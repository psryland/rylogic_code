/*
 *  Authors:  Benton Stark
 *
 *  Copyright (c) 2007-2009 Starksoft, LLC (http://www.starksoft.com)
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 */

using System;
using System.ComponentModel;
using System.Diagnostics;
using System.Globalization;
using System.Net;
using System.Runtime.Serialization;
using System.Text;
using System.Net.Sockets;
using System.Threading;

namespace pr.inet
{
	/// <summary>Proxy client interface.  This is the interface that all proxy clients must implement.</summary>
	public interface IProxyClient
	{
		/// <summary>Event handler for CreateConnectionAsync method completed.</summary>
		event EventHandler<CreateConnectionAsyncCompletedEventArgs> CreateConnectionAsyncCompleted;
		
		/// <summary>Gets or sets proxy host name or IP address.</summary>
		string ProxyHost { get; set; }
		
		/// <summary>Gets or sets proxy port number.</summary>
		int ProxyPort { get; set; }
		
		/// <summary>Gets String representing the name of the proxy.</summary>
		string ProxyName { get; }
		
		/// <summary>Gets or set the TcpClient object if one was specified in the constructor.</summary>
		TcpClient TcpClient { get; set; }
		
		/// <summary>Creates a remote TCP connection through a proxy server to the destination host on the destination port.</summary>
		/// <param name="destination_host">Destination host name or IP address.</param>
		/// <param name="destination_port">Port number to connect to on the destination host.</param>
		/// <returns>Returns an open TcpClient object that can be used normally to communicate with the destination server</returns>
		/// <remarks>
		/// This method creates a connection to the proxy server and instructs the proxy server
		/// to make a pass through connection to the specified destination host on the specified
		/// port.</remarks>
		TcpClient CreateConnection(string destination_host, int destination_port);
		
		/// <summary>Asynchronously creates a remote TCP connection through a proxy server to the destination host on the destination port.</summary>
		/// <param name="destination_host">Destination host name or IP address.</param>
		/// <param name="destination_port">Port number to connect to on the destination host.</param>
		/// <returns>Returns an open TcpClient object that can be used normally to communicate with the destination server</returns>
		/// <remarks>
		/// This method creates a connection to the proxy server and instructs the proxy server
		/// to make a pass through connection to the specified destination host on the specified
		/// port.</remarks>
		void CreateConnectionAsync(string destination_host, int destination_port);
	}
	
	/// <summary>The type of proxy.</summary>
	public enum ProxyType
	{
		/// <summary>No Proxy specified.  Note this option will cause an exception to be thrown if used to create a proxy object by the factory.</summary>
		None,
		
		/// <summary>HTTP Proxy</summary>
		Http,
		
		/// <summary>SOCKS v4 Proxy</summary>
		Socks4,
		
		/// <summary>SOCKS v4a Proxy</summary>
		Socks4A,
		
		/// <summary>SOCKS v5 Proxy</summary>
		Socks5
	}
	
	/// <summary>Event arguments class for the EncryptAsyncCompleted event.</summary>
	public class CreateConnectionAsyncCompletedEventArgs : AsyncCompletedEventArgs
	{
		private readonly TcpClient m_proxy_connection;
		
		/// <summary>Constructor.</summary>
		/// <param name="error">Exception information generated by the event.</param>
		/// <param name="cancelled">Cancelled event flag.  This flag is set to true if the event was cancelled.</param>
		/// <param name="proxy_connection">Proxy Connection.  The initialized and open TcpClient proxy connection.</param>
		public CreateConnectionAsyncCompletedEventArgs(Exception error, bool cancelled, TcpClient proxy_connection)
		:base(error, cancelled, null)
		{
			m_proxy_connection = proxy_connection;
		}
		
		/// <summary>The proxy connection.</summary>
		public TcpClient ProxyConnection
		{
			get { return m_proxy_connection; }
		}
	}
	
	/// <summary>Factory class for creating new proxy client objects.</summary>
	/// <remarks>
	/// <code>
	/// // create an instance of the client proxy factory
	/// ProxyClientFactory factory = new ProxyClientFactory();
	///
	/// // use the proxy client factory to generically specify the type of proxy to create
	/// // the proxy factory method CreateProxyClient returns an IProxyClient object
	/// IProxyClient proxy = factory.CreateProxyClient(ProxyType.Http, "localhost", 6588);
	///
	/// // create a connection through the proxy to www.starksoft.com over port 80
	/// System.Net.Sockets.TcpClient tcpClient = proxy.CreateConnection("www.starksoft.com", 80);
	/// </code>
	/// </remarks>
	public class ProxyClientFactory
	{
		/// <summary>Factory method for creating new proxy client objects.</summary>
		/// <param name="type">The type of proxy client to create.</param>
		/// <returns>Proxy client object.</returns>
		public IProxyClient CreateProxyClient(ProxyType type)
		{
			switch (type)
			{
			default: throw new ProxyException(String.Format("Unknown proxy type {0}.", type.ToString()));
			case ProxyType.None:    throw new ArgumentOutOfRangeException("type");
			case ProxyType.Http:    return new HttpProxyClient();
			case ProxyType.Socks4:  return new Socks4ProxyClient();
			case ProxyType.Socks4A: return new Socks4AProxyClient();
			case ProxyType.Socks5:  return new Socks5ProxyClient();
			}
		}
		
		/// <summary>Factory method for creating new proxy client objects using an existing TcpClient connection object.</summary>
		/// <param name="type">The type of proxy client to create.</param>
		/// <param name="tcp_client">Open TcpClient object.</param>
		/// <returns>Proxy client object.</returns>
		public IProxyClient CreateProxyClient(ProxyType type, TcpClient tcp_client)
		{
				
			switch (type)
			{
			default: throw new ProxyException(String.Format("Unknown proxy type {0}.", type.ToString()));
			case ProxyType.None:    throw new ArgumentOutOfRangeException("type");
			case ProxyType.Http:    return new HttpProxyClient(tcp_client);
			case ProxyType.Socks4:  return new Socks4ProxyClient(tcp_client);
			case ProxyType.Socks4A: return new Socks4AProxyClient(tcp_client);
			case ProxyType.Socks5:  return new Socks5ProxyClient(tcp_client);
			}
		}
		
		/// <summary>Factory method for creating new proxy client objects.</summary>
		/// <param name="type">The type of proxy client to create.</param>
		/// <param name="proxy_host">The proxy host or IP address.</param>
		/// <param name="proxy_port">The proxy port number.</param>
		/// <returns>Proxy client object.</returns>
		public IProxyClient CreateProxyClient(ProxyType type, string proxy_host, int proxy_port)
		{
			switch (type)
			{
			default: throw new ProxyException(String.Format("Unknown proxy type {0}.", type));
			case ProxyType.None:    throw new ArgumentOutOfRangeException("type");
			case ProxyType.Http:    return new HttpProxyClient(proxy_host, proxy_port);
			case ProxyType.Socks4:  return new Socks4ProxyClient(proxy_host, proxy_port);
			case ProxyType.Socks4A: return new Socks4AProxyClient(proxy_host, proxy_port);
			case ProxyType.Socks5:  return new Socks5ProxyClient(proxy_host, proxy_port);
			}
		}
		
		/// <summary>Factory method for creating new proxy client objects.</summary>
		/// <param name="type">The type of proxy client to create.</param>
		/// <param name="proxy_host">The proxy host or IP address.</param>
		/// <param name="proxy_port">The proxy port number.</param>
		/// <param name="proxy_username">The proxy username.  This parameter is only used by Socks4 and Socks5 proxy objects.</param>
		/// <param name="proxy_password">The proxy user password.  This parameter is only used Socks5 proxy objects.</param>
		/// <returns>Proxy client object.</returns>
		public IProxyClient CreateProxyClient(ProxyType type, string proxy_host, int proxy_port, string proxy_username, string proxy_password)
		{
			switch (type)
			{
			default: throw new ProxyException(String.Format("Unknown proxy type {0}.", type));
			case ProxyType.None:    throw new ArgumentOutOfRangeException("type");
			case ProxyType.Http:    return new HttpProxyClient(proxy_host, proxy_port);
			case ProxyType.Socks4:  return new Socks4ProxyClient(proxy_host, proxy_port, proxy_username);
			case ProxyType.Socks4A: return new Socks4AProxyClient(proxy_host, proxy_port, proxy_username);
			case ProxyType.Socks5:  return new Socks5ProxyClient(proxy_host, proxy_port, proxy_username, proxy_password);
			}
		}
		
		/// <summary>Factory method for creating new proxy client objects.</summary>
		/// <param name="type">The type of proxy client to create.</param>
		/// <param name="tcp_client">Open TcpClient object.</param>
		/// <param name="proxy_host">The proxy host or IP address.</param>
		/// <param name="proxy_port">The proxy port number.</param>
		/// <param name="proxy_username">The proxy username.  This parameter is only used by Socks4 and Socks5 proxy objects.</param>
		/// <param name="proxy_password">The proxy user password.  This parameter is only used Socks5 proxy objects.</param>
		/// <returns>Proxy client object.</returns>
		public IProxyClient CreateProxyClient(ProxyType type, TcpClient tcp_client, string proxy_host, int proxy_port, string proxy_username, string proxy_password)
		{
			IProxyClient c = CreateProxyClient(type, proxy_host, proxy_port, proxy_username, proxy_password);
			c.TcpClient = tcp_client;
			return c;
		}
	}
	
	/// <summary>
	/// HTTP connection proxy class.  This class implements the HTTP standard proxy protocol.
	/// <para>
	/// You can use this class to set up a connection to an HTTP proxy server.  Calling the
	/// CreateConnection() method initiates the proxy connection and returns a standard
	/// System.Net.Socks.TcpClient object that can be used as normal.  The proxy plumbing
	/// is all handled for you.
	/// </para>
	/// <code>
	/// </code>
	/// </summary>
	public class HttpProxyClient : IProxyClient
	{
		private string m_proxy_host;
		private int m_proxy_port;
		private HttpResponseCodes m_resp_code;
		private string m_resp_text;
		private TcpClient m_tcp_client;
		
		private const int HttpProxyDefaultPort = 8080;
		private const string HttpProxyConnectCmd = "CONNECT {0}:{1} HTTP/1.0 \r\nHOST {0}:{1}\r\n\r\n";
		private const int WaitForDataInterval = 50; // 50 ms
		private const int WaitForDataTimeout = 15000; // 15 seconds
		
		// ReSharper disable UnusedMember.Local
		private enum HttpResponseCodes
		{
			None = 0,
			Continue = 100,
			SwitchingProtocols = 101,
			Ok = 200,
			Created = 201,
			Accepted = 202,
			NonAuthoritiveInformation = 203,
			NoContent = 204,
			ResetContent = 205,
			PartialContent = 206,
			MultipleChoices = 300,
			MovedPermanetly = 301,
			Found = 302,
			SeeOther = 303,
			NotModified = 304,
			UserProxy = 305,
			TemporaryRedirect = 307,
			BadRequest = 400,
			Unauthorized = 401,
			PaymentRequired = 402,
			Forbidden = 403,
			NotFound = 404,
			MethodNotAllowed = 405,
			NotAcceptable = 406,
			ProxyAuthenticantionRequired = 407,
			RequestTimeout = 408,
			Conflict = 409,
			Gone = 410,
			PreconditionFailed = 411,
			RequestEntityTooLarge = 413,
			RequestUriTooLong = 414,
			UnsupportedMediaType = 415,
			RequestedRangeNotSatisfied = 416,
			ExpectationFailed = 417,
			InternalServerError = 500,
			NotImplemented = 501,
			BadGateway = 502,
			ServiceUnavailable = 503,
			GatewayTimeout = 504,
			HttpVersionNotSupported = 505
		}
		// ReSharper restore UnusedMember.Local

		/// <summary>Constructor.</summary>
		public HttpProxyClient() {}
		
		/// <summary>Creates a HTTP proxy client object using the supplied TcpClient object connection.</summary>
		/// <param name="tcp_client">A TcpClient connection object.</param>
		public HttpProxyClient(TcpClient tcp_client)
		{
			if (tcp_client == null) throw new ArgumentNullException("tcp_client");
			m_tcp_client = tcp_client;
		}
		
		/// <summary> Constructor. The default HTTP proxy port 8080 is used.</summary>
		/// <param name="proxy_host">Host name or IP address of the proxy.</param>
		public HttpProxyClient(string proxy_host)
		{
			if (String.IsNullOrEmpty(proxy_host)) throw new ArgumentNullException("proxy_host");
			m_proxy_host = proxy_host;
			m_proxy_port = HttpProxyDefaultPort;
		}
		
		/// <summary>Constructor.</summary>
		/// <param name="proxy_host">Host name or IP address of the proxy server.</param>
		/// <param name="proxy_port">Port number for the proxy server.</param>
		public HttpProxyClient(string proxy_host, int proxy_port)
		{
			if (String.IsNullOrEmpty(proxy_host))
				throw new ArgumentNullException("proxy_host");
				
			if (proxy_port <= 0 || proxy_port > 65535)
				throw new ArgumentOutOfRangeException("proxy_port", "port must be greater than zero and less than 65535");
				
			m_proxy_host = proxy_host;
			m_proxy_port = proxy_port;
		}
		
		/// <summary>Gets or sets host name or IP address of the proxy server.</summary>
		public string ProxyHost
		{
			get { return m_proxy_host; }
			set { m_proxy_host = value; }
		}
		
		/// <summary>Gets or sets port number for the proxy server.</summary>
		public int ProxyPort
		{
			get { return m_proxy_port; }
			set { m_proxy_port = value; }
		}
		
		/// <summary>Gets String representing the name of the proxy.</summary>
		/// <remarks>This property will always return the value 'HTTP'</remarks>
		public string ProxyName
		{
			get { return "HTTP"; }
		}
		
		/// <summary>
		/// Gets or sets the TcpClient object.
		/// This property can be set prior to executing CreateConnection to use an existing TcpClient connection.
		/// </summary>
		public TcpClient TcpClient
		{
			get { return m_tcp_client; }
			set { m_tcp_client = value; }
		}
		
		/// <summary>Creates a remote TCP connection through a proxy server to the destination host on the destination port.</summary>
		/// <param name="destination_host">Destination host name or IP address.</param>
		/// <param name="destination_port">Port number to connect to on the destination host.</param>
		/// <returns>
		/// Returns an open TcpClient object that can be used normally to communicate
		/// with the destination server
		/// </returns>
		/// <remarks>
		/// This method creates a connection to the proxy server and instructs the proxy server
		/// to make a pass through connection to the specified destination host on the specified
		/// port.</remarks>
		public TcpClient CreateConnection(string destination_host, int destination_port)
		{
			try
			{
				// if we have no connection, create one
				if (m_tcp_client == null)
				{
					if (String.IsNullOrEmpty(m_proxy_host))
						throw new ProxyException("ProxyHost property must contain a value.");
						
					if (m_proxy_port <= 0 || m_proxy_port > 65535)
						throw new ProxyException("ProxyPort value must be greater than zero and less than 65535");
						
					//  create new tcp client object to the proxy server
					m_tcp_client = new TcpClient();
					
					// attempt to open the connection
					m_tcp_client.Connect(m_proxy_host, m_proxy_port);
				}
				
				//  send connection command to proxy host for the specified destination host and port
				SendConnectionCommand(destination_host, destination_port);
				
				// return the open proxied tcp client object to the caller for normal use
				return m_tcp_client;
			}
			catch (SocketException ex)
			{
				throw new ProxyException(String.Format(CultureInfo.InvariantCulture, "Connection to proxy host {0} on port {1} failed.", Utils.GetHost(m_tcp_client), Utils.GetPort(m_tcp_client)), ex);
			}
		}
		
		private void SendConnectionCommand(string host, int port)
		{
			NetworkStream stream = m_tcp_client.GetStream();
			
			// PROXY SERVER REQUEST
			// =======================================================================
			//CONNECT starksoft.com:443 HTTP/1.0 <CR><LF>
			//HOST starksoft.com:443<CR><LF>
			//[... other HTTP header lines ending with <CR><LF> if required]>
			//<CR><LF>    // Last Empty Line
			
			string connect_cmd = String.Format(CultureInfo.InvariantCulture, HttpProxyConnectCmd, host, port.ToString(CultureInfo.InvariantCulture));
			byte[] request = Encoding.ASCII.GetBytes(connect_cmd);
			
			// send the connect request
			stream.Write(request, 0, request.Length);
			
			// wait for the proxy server to respond
			WaitForData(stream);
			
			// PROXY SERVER RESPONSE
			// =======================================================================
			//HTTP/1.0 200 Connection Established<CR><LF>
			//[.... other HTTP header lines ending with <CR><LF>..
			//ignore all of them]
			//<CR><LF>    // Last Empty Line
			
			// create an byte response array
			byte[] response = new byte[m_tcp_client.ReceiveBufferSize];
			StringBuilder sbuilder = new StringBuilder();

			do
			{
				int bytes = stream.Read(response, 0, m_tcp_client.ReceiveBufferSize);
				sbuilder.Append(Encoding.UTF8.GetString(response, 0, bytes));
			}
			while (stream.DataAvailable);
			
			ParseResponse(sbuilder.ToString());
			
			//  evaluate the reply code for an error condition
			if (m_resp_code != HttpResponseCodes.Ok)
				HandleProxyCommandError();
		}
		
		private void HandleProxyCommandError()
		{
			string msg;
			switch (m_resp_code)
			{
			case HttpResponseCodes.None:
				msg = String.Format(CultureInfo.InvariantCulture, "Proxy destination {0} on port {1} failed to return a recognized HTTP response code.  Server response: {2}", Utils.GetHost(m_tcp_client), Utils.GetPort(m_tcp_client), m_resp_text);
				break;
			case HttpResponseCodes.BadGateway:
				//HTTP/1.1 502 Proxy Error (The specified Secure Sockets Layer (SSL) port is not allowed. ISA Server is not configured to allow SSL requests from this port. Most Web browsers use port 443 for SSL requests.)
				msg = String.Format(CultureInfo.InvariantCulture, "Proxy destination {0} on port {1} responded with a 502 code - Bad Gateway.  If you are connecting to a Microsoft ISA destination please refer to knowledge based article Q283284 for more information.  Server response: {2}", Utils.GetHost(m_tcp_client), Utils.GetPort(m_tcp_client), m_resp_text);
				break;
			default:
				msg = String.Format(CultureInfo.InvariantCulture, "Proxy destination {0} on port {1} responded with a {2} code - {3}", Utils.GetHost(m_tcp_client), Utils.GetPort(m_tcp_client), ((int)m_resp_code).ToString(CultureInfo.InvariantCulture), m_resp_text);
				break;
			}

			//  throw a new application exception
			throw new ProxyException(msg);
		}
		
		private void WaitForData(NetworkStream stream)
		{
			int sleep_time = 0;
			while (!stream.DataAvailable)
			{
				Thread.Sleep(WaitForDataInterval);
				sleep_time += WaitForDataInterval;
				if (sleep_time > WaitForDataTimeout)
					throw new ProxyException(String.Format("A timeout while waiting for the proxy server at {0} on port {1} to respond.", Utils.GetHost(m_tcp_client), Utils.GetPort(m_tcp_client)));
			}
		}
		
		private void ParseResponse(string response)
		{
			//  get rid of the LF character if it exists and then split the string on all CR
			string[] data = response.Replace('\n', ' ').Split('\r');
			ParseCodeAndText(data[0]);
		}

		private void ParseCodeAndText(string line)
		{
			Debug.Assert(line != null, "line != null");
			if (line.IndexOf("HTTP", StringComparison.Ordinal) == -1)
				throw new ProxyException(String.Format("No HTTP response received from proxy destination.  Server response: {0}.", line));
				
			int begin = line.IndexOf(" ", StringComparison.Ordinal) + 1;
			int end = line.IndexOf(" ", begin, StringComparison.Ordinal);
			string val = line.Substring(begin, end - begin);
			
			Int32 code;
			if (!Int32.TryParse(val, out code))
				throw new ProxyException(String.Format("An invalid response code was received from proxy destination.  Server response: {0}.", line));
				
			m_resp_code = (HttpResponseCodes)code;
			m_resp_text = line.Substring(end + 1).Trim();
		}

		private BackgroundWorker m_async_worker;
		private Exception m_async_exception;
		bool m_async_cancelled;
		
		/// <summary>Gets a value indicating whether an asynchronous operation is running.</summary>
		/// <remarks>Returns true if an asynchronous operation is running; otherwise, false.</remarks>
		public bool IsBusy
		{
			get { return m_async_worker != null && m_async_worker.IsBusy; }
		}
		
		/// <summary>
		/// Gets a value indicating whether an asynchronous operation is cancelled.
		/// </summary>
		/// <remarks>Returns true if an asynchronous operation is cancelled; otherwise, false.
		/// </remarks>
		public bool IsAsyncCancelled
		{
			get { return m_async_cancelled; }
		}
		
		/// <summary>
		/// Cancels any asychronous operation that is currently active.
		/// </summary>
		public void CancelAsync()
		{
			if (m_async_worker != null && !m_async_worker.CancellationPending && m_async_worker.IsBusy)
			{
				m_async_cancelled = true;
				m_async_worker.CancelAsync();
			}
		}
		
		/// <summary>
		/// Event handler for CreateConnectionAsync method completed.
		/// </summary>
		public event EventHandler<CreateConnectionAsyncCompletedEventArgs> CreateConnectionAsyncCompleted;
		
		/// <summary>
		/// Asynchronously creates a remote TCP connection through a proxy server to the destination host on the destination port.
		/// </summary>
		/// <param name="destination_host">Destination host name or IP address.</param>
		/// <param name="destination_port">Port number to connect to on the destination host.</param>
		/// <returns>
		/// Returns an open TcpClient object that can be used normally to communicate
		/// with the destination server
		/// </returns>
		/// <remarks>
		/// This method creates a connection to the proxy server and instructs the proxy server
		/// to make a pass through connection to the specified destination host on the specified
		/// port.
		/// </remarks>
		public void CreateConnectionAsync(string destination_host, int destination_port)
		{
			if (m_async_worker != null && m_async_worker.IsBusy)
				throw new InvalidOperationException("The HttpProxy object is already busy executing another asynchronous operation.  You can only execute one asychronous method at a time.");
				
			if (m_async_worker != null) m_async_worker.Dispose();
			m_async_exception = null;
			m_async_worker = null;
			m_async_cancelled = false;
			m_async_worker = new BackgroundWorker();
			m_async_worker.WorkerSupportsCancellation = true;
			m_async_worker.DoWork += CreateConnectionAsync_DoWork;
			m_async_worker.RunWorkerCompleted += CreateConnectionAsync_RunWorkerCompleted;
			Object[] args = new Object[2];
			args[0] = destination_host;
			args[1] = destination_port;
			m_async_worker.RunWorkerAsync(args);
		}
		
		private void CreateConnectionAsync_DoWork(object sender, DoWorkEventArgs e)
		{
			try
			{
				Object[] args = (Object[])e.Argument;
				e.Result = CreateConnection((string)args[0], (int)args[1]);
			}
			catch (Exception ex)
			{
				m_async_exception = ex;
			}
		}
		
		private void CreateConnectionAsync_RunWorkerCompleted(object sender, RunWorkerCompletedEventArgs e)
		{
			if (CreateConnectionAsyncCompleted != null)
				CreateConnectionAsyncCompleted(this, new CreateConnectionAsyncCompletedEventArgs(m_async_exception, m_async_cancelled, (TcpClient)e.Result));
		}
	}
	
	/// <summary>
	/// Socks4a connection proxy class.  This class implements the Socks4a standard proxy protocol
	/// which is an extension of the Socks4 protocol
	/// </summary>
	/// <remarks>
	/// In Socks version 4A if the client cannot resolve the destination host's domain name
	/// to find its IP address the server will attempt to resolve it.
	/// </remarks>
	public class Socks4AProxyClient : Socks4ProxyClient
	{
		/// <summary>Default constructor.</summary>
		public Socks4AProxyClient() {}
		
		/// <summary>Creates a Socks4 proxy client object using the supplied TcpClient object connection.</summary>
		/// <param name="tcp_client">An open TcpClient object with an established connection.</param>
		public Socks4AProxyClient(TcpClient tcp_client)
		:base(tcp_client)
		{}
		
		/// <summary>
		/// Create a Socks4a proxy client object.  The default proxy port 1080 is used.
		/// </summary>
		/// <param name="proxy_host">Host name or IP address of the proxy server.</param>
		/// <param name="proxy_user_id">Proxy user identification information for an IDENTD server.</param>
		public Socks4AProxyClient(string proxy_host, string proxy_user_id)
		:base(proxy_host, proxy_user_id)
		{}
		
		/// <summary>
		/// Create a Socks4a proxy client object.
		/// </summary>
		/// <param name="proxy_host">Host name or IP address of the proxy server.</param>
		/// <param name="proxy_port">Port used to connect to proxy server.</param>
		/// <param name="proxy_user_id">Proxy user identification information.</param>
		public Socks4AProxyClient(string proxy_host, int proxy_port, string proxy_user_id)
		:base(proxy_host, proxy_port, proxy_user_id)
		{}
		
		/// <summary>
		/// Create a Socks4 proxy client object.  The default proxy port 1080 is used.
		/// </summary>
		/// <param name="proxy_host">Host name or IP address of the proxy server.</param>
		public Socks4AProxyClient(string proxy_host) : base(proxy_host)
		{ }
		
		/// <summary>
		/// Create a Socks4a proxy client object.
		/// </summary>
		/// <param name="proxy_host">Host name or IP address of the proxy server.</param>
		/// <param name="proxy_port">Port used to connect to proxy server.</param>
		public Socks4AProxyClient(string proxy_host, int proxy_port)
		: base(proxy_host, proxy_port)
		{  }
		
		/// <summary>
		/// Gets String representing the name of the proxy.
		/// </summary>
		/// <remarks>This property will always return the value 'SOCKS4a'</remarks>
		public override string ProxyName
		{
			get { return "SOCKS4a"; }
		}
		
		/// <summary>
		/// Sends a command to the proxy server.
		/// </summary>
		/// <param name="proxy">Proxy server data stream.</param>
		/// <param name="command">Proxy byte command to execute.</param>
		/// <param name="destination_host">Destination host name or IP address.</param>
		/// <param name="destination_port">Destination port number</param>
		/// <param name="user_id">IDENTD user ID value.</param>
		/// <remarks>
		/// This method override the SendCommand message in the Sock4ProxyClient object.  The override adds support for the
		/// Socks4a extensions which allow the proxy client to optionally command the proxy server to resolve the
		/// destination host IP address.
		/// </remarks>
		protected override void SendCommand(NetworkStream proxy, byte command, string destination_host, int destination_port, string user_id)
		{
			// PROXY SERVER REQUEST
			//Please read SOCKS4.protocol first for an description of the version 4
			//protocol. This extension is intended to allow the use of SOCKS on hosts
			//which are not capable of resolving all domain names.
			//
			//In version 4, the client sends the following packet to the SOCKS server
			//to request a CONNECT or a BIND operation:
			//
			//        +----+----+----+----+----+----+----+----+----+----+....+----+
			//        | VN | CD | DSTPORT |      DSTIP        | USERID       |NULL|
			//        +----+----+----+----+----+----+----+----+----+----+....+----+
			// # of bytes:     1    1      2              4           variable       1
			//
			//VN is the SOCKS protocol version number and should be 4. CD is the
			//SOCKS command code and should be 1 for CONNECT or 2 for BIND. NULL
			//is a byte of all zero bits.
			//
			//For version 4A, if the client cannot resolve the destination host's
			//domain name to find its IP address, it should set the first three bytes
			//of DSTIP to NULL and the last byte to a non-zero value. (This corresponds
			//to IP address 0.0.0.x, with x nonzero. As decreed by IANA  -- The
			//Internet Assigned Numbers Authority -- such an address is inadmissible
			//as a destination IP address and thus should never occur if the client
			//can resolve the domain name.) Following the NULL byte terminating
			//USERID, the client must sends the destination domain name and termiantes
			//it with another NULL byte. This is used for both CONNECT and BIND requests.
			//
			//A server using protocol 4A must check the DSTIP in the request packet.
			//If it represent address 0.0.0.x with nonzero x, the server must read
			//in the domain name that the client sends in the packet. The server
			//should resolve the domain name and make connection to the destination
			//host if it can.
			//
			//SOCKSified sockd may pass domain names that it cannot resolve to
			//the next-hop SOCKS server.
			
			//  userId needs to be a zero length string so that the GetBytes method
			//  works properly
			if (user_id == null)
				user_id = "";
				
			byte[] dest_ip = {0,0,0,1};  // build the invalid ip address as specified in the 4a protocol
			byte[] dest_port = GetDestinationPortBytes(destination_port);
			byte[] user_id_bytes = Encoding.ASCII.GetBytes(user_id);
			byte[] host_bytes = Encoding.ASCII.GetBytes(destination_host);
			byte[] request = new byte[10 + user_id_bytes.Length + host_bytes.Length];
			
			//  set the bits on the request byte array
			request[0] = SOCKS4_VERSION_NUMBER;
			request[1] = command;
			dest_port.CopyTo(request, 2);
			dest_ip.CopyTo(request, 4);
			user_id_bytes.CopyTo(request, 8);  // copy the userid to the request byte array
			request[8 + user_id_bytes.Length] = 0x00;  // null (byte with all zeros) terminator for userId
			host_bytes.CopyTo(request, 9 + user_id_bytes.Length);  // copy the host name to the request byte array
			request[9 + user_id_bytes.Length + host_bytes.Length] = 0x00;  // null (byte with all zeros) terminator for userId
			
			// send the connect request
			proxy.Write(request, 0, request.Length);
			
			// wait for the proxy server to send a response
			WaitForData(proxy);
			
			// PROXY SERVER RESPONSE
			// The SOCKS server checks to see whether such a request should be granted
			// based on any combination of source IP address, destination IP address,
			// destination port number, the userid, and information it may obtain by
			// consulting IDENT, cf. RFC 1413.  If the request is granted, the SOCKS
			// server makes a connection to the specified port of the destination host.
			// A reply packet is sent to the client when this connection is established,
			// or when the request is rejected or the operation fails.
			//
			//        +----+----+----+----+----+----+----+----+
			//        | VN | CD | DSTPORT |      DSTIP        |
			//        +----+----+----+----+----+----+----+----+
			// # of bytes:     1    1      2              4
			//
			// VN is the version of the reply code and should be 0. CD is the result
			// code with one of the following values:
			//
			//    90: request granted
			//    91: request rejected or failed
			//    92: request rejected becuase SOCKS server cannot connect to
			//        identd on the client
			//    93: request rejected because the client program and identd
			//        report different user-ids
			//
			// The remaining fields are ignored.
			//
			// The SOCKS server closes its connection immediately after notifying
			// the client of a failed or rejected request. For a successful request,
			// the SOCKS server gets ready to relay traffic on both directions. This
			// enables the client to do I/O on its connection as if it were directly
			// connected to the application server.
			
			// create an 8 byte response array
			byte[] response = new byte[8];
			
			// read the resonse from the network stream
			proxy.Read(response, 0, 8);
			
			//  evaluate the reply code for an error condition
			if (response[1] != SOCKS4_CMD_REPLY_REQUEST_GRANTED)
				HandleProxyCommandError(response, destination_host, destination_port);
		}
	}
	
	/// <summary>
	/// Socks4 connection proxy class.  This class implements the Socks4 standard proxy protocol.
	/// </summary>
	/// <remarks>
	/// This class implements the Socks4 proxy protocol standard for TCP communciations.
	/// </remarks>
	public class Socks4ProxyClient : IProxyClient
	{
		private const int WaitForDataInterval = 50;   // 50 ms
		private const int WaitForDataTimeout = 15000; // 15 seconds
		private TcpClient m_tcp_client;
		
		private string m_proxy_host;
		private int m_proxy_port;
		private string m_proxy_user_id;
		
		// ReSharper disable InconsistentNaming
		/// <summary>Default Socks4 proxy port.</summary>
		internal const int SOCKS_PROXY_DEFAULT_PORT = 1080;
		/// <summary>Socks4 version number.</summary>
		internal const byte SOCKS4_VERSION_NUMBER = 4;
		/// <summary>Socks4 connection command value.</summary>
		internal const byte SOCKS4_CMD_CONNECT = 0x01;
		/// <summary>Socks4 bind command value.</summary>
		internal const byte SOCKS4_CMD_BIND = 0x02;
		/// <summary>Socks4 reply request grant response value.</summary>
		internal const byte SOCKS4_CMD_REPLY_REQUEST_GRANTED = 90;
		/// <summary>Socks4 reply request rejected or failed response value.</summary>
		internal const byte SOCKS4_CMD_REPLY_REQUEST_REJECTED_OR_FAILED = 91;
		/// <summary>Socks4 reply request rejected becauase the proxy server can not connect to the IDENTD server value.</summary>
		internal const byte SOCKS4_CMD_REPLY_REQUEST_REJECTED_CANNOT_CONNECT_TO_IDENTD = 92;
		/// <summary>Socks4 reply request rejected because of a different IDENTD server.</summary>
		internal const byte SOCKS4_CMD_REPLY_REQUEST_REJECTED_DIFFERENT_IDENTD = 93;
		// ReSharper restore InconsistentNaming
		
		/// <summary>Create a Socks4 proxy client object.  The default proxy port 1080 is used.</summary>
		public Socks4ProxyClient() { }
		
		/// <summary>Creates a Socks4 proxy client object using the supplied TcpClient object connection.</summary>
		/// <param name="tcp_client">A TcpClient connection object.</param>
		public Socks4ProxyClient(TcpClient tcp_client)
		{
			if (tcp_client == null)
				throw new ArgumentNullException("tcp_client");
				
			m_tcp_client = tcp_client;
		}
		
		/// <summary>Create a Socks4 proxy client object.  The default proxy port 1080 is used.</summary>
		/// <param name="proxy_host">Host name or IP address of the proxy server.</param>
		/// <param name="proxy_user_id">Proxy user identification information.</param>
		protected Socks4ProxyClient(string proxy_host, string proxy_user_id)
		{
			if (String.IsNullOrEmpty(proxy_host))
				throw new ArgumentNullException("proxy_host");
				
			if (proxy_user_id == null)
				throw new ArgumentNullException("proxy_user_id");
				
			m_proxy_host = proxy_host;
			m_proxy_port = SOCKS_PROXY_DEFAULT_PORT;
			m_proxy_user_id = proxy_user_id;
		}
		
		/// <summary>Create a Socks4 proxy client object.</summary>
		/// <param name="proxy_host">Host name or IP address of the proxy server.</param>
		/// <param name="proxy_port">Port used to connect to proxy server.</param>
		/// <param name="proxy_user_id">Proxy user identification information.</param>
		public Socks4ProxyClient(string proxy_host, int proxy_port, string proxy_user_id)
		{
			if (String.IsNullOrEmpty(proxy_host))
				throw new ArgumentNullException("proxy_host");
				
			if (proxy_port <= 0 || proxy_port > 65535)
				throw new ArgumentOutOfRangeException("proxy_port", "port must be greater than zero and less than 65535");
				
			if (proxy_user_id == null)
				throw new ArgumentNullException("proxy_user_id");
				
			m_proxy_host = proxy_host;
			m_proxy_port = proxy_port;
			m_proxy_user_id = proxy_user_id;
		}
		
		/// <summary>
		/// Create a Socks4 proxy client object.  The default proxy port 1080 is used.
		/// </summary>
		/// <param name="proxy_host">Host name or IP address of the proxy server.</param>
		protected Socks4ProxyClient(string proxy_host)
		{
			if (String.IsNullOrEmpty(proxy_host))
				throw new ArgumentNullException("proxy_host");
				
			m_proxy_host = proxy_host;
			m_proxy_port = SOCKS_PROXY_DEFAULT_PORT;
		}
		
		/// <summary>
		/// Create a Socks4 proxy client object.
		/// </summary>
		/// <param name="proxy_host">Host name or IP address of the proxy server.</param>
		/// <param name="proxy_port">Port used to connect to proxy server.</param>
		public Socks4ProxyClient(string proxy_host, int proxy_port)
		{
			if (String.IsNullOrEmpty(proxy_host))
				throw new ArgumentNullException("proxy_host");
				
			if (proxy_port <= 0 || proxy_port > 65535)
				throw new ArgumentOutOfRangeException("proxy_port", "port must be greater than zero and less than 65535");
				
			m_proxy_host = proxy_host;
			m_proxy_port = proxy_port;
		}
		
		/// <summary>Gets or sets host name or IP address of the proxy server.</summary>
		public string ProxyHost
		{
			get { return m_proxy_host; }
			set { m_proxy_host = value; }
		}
		
		/// <summary>Gets or sets port used to connect to proxy server.</summary>
		public int ProxyPort
		{
			get { return m_proxy_port; }
			set { m_proxy_port = value; }
		}
		
		/// <summary>Gets String representing the name of the proxy.</summary>
		/// <remarks>This property will always return the value 'SOCKS4'</remarks>
		virtual public string ProxyName
		{
			get { return "SOCKS4"; }
		}
		
		/// <summary>Gets or sets proxy user identification information.</summary>
		public string ProxyUserId
		{
			get { return m_proxy_user_id; }
			set { m_proxy_user_id = value; }
		}
		
		/// <summary>
		/// Gets or sets the TcpClient object.
		/// This property can be set prior to executing CreateConnection to use an existing TcpClient connection.
		/// </summary>
		public TcpClient TcpClient
		{
			get { return m_tcp_client; }
			set { m_tcp_client = value; }
		}
		
		/// <summary>
		/// Creates a TCP connection to the destination host through the proxy server
		/// host.
		/// </summary>
		/// <param name="destination_host">Destination host name or IP address of the destination server.</param>
		/// <param name="destination_port">Port number to connect to on the destination server.</param>
		/// <returns>
		/// Returns an open TcpClient object that can be used normally to communicate
		/// with the destination server
		/// </returns>
		/// <remarks>
		/// This method creates a connection to the proxy server and instructs the proxy server
		/// to make a pass through connection to the specified destination host on the specified
		/// port.
		/// </remarks>
		public TcpClient CreateConnection(string destination_host, int destination_port)
		{
			if (String.IsNullOrEmpty(destination_host))
				throw new ArgumentNullException("destination_host");
				
			if (destination_port <= 0 || destination_port > 65535)
				throw new ArgumentOutOfRangeException("destination_port", "port must be greater than zero and less than 65535");
				
			try
			{
				// if we have no connection, create one
				if (m_tcp_client == null)
				{
					if (String.IsNullOrEmpty(m_proxy_host))
						throw new ProxyException("ProxyHost property must contain a value.");
						
					if (m_proxy_port <= 0 || m_proxy_port > 65535)
						throw new ProxyException("ProxyPort value must be greater than zero and less than 65535");
						
					//  create new tcp client object to the proxy server
					m_tcp_client = new TcpClient();
					
					// attempt to open the connection
					m_tcp_client.Connect(m_proxy_host, m_proxy_port);
				}
				
				//  send connection command to proxy host for the specified destination host and port
				SendCommand(m_tcp_client.GetStream(), SOCKS4_CMD_CONNECT, destination_host, destination_port, m_proxy_user_id);
				
				// return the open proxied tcp client object to the caller for normal use
				return m_tcp_client;
			}
			catch (Exception ex)
			{
				throw new ProxyException(String.Format(CultureInfo.InvariantCulture, "Connection to proxy host {0} on port {1} failed.", Utils.GetHost(m_tcp_client), Utils.GetPort(m_tcp_client)), ex);
			}
		}
		
		
		/// <summary>
		/// Sends a command to the proxy server.
		/// </summary>
		/// <param name="proxy">Proxy server data stream.</param>
		/// <param name="command">Proxy byte command to execute.</param>
		/// <param name="destination_host">Destination host name or IP address.</param>
		/// <param name="destination_port">Destination port number</param>
		/// <param name="user_id">IDENTD user ID value.</param>
		protected virtual void SendCommand(NetworkStream proxy, byte command, string destination_host, int destination_port, string user_id)
		{
			// PROXY SERVER REQUEST
			// The client connects to the SOCKS server and sends a CONNECT request when
			// it wants to establish a connection to an application server. The client
			// includes in the request packet the IP address and the port number of the
			// destination host, and userid, in the following format.
			//
			//        +----+----+----+----+----+----+----+----+----+----+....+----+
			//        | VN | CD | DSTPORT |      DSTIP        | USERID       |NULL|
			//        +----+----+----+----+----+----+----+----+----+----+....+----+
			// # of bytes:     1    1      2              4           variable       1
			//
			// VN is the SOCKS protocol version number and should be 4. CD is the
			// SOCKS command code and should be 1 for CONNECT request. NULL is a byte
			// of all zero bits.
			
			//  userId needs to be a zero length string so that the GetBytes method
			//  works properly
			if (user_id == null)
				user_id = "";
				
			byte[] dest_ip = GetIPAddressBytes(destination_host);
			byte[] dest_port = GetDestinationPortBytes(destination_port);
			byte[] user_id_bytes = Encoding.ASCII.GetBytes(user_id);
			byte[] request = new byte[9 + user_id_bytes.Length];
			
			//  set the bits on the request byte array
			request[0] = SOCKS4_VERSION_NUMBER;
			request[1] = command;
			dest_port.CopyTo(request, 2);
			dest_ip.CopyTo(request, 4);
			user_id_bytes.CopyTo(request, 8);
			request[8 + user_id_bytes.Length] = 0x00;  // null (byte with all zeros) terminator for userId
			
			// send the connect request
			proxy.Write(request, 0, request.Length);
			
			// wait for the proxy server to respond
			WaitForData(proxy);
			
			// PROXY SERVER RESPONSE
			// The SOCKS server checks to see whether such a request should be granted
			// based on any combination of source IP address, destination IP address,
			// destination port number, the userid, and information it may obtain by
			// consulting IDENT, cf. RFC 1413.  If the request is granted, the SOCKS
			// server makes a connection to the specified port of the destination host.
			// A reply packet is sent to the client when this connection is established,
			// or when the request is rejected or the operation fails.
			//
			//        +----+----+----+----+----+----+----+----+
			//        | VN | CD | DSTPORT |      DSTIP        |
			//        +----+----+----+----+----+----+----+----+
			// # of bytes:     1    1      2              4
			//
			// VN is the version of the reply code and should be 0. CD is the result
			// code with one of the following values:
			//
			//    90: request granted
			//    91: request rejected or failed
			//    92: request rejected becuase SOCKS server cannot connect to
			//        identd on the client
			//    93: request rejected because the client program and identd
			//        report different user-ids
			//
			// The remaining fields are ignored.
			//
			// The SOCKS server closes its connection immediately after notifying
			// the client of a failed or rejected request. For a successful request,
			// the SOCKS server gets ready to relay traffic on both directions. This
			// enables the client to do I/O on its connection as if it were directly
			// connected to the application server.
			
			// create an 8 byte response array
			byte[] response = new byte[8];
			
			// read the resonse from the network stream
			proxy.Read(response, 0, 8);
			
			//  evaluate the reply code for an error condition
			if (response[1] != SOCKS4_CMD_REPLY_REQUEST_GRANTED)
				HandleProxyCommandError(response, destination_host, destination_port);
		}
		
		/// <summary>
		/// Translate the host name or IP address to a byte array.
		/// </summary>
		/// <param name="destination_host">Host name or IP address.</param>
		/// <returns>Byte array representing IP address in bytes.</returns>
		private static byte[] GetIPAddressBytes(string destination_host)
		{
			IPAddress ip_addr;
			
			//  if the address doesn't parse then try to resolve with dns
			if (!IPAddress.TryParse(destination_host, out ip_addr))
			{
				try
				{
					ip_addr = Dns.GetHostEntry(destination_host).AddressList[0];
				}
				catch (Exception ex)
				{
					throw new ProxyException(String.Format(CultureInfo.InvariantCulture, "A error occurred while attempting to DNS resolve the host name {0}.", destination_host), ex);
				}
			}
			
			// return address bytes
			return ip_addr.GetAddressBytes();
		}
		
		/// <summary>
		/// Translate the destination port value to a byte array.
		/// </summary>
		/// <param name="value">Destination port.</param>
		/// <returns>Byte array representing an 16 bit port number as two bytes.</returns>
		internal byte[] GetDestinationPortBytes(int value)
		{
			byte[] array = new byte[2];
			array[0] = Convert.ToByte(value / 256);
			array[1] = Convert.ToByte(value % 256);
			return array;
		}
		
		/// <summary>Receive a byte array from the proxy server and determine and handle and errors that may have occurred.</summary>
		/// <param name="response">Proxy server command response as a byte array.</param>
		/// <param name="destination_host">Destination host.</param>
		/// <param name="destination_port">Destination port number.</param>
		internal void HandleProxyCommandError(byte[] response, string destination_host, int destination_port)
		{
			if (response == null)
				throw new ArgumentNullException("response");
				
			// extract the reply code
			byte reply_code = response[1];
			
			//  extract the ip v4 address (4 bytes)
			byte[] ip_bytes = new byte[4];
			for (int i = 0; i < 4; i++)
				ip_bytes[i] = response[i + 4];
				
			//  convert the ip address to an IPAddress object
			IPAddress ip_addr = new IPAddress(ip_bytes);
			
			//  extract the port number big endian (2 bytes)
			byte[] port_bytes = new byte[2];
			port_bytes[0] = response[3];
			port_bytes[1] = response[2];
			Int16 port = BitConverter.ToInt16(port_bytes, 0);
			
			// translate the reply code error number to human readable text
			string proxy_error_text;
			switch (reply_code)
			{
			case SOCKS4_CMD_REPLY_REQUEST_REJECTED_OR_FAILED:
				proxy_error_text = "connection request was rejected or failed";
				break;
			case SOCKS4_CMD_REPLY_REQUEST_REJECTED_CANNOT_CONNECT_TO_IDENTD:
				proxy_error_text = "connection request was rejected because SOCKS destination cannot connect to identd on the client";
				break;
			case SOCKS4_CMD_REPLY_REQUEST_REJECTED_DIFFERENT_IDENTD:
				proxy_error_text = "connection request rejected because the client program and identd report different user-ids";
				break;
			default:
				proxy_error_text = String.Format(CultureInfo.InvariantCulture, "proxy client received an unknown reply with the code value '{0}' from the proxy destination", reply_code.ToString(CultureInfo.InvariantCulture));
				break;
			}
			
			//  build the exeception message string
			string exception_msg = String.Format(CultureInfo.InvariantCulture, "The {0} concerning destination host {1} port number {2}.  The destination reported the host as {3} port {4}.", proxy_error_text, destination_host, destination_port, ip_addr, port.ToString(CultureInfo.InvariantCulture));
			
			//  throw a new application exception
			throw new ProxyException(exception_msg);
		}
		
		internal void WaitForData(NetworkStream stream)
		{
			int sleep_time = 0;
			while (!stream.DataAvailable)
			{
				Thread.Sleep(WaitForDataInterval);
				sleep_time += WaitForDataInterval;
				if (sleep_time > WaitForDataTimeout)
					throw new ProxyException("A timeout while waiting for the proxy destination to respond.");
			}
		}
		
		
		#region "Async Methods"
		
		private BackgroundWorker m_async_worker;
		private Exception m_async_exception;
		bool m_async_cancelled;
		
		/// <summary>
		/// Gets a value indicating whether an asynchronous operation is running.
		/// </summary>
		/// <remarks>Returns true if an asynchronous operation is running; otherwise, false.
		/// </remarks>
		public bool IsBusy
		{
			get { return m_async_worker != null && m_async_worker.IsBusy; }
		}
		
		/// <summary>
		/// Gets a value indicating whether an asynchronous operation is cancelled.
		/// </summary>
		/// <remarks>Returns true if an asynchronous operation is cancelled; otherwise, false.
		/// </remarks>
		public bool IsAsyncCancelled
		{
			get { return m_async_cancelled; }
		}
		
		/// <summary>
		/// Cancels any asychronous operation that is currently active.
		/// </summary>
		public void CancelAsync()
		{
			if (m_async_worker != null && !m_async_worker.CancellationPending && m_async_worker.IsBusy)
			{
				m_async_cancelled = true;
				m_async_worker.CancelAsync();
			}
		}
		
		/// <summary>
		/// Event handler for CreateConnectionAsync method completed.
		/// </summary>
		public event EventHandler<CreateConnectionAsyncCompletedEventArgs> CreateConnectionAsyncCompleted;
		
		/// <summary>
		/// Asynchronously creates a remote TCP connection through a proxy server to the destination host on the destination port
		/// using the supplied open TcpClient object with an open connection to proxy server.
		/// </summary>
		/// <param name="destination_host">Destination host name or IP address.</param>
		/// <param name="destination_port">Port number to connect to on the destination host.</param>
		/// <returns>
		/// Returns TcpClient object that can be used normally to communicate
		/// with the destination server.
		/// </returns>
		/// <remarks>
		/// This instructs the proxy server to make a pass through connection to the specified destination host on the specified
		/// port.
		/// </remarks>
		public void CreateConnectionAsync(string destination_host, int destination_port)
		{
			if (m_async_worker != null && m_async_worker.IsBusy)
				throw new InvalidOperationException("The Socks4/4a object is already busy executing another asynchronous operation.  You can only execute one asychronous method at a time.");
				
			if (m_async_worker != null) m_async_worker.Dispose();
			m_async_exception = null;
			m_async_worker = null;
			m_async_cancelled = false;
			m_async_worker = new BackgroundWorker();
			m_async_worker.WorkerSupportsCancellation = true;
			m_async_worker.DoWork += CreateConnectionAsync_DoWork;
			m_async_worker.RunWorkerCompleted += CreateConnectionAsync_RunWorkerCompleted;
			Object[] args = new Object[2];
			args[0] = destination_host;
			args[1] = destination_port;
			m_async_worker.RunWorkerAsync(args);
		}
		
		private void CreateConnectionAsync_DoWork(object sender, DoWorkEventArgs e)
		{
			try
			{
				Object[] args = (Object[])e.Argument;
				e.Result = CreateConnection((string)args[0], (int)args[1]);
			}
			catch (Exception ex)
			{
				m_async_exception = ex;
			}
		}
		
		private void CreateConnectionAsync_RunWorkerCompleted(object sender, RunWorkerCompletedEventArgs e)
		{
			if (CreateConnectionAsyncCompleted != null)
				CreateConnectionAsyncCompleted(this, new CreateConnectionAsyncCompletedEventArgs(m_async_exception, m_async_cancelled, (TcpClient)e.Result));
		}
		
		#endregion
		
	}
	
	/// <summary>
	/// Socks5 connection proxy class.  This class implements the Socks5 standard proxy protocol.
	/// </summary>
	/// <remarks>
	/// This implementation supports TCP proxy connections with a Socks v5 server.
	/// </remarks>
	public class Socks5ProxyClient : IProxyClient
	{
		private string m_proxy_host;
		private int m_proxy_port;
		private string m_proxy_user_name;
		private string m_proxy_password;
		private SocksAuthentication m_proxy_auth_method;
		private TcpClient m_tcp_client;
		
		// ReSharper disable InconsistentNaming, UnusedMember.Local
		private const int SOCKS5_DEFAULT_PORT = 1080;
		private const byte SOCKS5_VERSION_NUMBER = 5;
		private const byte SOCKS5_RESERVED = 0x00;
		private const byte SOCKS5_AUTH_NUMBER_OF_AUTH_METHODS_SUPPORTED = 2;
		private const byte SOCKS5_AUTH_METHOD_NO_AUTHENTICATION_REQUIRED = 0x00;
		private const byte SOCKS5_AUTH_METHOD_GSSAPI = 0x01;
		private const byte SOCKS5_AUTH_METHOD_USERNAME_PASSWORD = 0x02;
		private const byte SOCKS5_AUTH_METHOD_IANA_ASSIGNED_RANGE_BEGIN = 0x03;
		private const byte SOCKS5_AUTH_METHOD_IANA_ASSIGNED_RANGE_END = 0x7f;
		private const byte SOCKS5_AUTH_METHOD_RESERVED_RANGE_BEGIN = 0x80;
		private const byte SOCKS5_AUTH_METHOD_RESERVED_RANGE_END = 0xfe;
		private const byte SOCKS5_AUTH_METHOD_REPLY_NO_ACCEPTABLE_METHODS = 0xff;
		private const byte SOCKS5_CMD_CONNECT = 0x01;
		private const byte SOCKS5_CMD_BIND = 0x02;
		private const byte SOCKS5_CMD_UDP_ASSOCIATE = 0x03;
		private const byte SOCKS5_CMD_REPLY_SUCCEEDED = 0x00;
		private const byte SOCKS5_CMD_REPLY_GENERAL_SOCKS_SERVER_FAILURE = 0x01;
		private const byte SOCKS5_CMD_REPLY_CONNECTION_NOT_ALLOWED_BY_RULESET = 0x02;
		private const byte SOCKS5_CMD_REPLY_NETWORK_UNREACHABLE = 0x03;
		private const byte SOCKS5_CMD_REPLY_HOST_UNREACHABLE = 0x04;
		private const byte SOCKS5_CMD_REPLY_CONNECTION_REFUSED = 0x05;
		private const byte SOCKS5_CMD_REPLY_TTL_EXPIRED = 0x06;
		private const byte SOCKS5_CMD_REPLY_COMMAND_NOT_SUPPORTED = 0x07;
		private const byte SOCKS5_CMD_REPLY_ADDRESS_TYPE_NOT_SUPPORTED = 0x08;
		private const byte SOCKS5_ADDRTYPE_IPV4 = 0x01;
		private const byte SOCKS5_ADDRTYPE_DOMAIN_NAME = 0x03;
		private const byte SOCKS5_ADDRTYPE_IPV6 = 0x04;
		// ReSharper restore InconsistentNaming, UnusedMember.Local
		
		/// <summary>Authentication itemType.</summary>
		private enum SocksAuthentication
		{
			/// <summary>No authentication used.</summary>
			None,
			
			/// <summary>Username and password authentication.</summary>
			UsernamePassword
		}
		
		/// <summary>Create a Socks5 proxy client object.</summary>
		public Socks5ProxyClient() {}
		
		/// <summary>Creates a Socks5 proxy client object using the supplied TcpClient object connection.</summary>
		/// <param name="tcp_client">A TcpClient connection object.</param>
		public Socks5ProxyClient(TcpClient tcp_client)
		{
			if (tcp_client == null) throw new ArgumentNullException("tcp_client");
			m_tcp_client = tcp_client;
		}
		
		/// <summary>
		/// Create a Socks5 proxy client object.  The default proxy port 1080 is used.
		/// </summary>
		/// <param name="proxy_host">Host name or IP address of the proxy server.</param>
		public Socks5ProxyClient(string proxy_host)
		{
			if (String.IsNullOrEmpty(proxy_host))
				throw new ArgumentNullException("proxy_host");
				
			m_proxy_host = proxy_host;
			m_proxy_port = SOCKS5_DEFAULT_PORT;
		}
		
		/// <summary>
		/// Create a Socks5 proxy client object.
		/// </summary>
		/// <param name="proxy_host">Host name or IP address of the proxy server.</param>
		/// <param name="proxy_port">Port used to connect to proxy server.</param>
		public Socks5ProxyClient(string proxy_host, int proxy_port)
		{
			if (String.IsNullOrEmpty(proxy_host))
				throw new ArgumentNullException("proxy_host");
				
			if (proxy_port <= 0 || proxy_port > 65535)
				throw new ArgumentOutOfRangeException("proxy_port", "port must be greater than zero and less than 65535");
				
			m_proxy_host = proxy_host;
			m_proxy_port = proxy_port;
		}
		
		/// <summary>
		/// Create a Socks5 proxy client object.  The default proxy port 1080 is used.
		/// </summary>
		/// <param name="proxy_host">Host name or IP address of the proxy server.</param>
		/// <param name="proxy_user_name">Proxy authentication user name.</param>
		/// <param name="proxy_password">Proxy authentication password.</param>
		public Socks5ProxyClient(string proxy_host, string proxy_user_name, string proxy_password)
		{
			if (String.IsNullOrEmpty(proxy_host))
				throw new ArgumentNullException("proxy_host");
				
			if (proxy_user_name == null)
				throw new ArgumentNullException("proxy_user_name");
				
			if (proxy_password == null)
				throw new ArgumentNullException("proxy_password");
				
			m_proxy_host = proxy_host;
			m_proxy_port = SOCKS5_DEFAULT_PORT;
			m_proxy_user_name = proxy_user_name;
			m_proxy_password = proxy_password;
		}
		
		/// <summary>
		/// Create a Socks5 proxy client object.
		/// </summary>
		/// <param name="proxy_host">Host name or IP address of the proxy server.</param>
		/// <param name="proxy_port">Port used to connect to proxy server.</param>
		/// <param name="proxy_user_name">Proxy authentication user name.</param>
		/// <param name="proxy_password">Proxy authentication password.</param>
		public Socks5ProxyClient(string proxy_host, int proxy_port, string proxy_user_name, string proxy_password)
		{
			if (String.IsNullOrEmpty(proxy_host))
				throw new ArgumentNullException("proxy_host");
				
			if (proxy_port <= 0 || proxy_port > 65535)
				throw new ArgumentOutOfRangeException("proxy_port", "port must be greater than zero and less than 65535");
				
			if (proxy_user_name == null)
				throw new ArgumentNullException("proxy_user_name");
				
			if (proxy_password == null)
				throw new ArgumentNullException("proxy_password");
				
			m_proxy_host = proxy_host;
			m_proxy_port = proxy_port;
			m_proxy_user_name = proxy_user_name;
			m_proxy_password = proxy_password;
		}
		
		/// <summary>
		/// Gets or sets host name or IP address of the proxy server.
		/// </summary>
		public string ProxyHost
		{
			get { return m_proxy_host; }
			set { m_proxy_host = value; }
		}
		
		/// <summary>
		/// Gets or sets port used to connect to proxy server.
		/// </summary>
		public int ProxyPort
		{
			get { return m_proxy_port; }
			set { m_proxy_port = value; }
		}
		
		/// <summary>
		/// Gets String representing the name of the proxy.
		/// </summary>
		/// <remarks>This property will always return the value 'SOCKS5'</remarks>
		public string ProxyName
		{
			get { return "SOCKS5"; }
		}
		
		/// <summary>
		/// Gets or sets proxy authentication user name.
		/// </summary>
		public string ProxyUserName
		{
			get { return m_proxy_user_name; }
			set { m_proxy_user_name = value; }
		}
		
		/// <summary>
		/// Gets or sets proxy authentication password.
		/// </summary>
		public string ProxyPassword
		{
			get { return m_proxy_password; }
			set { m_proxy_password = value; }
		}
		
		/// <summary>
		/// Gets or sets the TcpClient object.
		/// This property can be set prior to executing CreateConnection to use an existing TcpClient connection.
		/// </summary>
		public TcpClient TcpClient
		{
			get { return m_tcp_client; }
			set { m_tcp_client = value; }
		}
		
		/// <summary>
		/// Creates a remote TCP connection through a proxy server to the destination host on the destination port.
		/// </summary>
		/// <param name="destination_host">Destination host name or IP address of the destination server.</param>
		/// <param name="destination_port">Port number to connect to on the destination host.</param>
		/// <returns>
		/// Returns an open TcpClient object that can be used normally to communicate
		/// with the destination server
		/// </returns>
		/// <remarks>
		/// This method creates a connection to the proxy server and instructs the proxy server
		/// to make a pass through connection to the specified destination host on the specified
		/// port.
		/// </remarks>
		public TcpClient CreateConnection(string destination_host, int destination_port)
		{
			if (String.IsNullOrEmpty(destination_host))
				throw new ArgumentNullException("destination_host");
				
			if (destination_port <= 0 || destination_port > 65535)
				throw new ArgumentOutOfRangeException("destination_port", "port must be greater than zero and less than 65535");
				
			try
			{
				// if we have no connection, create one
				if (m_tcp_client == null)
				{
					if (String.IsNullOrEmpty(m_proxy_host))
						throw new ProxyException("ProxyHost property must contain a value.");
						
					if (m_proxy_port <= 0 || m_proxy_port > 65535)
						throw new ProxyException("ProxyPort value must be greater than zero and less than 65535");
						
					//  create new tcp client object to the proxy server
					m_tcp_client = new TcpClient();
					
					// attempt to open the connection
					m_tcp_client.Connect(m_proxy_host, m_proxy_port);
				}
				
				//  determine which authentication method the client would like to use
				DetermineClientAuthMethod();
				
				// negotiate which authentication methods are supported / accepted by the server
				NegotiateServerAuthMethod();
				
				// send a connect command to the proxy server for destination host and port
				SendCommand(SOCKS5_CMD_CONNECT, destination_host, destination_port);
				
				// return the open proxied tcp client object to the caller for normal use
				return m_tcp_client;
			}
			catch (Exception ex)
			{
				throw new ProxyException(String.Format(CultureInfo.InvariantCulture, "Connection to proxy host {0} on port {1} failed.", Utils.GetHost(m_tcp_client), Utils.GetPort(m_tcp_client)), ex);
			}
		}
		
		
		private void DetermineClientAuthMethod()
		{
			//  set the authentication itemType used based on values inputed by the user
			if (m_proxy_user_name != null && m_proxy_password != null)
				m_proxy_auth_method = SocksAuthentication.UsernamePassword;
			else
				m_proxy_auth_method = SocksAuthentication.None;
		}
		
		private void NegotiateServerAuthMethod()
		{
			//  get a reference to the network stream
			NetworkStream stream = m_tcp_client.GetStream();
			
			// SERVER AUTHENTICATION REQUEST
			// The client connects to the server, and sends a version
			// identifier/method selection message:
			//
			//      +----+----------+----------+
			//      |VER | NMETHODS | METHODS  |
			//      +----+----------+----------+
			//      | 1  |    1     | 1 to 255 |
			//      +----+----------+----------+
			
			byte[] auth_request = new byte[4];
			auth_request[0] = SOCKS5_VERSION_NUMBER;
			auth_request[1] = SOCKS5_AUTH_NUMBER_OF_AUTH_METHODS_SUPPORTED;
			auth_request[2] = SOCKS5_AUTH_METHOD_NO_AUTHENTICATION_REQUIRED;
			auth_request[3] = SOCKS5_AUTH_METHOD_USERNAME_PASSWORD;
			
			//  send the request to the server specifying authentication types supported by the client.
			stream.Write(auth_request, 0, auth_request.Length);
			
			//  SERVER AUTHENTICATION RESPONSE
			//  The server selects from one of the methods given in METHODS, and
			//  sends a METHOD selection message:
			//
			//     +----+--------+
			//     |VER | METHOD |
			//     +----+--------+
			//     | 1  |   1    |
			//     +----+--------+
			//
			//  If the selected METHOD is X'FF', none of the methods listed by the
			//  client are acceptable, and the client MUST close the connection.
			//
			//  The values currently defined for METHOD are:
			//   * X'00' NO AUTHENTICATION REQUIRED
			//   * X'01' GSSAPI
			//   * X'02' USERNAME/PASSWORD
			//   * X'03' to X'7F' IANA ASSIGNED
			//   * X'80' to X'FE' RESERVED FOR PRIVATE METHODS
			//   * X'FF' NO ACCEPTABLE METHODS
			
			//  receive the server response
			byte[] response = new byte[2];
			stream.Read(response, 0, response.Length);
			
			//  the first byte contains the socks version number (e.g. 5)
			//  the second byte contains the auth method acceptable to the proxy server
			byte accepted_auth_method = response[1];
			
			// if the server does not accept any of our supported authenication methods then throw an error
			if (accepted_auth_method == SOCKS5_AUTH_METHOD_REPLY_NO_ACCEPTABLE_METHODS)
			{
				m_tcp_client.Close();
				throw new ProxyException("The proxy destination does not accept the supported proxy client authentication methods.");
			}
			
			// if the server accepts a username and password authentication and none is provided by the user then throw an error
			if (accepted_auth_method == SOCKS5_AUTH_METHOD_USERNAME_PASSWORD && m_proxy_auth_method == SocksAuthentication.None)
			{
				m_tcp_client.Close();
				throw new ProxyException("The proxy destination requires a username and password for authentication.");
			}
			
			if (accepted_auth_method == SOCKS5_AUTH_METHOD_USERNAME_PASSWORD)
			{
			
				// USERNAME / PASSWORD SERVER REQUEST
				// Once the SOCKS V5 server has started, and the client has selected the
				// Username/Password Authentication protocol, the Username/Password
				// subnegotiation begins.  This begins with the client producing a
				// Username/Password request:
				//
				//       +----+------+----------+------+----------+
				//       |VER | ULEN |  UNAME   | PLEN |  PASSWD  |
				//       +----+------+----------+------+----------+
				//       | 1  |  1   | 1 to 255 |  1   | 1 to 255 |
				//       +----+------+----------+------+----------+
				
				byte[] credentials = new byte[m_proxy_user_name.Length + m_proxy_password.Length + 3];
				credentials[0] = SOCKS5_VERSION_NUMBER;
				credentials[1] = (byte)m_proxy_user_name.Length;
				Array.Copy(Encoding.ASCII.GetBytes(m_proxy_user_name), 0, credentials, 2, m_proxy_user_name.Length);
				credentials[m_proxy_user_name.Length + 2] = (byte)m_proxy_password.Length;
				Array.Copy(Encoding.ASCII.GetBytes(m_proxy_password), 0, credentials, m_proxy_user_name.Length + 3, m_proxy_password.Length);
				
				// USERNAME / PASSWORD SERVER RESPONSE
				// The server verifies the supplied UNAME and PASSWD, and sends the
				// following response:
				//
				//   +----+--------+
				//   |VER | STATUS |
				//   +----+--------+
				//   | 1  |   1    |
				//   +----+--------+
				//
				// A STATUS field of X'00' indicates success. If the server returns a
				// `failure' (STATUS value other than X'00') status, it MUST close the
				// connection.
			}
		}
		
		private byte GetDestAddressType(string host)
		{
			IPAddress ip_addr;
			
			bool result = IPAddress.TryParse(host, out ip_addr);
			
			if (!result)
				return SOCKS5_ADDRTYPE_DOMAIN_NAME;
				
			switch (ip_addr.AddressFamily)
			{
			case AddressFamily.InterNetwork:
				return SOCKS5_ADDRTYPE_IPV4;
			case AddressFamily.InterNetworkV6:
				return SOCKS5_ADDRTYPE_IPV6;
			default:
				throw new ProxyException(String.Format(CultureInfo.InvariantCulture, "The host addess {0} of type '{1}' is not a supported address type.  The supported types are InterNetwork and InterNetworkV6.", host, Enum.GetName(typeof(AddressFamily), ip_addr.AddressFamily)));
			}
			
		}
		
		private byte[] GetDestAddressBytes(byte address_type, string host)
		{
			switch (address_type)
			{
			case SOCKS5_ADDRTYPE_IPV4:
			case SOCKS5_ADDRTYPE_IPV6:
				return IPAddress.Parse(host).GetAddressBytes();
			case SOCKS5_ADDRTYPE_DOMAIN_NAME:
				//  create a byte array to hold the host name bytes plus one byte to store the length
				byte[] bytes = new byte[host.Length + 1];
				//  if the address field contains a fully-qualified domain name.  The first
				//  octet of the address field contains the number of octets of name that
				//  follow, there is no terminating NUL octet.
				bytes[0] = Convert.ToByte(host.Length);
				Encoding.ASCII.GetBytes(host).CopyTo(bytes, 1);
				return bytes;
			default:
				return null;
			}
		}
		
		private byte[] GetDestPortBytes(int value)
		{
			byte[] array = new byte[2];
			array[0] = Convert.ToByte(value / 256);
			array[1] = Convert.ToByte(value % 256);
			return array;
		}
		
		private void SendCommand(byte command, string destination_host, int destination_port)
		{
			NetworkStream stream = m_tcp_client.GetStream();
			
			byte address_type = GetDestAddressType(destination_host);
			byte[] dest_addr = GetDestAddressBytes(address_type, destination_host);
			byte[] dest_port = GetDestPortBytes(destination_port);
			
			//  The connection request is made up of 6 bytes plus the
			//  length of the variable address byte array
			//
			//  +----+-----+-------+------+----------+----------+
			//  |VER | CMD |  RSV  | ATYP | DST.ADDR | DST.PORT |
			//  +----+-----+-------+------+----------+----------+
			//  | 1  |  1  | X'00' |  1   | Variable |    2     |
			//  +----+-----+-------+------+----------+----------+
			//
			// * VER protocol version: X'05'
			// * CMD
			//   * CONNECT X'01'
			//   * BIND X'02'
			//   * UDP ASSOCIATE X'03'
			// * RSV RESERVED
			// * ATYP address itemType of following address
			//   * IP V4 address: X'01'
			//   * DOMAINNAME: X'03'
			//   * IP V6 address: X'04'
			// * DST.ADDR desired destination address
			// * DST.PORT desired destination port in network octet order
			
			byte[] request = new byte[4 + dest_addr.Length + 2];
			request[0] = SOCKS5_VERSION_NUMBER;
			request[1] = command;
			request[2] = SOCKS5_RESERVED;
			request[3] = address_type;
			dest_addr.CopyTo(request, 4);
			dest_port.CopyTo(request, 4 + dest_addr.Length);
			
			// send connect request.
			stream.Write(request, 0, request.Length);
			
			//  PROXY SERVER RESPONSE
			//  +----+-----+-------+------+----------+----------+
			//  |VER | REP |  RSV  | ATYP | BND.ADDR | BND.PORT |
			//  +----+-----+-------+------+----------+----------+
			//  | 1  |  1  | X'00' |  1   | Variable |    2     |
			//  +----+-----+-------+------+----------+----------+
			//
			// * VER protocol version: X'05'
			// * REP Reply field:
			//   * X'00' succeeded
			//   * X'01' general SOCKS server failure
			//   * X'02' connection not allowed by ruleset
			//   * X'03' Network unreachable
			//   * X'04' Host unreachable
			//   * X'05' Connection refused
			//   * X'06' TTL expired
			//   * X'07' Command not supported
			//   * X'08' Address itemType not supported
			//   * X'09' to X'FF' unassigned
			//* RSV RESERVED
			//* ATYP address itemType of following address
			
			byte[] response = new byte[255];
			
			// read proxy server response
			stream.Read(response, 0, response.Length);
			
			byte reply_code = response[1];
			
			//  evaluate the reply code for an error condition
			if (reply_code != SOCKS5_CMD_REPLY_SUCCEEDED)
				HandleProxyCommandError(response, destination_host, destination_port);
		}
		
		private void HandleProxyCommandError(byte[] response, string destination_host, int destination_port)
		{
			string proxy_error_text;
			byte reply_code = response[1];
			byte addr_type = response[3];
			string addr = "";
			Int16 port = 0;
			
			switch (addr_type)
			{
			case SOCKS5_ADDRTYPE_DOMAIN_NAME:
				int addr_len = Convert.ToInt32(response[4]);
				byte[] addr_bytes = new byte[addr_len];
				for (int i = 0; i < addr_len; i++)
					addr_bytes[i] = response[i + 5];
				addr = Encoding.ASCII.GetString(addr_bytes);
				byte[] port_bytes_domain = new byte[2];
				port_bytes_domain[0] = response[6 + addr_len];
				port_bytes_domain[1] = response[5 + addr_len];
				port = BitConverter.ToInt16(port_bytes_domain, 0);
				break;
				
			case SOCKS5_ADDRTYPE_IPV4:
				byte[] ipv4_bytes = new byte[4];
				for (int i = 0; i < 4; i++)
					ipv4_bytes[i] = response[i + 4];
				IPAddress ipv4 = new IPAddress(ipv4_bytes);
				addr = ipv4.ToString();
				byte[] port_bytes_ipv4 = new byte[2];
				port_bytes_ipv4[0] = response[9];
				port_bytes_ipv4[1] = response[8];
				port = BitConverter.ToInt16(port_bytes_ipv4, 0);
				break;
				
			case SOCKS5_ADDRTYPE_IPV6:
				byte[] ipv6_bytes = new byte[16];
				for (int i = 0; i < 16; i++)
					ipv6_bytes[i] = response[i + 4];
				IPAddress ipv6 = new IPAddress(ipv6_bytes);
				addr = ipv6.ToString();
				byte[] port_bytes_ipv6 = new byte[2];
				port_bytes_ipv6[0] = response[21];
				port_bytes_ipv6[1] = response[20];
				port = BitConverter.ToInt16(port_bytes_ipv6, 0);
				break;
			}
			
			
			switch (reply_code)
			{
			case SOCKS5_CMD_REPLY_GENERAL_SOCKS_SERVER_FAILURE:
				proxy_error_text = "a general socks destination failure occurred";
				break;
			case SOCKS5_CMD_REPLY_CONNECTION_NOT_ALLOWED_BY_RULESET:
				proxy_error_text = "the connection is not allowed by proxy destination rule set";
				break;
			case SOCKS5_CMD_REPLY_NETWORK_UNREACHABLE:
				proxy_error_text = "the network was unreachable";
				break;
			case SOCKS5_CMD_REPLY_HOST_UNREACHABLE:
				proxy_error_text = "the host was unreachable";
				break;
			case SOCKS5_CMD_REPLY_CONNECTION_REFUSED:
				proxy_error_text = "the connection was refused by the remote network";
				break;
			case SOCKS5_CMD_REPLY_TTL_EXPIRED:
				proxy_error_text = "the time to live (TTL) has expired";
				break;
			case SOCKS5_CMD_REPLY_COMMAND_NOT_SUPPORTED:
				proxy_error_text = "the command issued by the proxy client is not supported by the proxy destination";
				break;
			case SOCKS5_CMD_REPLY_ADDRESS_TYPE_NOT_SUPPORTED:
				proxy_error_text = "the address type specified is not supported";
				break;
			default:
				proxy_error_text = String.Format(CultureInfo.InvariantCulture, "that an unknown reply with the code value '{0}' was received by the destination", reply_code.ToString(CultureInfo.InvariantCulture));
				break;
			}
			string exception_msg = String.Format(CultureInfo.InvariantCulture, "The {0} concerning destination host {1} port number {2}.  The destination reported the host as {3} port {4}.", proxy_error_text, destination_host, destination_port, addr, port.ToString(CultureInfo.InvariantCulture));
			
			throw new ProxyException(exception_msg);
			
		}

		private BackgroundWorker m_async_worker;
		private Exception m_async_exception;
		bool m_async_cancelled;
		
		/// <summary>Gets a value indicating whether an asynchronous operation is running.</summary>
		/// <remarks>Returns true if an asynchronous operation is running; otherwise, false.</remarks>
		public bool IsBusy
		{
			get { return m_async_worker != null && m_async_worker.IsBusy; }
		}
		
		/// <summary>Gets a value indicating whether an asynchronous operation is cancelled.</summary>
		/// <remarks>Returns true if an asynchronous operation is cancelled; otherwise, false.</remarks>
		public bool IsAsyncCancelled
		{
			get { return m_async_cancelled; }
		}
		
		/// <summary>Cancels any asychronous operation that is currently active.</summary>
		public void CancelAsync()
		{
			if (m_async_worker != null && !m_async_worker.CancellationPending && m_async_worker.IsBusy)
			{
				m_async_cancelled = true;
				m_async_worker.CancelAsync();
			}
		}
		
		/// <summary>Event handler for CreateConnectionAsync method completed.</summary>
		public event EventHandler<CreateConnectionAsyncCompletedEventArgs> CreateConnectionAsyncCompleted;
		
		
		/// <summary>Asynchronously creates a remote TCP connection through a proxy server to the destination host on the destination port.</summary>
		/// <param name="destination_host">Destination host name or IP address.</param>
		/// <param name="destination_port">Port number to connect to on the destination host.</param>
		/// <returns>
		/// Returns TcpClient object that can be used normally to communicate
		/// with the destination server.
		/// </returns>
		/// <remarks>
		/// This method instructs the proxy server
		/// to make a pass through connection to the specified destination host on the specified
		/// port.
		/// </remarks>
		public void CreateConnectionAsync(string destination_host, int destination_port)
		{
			if (m_async_worker != null && m_async_worker.IsBusy)
				throw new InvalidOperationException("The Socks4 object is already busy executing another asynchronous operation.  You can only execute one asychronous method at a time.");
				
			if (m_async_worker != null) m_async_worker.Dispose();
			m_async_exception = null;
			m_async_worker = null;
			m_async_cancelled = false;
			m_async_worker = new BackgroundWorker();
			m_async_worker.WorkerSupportsCancellation = true;
			m_async_worker.DoWork += CreateConnectionAsync_DoWork;
			m_async_worker.RunWorkerCompleted += CreateConnectionAsync_RunWorkerCompleted;
			Object[] args = new Object[2];
			args[0] = destination_host;
			args[1] = destination_port;
			m_async_worker.RunWorkerAsync(args);
		}
		
		private void CreateConnectionAsync_DoWork(object sender, DoWorkEventArgs e)
		{
			try
			{
				Object[] args = (Object[])e.Argument;
				e.Result = CreateConnection((string)args[0], (int)args[1]);
			}
			catch (Exception ex)
			{
				m_async_exception = ex;
			}
		}
		
		private void CreateConnectionAsync_RunWorkerCompleted(object sender, RunWorkerCompletedEventArgs e)
		{
			if (CreateConnectionAsyncCompleted != null)
				CreateConnectionAsyncCompleted(this, new CreateConnectionAsyncCompletedEventArgs(m_async_exception, m_async_cancelled, (TcpClient)e.Result));
		}
	}
	
	internal static class Utils
	{
		internal static string GetHost(TcpClient client)
		{
			if (client == null) throw new ArgumentNullException("client");
			try { return ((IPEndPoint)client.Client.RemoteEndPoint).Address.ToString(); }
			catch { return ""; }
		}
		
		internal static string GetPort(TcpClient client)
		{
			if (client == null) throw new ArgumentNullException("client");
			try { return ((IPEndPoint)client.Client.RemoteEndPoint).Port.ToString(CultureInfo.InvariantCulture); }
			catch { return ""; }
		}
	}
	
	/// <summary>This exception is thrown when a general, unexpected proxy error.</summary>
	[Serializable]
	public class ProxyException : Exception
	{
		/// <summary>Constructor.</summary>
		public ProxyException() {}
		
		/// <summary>Constructor.</summary>
		/// <param name="message">Exception message text.</param>
		public ProxyException(string message) :base(message) {}
		
		/// <summary>Constructor.</summary>
		/// <param name="message">Exception message text.</param>
		/// <param name="inner_exception">The inner exception object.</param>
		public ProxyException(string message, Exception inner_exception) :base(message, inner_exception) {}
		
		/// <summary>Constructor.</summary>
		/// <param name="info">Serialization information.</param>
		/// <param name="context">Stream context information.</param>
		protected ProxyException(SerializationInfo info, StreamingContext context) :base(info, context) {}
	}
}
