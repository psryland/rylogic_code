//*********************************************
// Renderer
//  Copyright © Rylogic Ltd 2012
//*********************************************
#pragma once
#ifndef PR_RDR_UTIL_LOCK_H
#define PR_RDR_UTIL_LOCK_H

#include "pr/renderer11/forward.h"

namespace pr
{
	namespace rdr
	{
		// Notes about Map()/Unmap and resource usage flags:
		//  There are two main kinds of resources: mappable and non-mappable. Resources created with dynamic or staging
		//  usages are mappable, while resources created with default or immutable usages are non-mappable.
		// I think this means you have to initialise models that use 'D3D11_USAGE_DEFAULT' buffers at creation time
		// and you can't 'Map' them later.
		// Further:
		//  Copying data among non-mappable resources is very fast because this is the most common case and has been optimized
		//  to perform well. Since these resources are not directly accessible by the CPU, they are optimized so that the GPU
		//  can manipulate them quickly. Copying data among mappable resources is more problematic because the performance will
		//  depend on the usage the resource was created with. For example, the GPU can read a dynamic resource fairly quickly
		//  but cannot write to them, and the GPU cannot read or write to staging resources directly. Applications that wish to
		//  copy data from a resource with default usage to a resource with staging usage (to allow the CPU to read the data --
		//  i.e. the GPU readback problem) must do so with care. See Accessing Resource Data for more details on this last case.
		//
		//  The CPU can only read from resources created with the D3D10_USAGE_STAGING flag. Since resources created with this
		//  flag cannot be set as outputs of the pipeline, if the CPU wants to read the data in a resource generated by the GPU,
		//  the data must be copied to a resource created with the staging flag. The application may do this by using the
		//  ID3D10Device::CopyResource or ID3D10Device::CopySubresourceRegion methods to copy the contents of one resource to
		//  another. The application can then gain access to this resource by calling the appropriate Map method. When access
		//  to the resource is no longer needed, the application should then call the corresponding Unmap method. For example,
		//  ID3D10Texture2D::Map and ID3D10Texture2D::Unmap. The different Map methods return some specific values depending on
		//  the input flags. See Map Remarks section for details.
		//
		//  Read this: http://msdn.microsoft.com/en-us/library/windows/desktop/bb205132(v=vs.85).aspx
		//
		// If the app needs to use ID3D10Device::CopyResource or ID3D10Device::CopySubresourceRegion to copy GPU output back to 
		// CPU accessible memory, it needs 2 be done frames before calling Map on the result of the copy to prevent any performance
		// loss (i.e. CPU waits for GPU to do the copy, then GPU waits for CPU to finish the Map()/Unmap())
		//  

		// A scope object for locking (or "mapping") a resource so that the CPU can access it
		// Mapping:   Gets a pointer to the data contained in a subresource, and denies the GPU access to that subresource.
		// Unmapping: Invalidate the pointer to a resource and re-enable the GPU's access to that resource.
		struct Lock :private D3D11_MAPPED_SUBRESOURCE
		{
			D3DPtr<ID3D11DeviceContext> m_dc;    // Locking is done by the DC.
			D3DPtr<ID3D11Resource>      m_res;   // The resource to be locked
			UINT                        m_sub;   // e.g. mip level (use 0 for V/I buffers)
			Range                       m_range; // The range of elements locked.
			
			// Provide a 'dc' if you want to use a deferred context to lock the resource.
			// This will override the 'dc' passed to Map by the renderer manager classes (which will pass in the immediate dc)
			// Note: that to map a deferred context, you can only use write discard or write no overwrite.
			Lock()
			:D3D11_MAPPED_SUBRESOURCE()
			,m_dc()
			,m_res(0)
			,m_sub(0)
			,m_range()
			{}
			Lock(D3DPtr<ID3D11DeviceContext>& dc, D3DPtr<ID3D11Resource> const& res, UINT sub, D3D11_MAP map_type, UINT flags)
			{
				PR_ASSERT(PR_DBG_RDR, (flags & D3D11_MAP_FLAG_DO_NOT_WAIT) == 0, "Don't use this constructor with this flag");
				Map(dc, res, sub, map_type, flags);
			}
			~Lock()
			{
				Unmap();
			}
			
			// Returns a pointer to the mapped memory
			// SDK Notes: *Don't read from a subresource mapped for writing*
			//  When you pass D3D11_MAP_WRITE, D3D11_MAP_WRITE_DISCARD, or D3D11_MAP_WRITE_NO_OVERWRITE to the MapType parameter,
			//  you must ensure that your app does not read the subresource data to which the pData member of D3D11_MAPPED_SUBRESOURCE
			//  points because doing so can cause a significant performance penalty. The memory region to which pData points can be
			//  allocated with PAGE_WRITECOMBINE, and your app must honor all restrictions that are associated with such memory.
			// The SDK recommends using volatile pointers (but struct assignment for volatiles requires cv-qualified assignment operators)
			// Just don't read from ptr()...
			template <typename Type> Type* ptr()
			{
				return static_cast<Type*>(pData);
			}
			
			// For mapped textures
			UINT RowPitch() const   { return pr::type_ptr<D3D11_MAPPED_SUBRESOURCE>(this)->RowPitch; }
			UINT DepthPitch() const { return pr::type_ptr<D3D11_MAPPED_SUBRESOURCE>(this)->DepthPitch; }
			
			// Maps a resource to CPU accessable memory
			// Only returns false if 'D3D11_MAP_FLAG_DO_NOT_WAIT' is used in 'flags'
			bool Map(D3DPtr<ID3D11DeviceContext>& dc, D3DPtr<ID3D11Resource> const& res, UINT sub, D3D11_MAP map_type, UINT flags)
			{
				PR_ASSERT(PR_DBG_RDR, m_dc == 0, "Already mapped");
				m_dc = dc;
				
				// Do not wait means the caller expects the map to potentially not to work
				HRESULT hr = m_dc->Map(res.m_ptr, sub, map_type, flags, this);
				if ((flags&D3D11_MAP_FLAG_DO_NOT_WAIT) == 0) pr::Throw(hr);
				m_res = res;
				m_sub = sub;
				return pr::Succeeded(hr);
			}
			
			void Unmap()
			{
				if (!m_res) return;
				m_dc->Unmap(m_res.m_ptr, m_sub);
				static_cast<D3D11_MAPPED_SUBRESOURCE&>(*this) = D3D11_MAPPED_SUBRESOURCE();
				m_res = 0;
				m_dc = 0;
			}
		};

		// Model Lock - an object for scoped locking of a model vertex and
		// index buffer and for keeping track of ranges as it you fill it with stuff
		struct MLock
		{
			Lock     m_local_vlock;  // A local vertex lock to allow the caller to not provide one
			Lock     m_local_ilock;  // A local index lock to allow the caller to not provide one
			ModelPtr m_model;        // Pointer to the model whose buffers we're locking
			Lock&    m_vlock;        // The vertex buffer lock for the model
			Lock&    m_ilock;        // The index buffer lock for the model
			Range    m_vrange;       // The editable range of the model vertices
			Range    m_irange;       // The editable range of the model indices

			MLock(ModelPtr& model, D3D11_MAP map_type = D3D11_MAP_WRITE, UINT flags = 0);
			MLock(ModelPtr& model, Lock& vlock, Lock& ilock, D3D11_MAP map_type = D3D11_MAP_WRITE, UINT flags = 0);
			MLock(ModelPtr& model, Range const& vrange, Range const& irange, D3D11_MAP map_type = D3D11_MAP_WRITE, UINT flags = 0);
			MLock(ModelPtr& model, Lock& vlock, Lock& ilock, Range const& vrange, Range const& irange, D3D11_MAP map_type = D3D11_MAP_WRITE, UINT flags = 0);
			
			MLock(MLock const&); // no copying
			MLock& operator=(MLock const&);

			// Pointers to the locked vert/index range
			template <typename VType> VType* vptr() { return pr::type_ptr<VType>(m_vlock.pData) + m_vrange.m_begin; }
			template <typename IType> IType* iptr() { return pr::type_ptr<IType>(m_ilock.pData) + m_irange.m_begin; }
		};
	}
}

#endif
