<?xml version="1.0"?>
<doc>
    <assembly>
        <name>nstl</name>
    </assembly>
    <members>
        <member name="T:NStl.NStlUtil">
            <summary>
            This class provides functionality, such as combining the NStl iterators
            with the .Net containers. It also contains STL functions that are
            not part of a special section of the C++ STL, e.g. advance.
            </summary>
        </member>
        <member name="M:NStl.NStlUtil.Iterator``1(``0[],System.Int32)">
            <summary>
            Get an iterator for an array at the specified index.
            </summary>
            <param name="l"></param>
            <param name="idx"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.NStlUtil.Iterator``1(System.Collections.Generic.IList{``0},System.Int32)">
            <summary>
            Get an iterator for an IList at the specified index.
            </summary>
            <param name="l"></param>
            <param name="idx"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.NStlUtil.Iterator``1(System.Collections.IList,System.Int32)">
            <summary>
            Get an iterator for an IList at the specified index.
            </summary>
            <param name="l"></param>
            <param name="idx"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.NStlUtil.Advance``2(``1,System.Int32)">
            <summary>
            returns tan iterator that is advanced by the given value. it might modify the
            passed in iterator.
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="It"></typeparam>
            <param name="where"></param>
            <param name="distance"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.NStlUtil.Collection``1(NStl.Iterators.IInputIterator{``0},NStl.Iterators.IInputIterator{``0})">
            <summary>
            Returns an adapter that implements <see cref="T:System.Collections.ICollection"/>.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="first">
            An iterator addressing the position of the first element.
            </param>
            <param name="last">
            An iterator addressing the position one past the last element.
            </param>
            <returns>An <see cref="T:System.Collections.ICollection"/> implemetation.</returns>
        </member>
        <member name="M:NStl.NStlUtil.Collection``1(NStl.IRange{``0})">
            <summary>
            Returns an adapter that implements <see cref="T:System.Collections.ICollection"/>.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="range">
            The range that needs an adapter for the <see cref="T:System.Collections.ICollection"/> interface.
            </param>
            <returns>An <see cref="T:System.Collections.ICollection"/> implemetation.</returns>
        </member>
        <member name="M:NStl.NStlUtil.Collection``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Returns an adapter that implements <see cref="T:System.Collections.ICollection"/>.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="range">
            The range that needs an adapter for the <see cref="T:System.Collections.ICollection"/> interface.
            </param>
            <returns>An <see cref="T:System.Collections.ICollection"/> implemetation.</returns>
        </member>
        <member name="M:NStl.NStlUtil.Collection``1(System.Collections.IEnumerable)">
            <summary>
            Returns an adapter that implements <see cref="T:System.Collections.ICollection"/>.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="range">
            The range that needs an adapter for the <see cref="T:System.Collections.ICollection"/> interface.
            </param>
            <returns>An <see cref="T:System.Collections.ICollection"/> implemetation.</returns>
        </member>
        <member name="M:NStl.NStlUtil.Begin``1(System.Collections.IEnumerable)">
            <summary>
            Get a Start Iterator for a IEnumerable collection.
            </summary>
            <param name="l"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.NStlUtil.End``1(System.Collections.IEnumerable)">
            <summary>
            Get a Start Iterator for a IEnumerable collection.
            </summary>
            <param name="l"></param>
            <returns></returns>
            <remarks>
            The returned iterator is a weak input iterator. This means that it can only be applied to
            non-mutative algorithms.
            </remarks>
        </member>
        <member name="M:NStl.NStlUtil.Inserter(System.Collections.IDictionary)">
            <summary>
            Creates an <see cref="T:NStl.Iterators.IOutputIterator`1"/> implementation
            that can be use as an output for <see cref="T:System.Collections.DictionaryEntry"/>s to an 
            <see cref="T:System.Collections.IDictionary"/> implementation, e.g a <see cref="T:System.Collections.Hashtable"/>.
            </summary>
            <param name="dict"></param>
            <returns></returns>
            <remarks>
            As <see cref="T:System.Collections.Generic.IDictionary`2"/> extends <see cref="T:System.Collections.Generic.ICollection`1"/>,
            <see cref="M:NStl.NStlUtil.Inserter``1(System.Collections.Generic.ICollection{``0})"/> can be used to obtain
            an <see cref="T:NStl.Iterators.IOutputIterator`1"/>.
            </remarks>
        </member>
        <member name="M:NStl.NStlUtil.Begin``1(``0[])">
            <summary>
            Get a Start Iterator for an array.
            </summary>
            <param name="l"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.NStlUtil.End``1(``0[])">
            <summary>
            Get an End Iterator for an array.
            </summary>
            <param name="l"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.NStlUtil.Distance``1(NStl.Iterators.IInputIterator{``0},NStl.Iterators.IInputIterator{``0})">
            <summary>
            Determines the number of increments between the positions by two iterators.
            </summary>
            <param name="first">The first iterator whose distance from the second is to be determined.</param>
            <param name="last">The second iterator whose distance from the first is to be determined.</param>
            <returns></returns>
        </member>
        <member name="M:NStl.NStlUtil.Distance``1(NStl.Iterators.IRandomAccessIterator{``0},NStl.Iterators.IRandomAccessIterator{``0})">
            <summary>
            Determines the number of increments between the positions by two iterators.
            </summary>
            <param name="first">The first iterator whose distance from the second is to be determined.</param>
            <param name="last">The second iterator whose distance from the first is to be determined.</param>
            <returns></returns>
        </member>
        <member name="M:NStl.NStlUtil.FrontInserter``1(NStl.IFrontInsertable{``0})">
            <summary>
            Returns an <see cref="T:NStl.Iterators.IOutputIterator`1"/> implementation
            that does front insertions on an <see cref="T:NStl.IFrontInsertable`1"/>.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="frontInsertable"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.NStlUtil.FrontInserter``1(System.Collections.Generic.LinkedList{``0})">
            <summary>
            Returns an <see cref="T:NStl.Iterators.IOutputIterator`1"/> implementation
            that does front insertions on a <see cref="T:System.Collections.Generic.LinkedList`1"/>.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="frontInsertable"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.NStlUtil.StringOutput``1(System.String)">
            <summary>
            Creates an output iterator that will print all values into an internal <see cref="T:System.Text.StringBuilder"/>. 
            Use the <see cref="M:System.Object.ToString"/> method of the iterator to get the complete string.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="seperator">The seperator string that is inserted between the values.</param>
            <returns></returns>
        </member>
        <member name="M:NStl.NStlUtil.StringOutput``1(System.Text.StringBuilder,System.String)">
            <summary>
            Creates an output iterator that will print all values into an internal <see cref="T:System.Text.StringBuilder"/>. 
            Use the <see cref="M:System.Object.ToString"/> method of the iterator to get the complete string.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="builder">The StringBuilder to be used for the string concat.</param>
            <param name="seperator">The seperator string that is inserted between the values.</param>
            <returns></returns>
        </member>
        <member name="M:NStl.NStlUtil.Begin``1(System.Collections.Generic.LinkedList{``0})">
            <summary>
            Creates a <see cref="T:NStl.Iterators.Support.LinkedListIterator`1"/> pointing to the first element of the <see cref="T:System.Collections.Generic.LinkedList`1"/>.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.NStlUtil.End``1(System.Collections.Generic.LinkedList{``0})">
            <summary>
            Creates a <see cref="T:NStl.Iterators.Support.LinkedListIterator`1"/> pointing one past the last element of passed in <see cref="T:System.Collections.Generic.LinkedList`1"/>.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.NStlUtil.Inserter``2(NStl.IInsertable{``0,``1},``1)">
            <summary>
            Returns an Iterator adaptor that can be used as a output
            iterator. It will insert values at the location that the 
            passed in iterator points to
            </summary>
            <param name="insertable"></param>
            <param name="where"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.NStlUtil.Inserter``1(System.Collections.Generic.ICollection{``0})">
            <summary>
            Returns an iterator adapter that can be used as an output
            iterator. It simply adds items to the end of a sequence.
            </summary>
            <param name="l"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.NStlUtil.Begin``1(System.Collections.IList)">
            <summary>
            Get a start iterator for an IList collection.
            </summary>
            <param name="l"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.NStlUtil.End``1(System.Collections.IList)">
            <summary>
            Get an end iterator for an IList collection.
            </summary>
            <param name="l"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.NStlUtil.Begin``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Get a Start Iterator for a IEnumerable collection.
            </summary>
            <param name="l"></param>
            <returns></returns>
            <remarks>
            The returned iterator is a weak input iterator. This means that it can only be applied to
            non-mutative algorithms.
            </remarks>
        </member>
        <member name="M:NStl.NStlUtil.End``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Get a Start Iterator for a IEnumerable collection.
            </summary>
            <param name="l"></param>
            <returns></returns>
            <remarks>
            The returned iterator is a weak input iterator. This means that it can only be applied to
            non-mutative algorithms.
            </remarks>
        </member>
        <member name="M:NStl.NStlUtil.Enumerable``1(NStl.Iterators.IInputIterator{``0},NStl.Iterators.IInputIterator{``0})">
            <summary>
            Returns an adapter that implements <see cref="T:System.Collections.Generic.IEnumerable`1"/>, 
            so that any range bound by two iterators can be traversed the .NET way 
            using the foreach statement.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="first">
            An iterator addressing the position of the first element.
            </param>
            <param name="last">
            An iterator addressing the position one past the last element.
            </param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/> implemetation.</returns>
        </member>
        <member name="M:NStl.NStlUtil.Enumerable``1(NStl.IRange{``0})">
            <summary>
            Returns an adapter that implements <see cref="T:System.Collections.Generic.IEnumerable`1"/>, 
            so that any range bound by two iterators can be traversed the .NET way 
            using the foreach statement.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="range">
            The range that needs an adapter for the IEnumerator interface.
            </param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/> implemetation.</returns>
        </member>
        <member name="M:NStl.NStlUtil.Enumerable``1(System.Collections.IEnumerable)">
            <summary>
            Returns an adapter that implements <see cref="T:System.Collections.Generic.IEnumerable`1"/>,
            adapting an untyped IEnumerator
            </summary>
            <typeparam name="T"></typeparam>
            <param name="range"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.NStlUtil.Enumerator``1(NStl.Iterators.IInputIterator{``0},NStl.Iterators.IInputIterator{``0})">
            <summary>
            Returns an adapter that implements <see cref="T:System.Collections.Generic.IEnumerator`1"/>.
            </summary>
            <param name="first">
            An iterator addressing the position of the first element.
            </param>
            <param name="last">
            An iterator addressing the position one past the last element.
            </param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerator`1"/> implementation.</returns>
        </member>
        <member name="M:NStl.NStlUtil.Enumerator``1(NStl.IRange{``0})">
            <summary>
            Returns an adapter that implements <see cref="T:System.Collections.Generic.IEnumerator`1"/>.
            </summary>
            <param name="range">
            The range that needs an adapter for the IEnumerator interface.
            </param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerator`1"/> implementation.</returns>
        </member>
        <member name="M:NStl.NStlUtil.Reverse``1(NStl.Iterators.IBidirectionalIterator{``0})">
            <summary>
            Creates an iterator adaptor that will run in the opposite direction of the passed in iterator.
            </summary>
            <param name="it">The iterator to be reversed.</param>
            <returns></returns>
        </member>
        <member name="M:NStl.NStlUtil.Reverse``1(NStl.Iterators.IBidirectionalInputIterator{``0})">
            <summary>
            Creates an iterator adaptor that will run in the opposite direction of the passed in iterator.
            </summary>
            <param name="it">The iterator to be reversed.</param>
            <returns></returns>
        </member>
        <member name="M:NStl.NStlUtil.Reverse``1(NStl.Iterators.IRandomAccessIterator{``0})">
            <summary>
            Creates an iterator adaptor that will run in the opposite direction of the passed in iterator.
            </summary>
            <param name="it">The iterator to be reversed.</param>
            <returns></returns>
        </member>
        <member name="M:NStl.NStlUtil.Begin``1(System.Collections.Generic.IList{``0})">
            <summary>
            Get a Start Iterator for a IList collection.
            </summary>
            <param name="l"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.NStlUtil.End``1(System.Collections.Generic.IList{``0})">
            <summary>
            Get an End Iterator for a IList collection.
            </summary>
            <param name="l"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.NStlUtil.ConsoleOutput``1(System.String)">
            <summary>
            Creates an output iterator that will print all values to the <see cref="T:System.Console"/>.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="seperator">The seperator string that is inserted between the values.</param>
            <returns></returns>
        </member>
        <member name="M:NStl.NStlUtil.StreamOutput``1(System.IO.Stream,System.String)">
            <summary>
            Creates an output iterator that will print all values to the stream.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="stream"></param>
            <param name="seperator">The seperator string that is inserted between the values.</param>
            <returns></returns>
        </member>
        <member name="M:NStl.NStlUtil.TextWriterOutput``1(System.IO.TextWriter,System.String)">
            <summary>
            Creates an output iterator that will print all values to the stream.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="writer"></param>
            <param name="seperator">The seperator string that is inserted between the values.</param>
            <returns></returns>
        </member>
        <member name="M:NStl.NStlUtil.BlackHoleOutput``1">
            <summary>
            Creates an output iterator that eats the assigned values.
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:NStl.NStlUtil.BackInserter``1(System.Collections.Generic.ICollection{``0})">
            <summary>
            Returns an iterator adapter that can be used as an output
            iterator. It simply adds items to the end of a sequence.
            </summary>
            <param name="l"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.NStlUtil.BackInserter``1(NStl.IBackInsertableCollection{``0})">
            <summary>
            Returns an iterator adapter that can be used as an output
            iterator. It simply adds items to the end of a sequence.
            </summary>
            <param name="l"></param>
            <returns></returns>
            <remarks>This oveload exists to enable the compiler to choose an
            implementation for a DList</remarks>
        </member>
        <member name="M:NStl.NStlUtil.BackInserter``1(NStl.Collections.Vector{``0})">
            <summary>
            Returns an iterator adapter that can be used as an output
            iterator. It simply adds items to the end of a sequence.
            </summary>
            <param name="vector"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.NStlUtil.BackInserter``1(NStl.IBackInsertable{``0})">
            <summary>
            Returns an iterator adapter that can be used as an output
            iterator. It simply adds items to the end of a sequence.
            </summary>
            <param name="l"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.NStlUtil.BackInserter``1(System.Collections.IList)">
            <summary>
            Returns an iterator adapter that can be used as an output
            iterator. It simply adds items to the end of a sequence.
            </summary>
            <param name="l"></param>
            <returns></returns>
        </member>
        <member name="T:NStl.Iterators.Support.InputIterator`1">
            <summary>
            Base class that can be used to implement an <see cref="T:NStl.Iterators.IInputIterator`1"/>
            interface.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:NStl.Iterators.Support.EquatableIterator`1">
            <summary>
            Base class for all iterator implementation.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:NStl.Iterators.IIterator`1">
            <summary>
            A iterator is an adapter that lets you iterate over a range without
            knowing about the undelying implematation of the range.
            </summary>
        </member>
        <member name="M:NStl.Iterators.IIterator`1.Clone">
            <summary>
            When implemented, it returns an exact copy of this iterator.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Iterators.IIterator`1.Equals(System.Object)">
            <summary>
            Base class override. Returns TRUE, if the two iterator point
            to the same value in the same range.
            </summary>
            <param name="value"></param>
            <returns>TRUE, if the other object is an iterator and points
            to the same value in the same range.</returns>
        </member>
        <member name="M:NStl.Iterators.IIterator`1.GetHashCode">
            <summary>
            See <see cref="M:System.Object.GetHashCode"/> for details.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Iterators.Support.EquatableIterator`1.Clone">
            <summary>
            Returns an exact copy of this object.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Iterators.Support.EquatableIterator`1.op_Equality(NStl.Iterators.Support.EquatableIterator{`0},NStl.Iterators.Support.EquatableIterator{`0})">
            <summary>
            
            </summary>
            <param name="lhs"></param>
            <param name="rhs"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.Iterators.Support.EquatableIterator`1.op_Inequality(NStl.Iterators.Support.EquatableIterator{`0},NStl.Iterators.Support.EquatableIterator{`0})">
            <summary>
            
            </summary>
            <param name="lhs"></param>
            <param name="rhs"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.Iterators.Support.EquatableIterator`1.Equals(System.Object)">
            <summary>
            See <see cref="M:System.Object.Equals(System.Object)"/> for details.
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.Iterators.Support.EquatableIterator`1.Equals(NStl.Iterators.Support.EquatableIterator{`0})">
            <summary>
            
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.Iterators.Support.EquatableIterator`1.GetHashCode">
            <summary>
            See <see cref="M:System.Object.GetHashCode"/> for details.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Iterators.Support.EquatableIterator`1.HashCode">
            <summary>
            When implemented, it returns the hash code for this object.
            </summary>
            <returns></returns>
        </member>
        <member name="T:NStl.Iterators.IInputIterator`1">
            <summary>
            When implemented, it represents an iterator that can be used as an
            input to singlepass algorithms.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:NStl.Iterators.IInputIterator`1.PreIncrement">
            <summary>
            When implemented, it will move the iterator
            one step ahead. It will return this iterator afterwards.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Iterators.IInputIterator`1.PostIncrement">
            <summary>
            When implemented, it will move the iterator
            one step ahead. It will return a copy of this
            iterator at the old position.
            </summary>
            <returns></returns>
        </member>
        <member name="P:NStl.Iterators.IInputIterator`1.Value">
            <summary>
            When implemented, it gives a direct access to the value
            that the iterator points to. 
            </summary>
        </member>
        <member name="M:NStl.Iterators.Support.InputIterator`1.PreIncrement">
            <summary>
            See <see cref="M:NStl.Iterators.IInputIterator`1.PreIncrement"/> for details.
            </summary>
        </member>
        <member name="M:NStl.Iterators.Support.InputIterator`1.PostIncrement">
            <summary>
            See <see cref="M:NStl.Iterators.IInputIterator`1.PostIncrement"/> for details.
            </summary>
            <returns></returns>
        </member>
        <member name="P:NStl.Iterators.Support.InputIterator`1.Value">
            <summary>
            See <see cref="P:NStl.Iterators.IInputIterator`1.Value"/> for details.
            </summary>
        </member>
        <member name="T:NStl.Iterators.Support.BidirectionalInputIterator`1">
            <summary>
            Base class for a readonly <see cref="T:NStl.Iterators.IBidirectionalInputIterator`1"/> implementation.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:NStl.Iterators.IBidirectionalInputIterator`1">
            <summary>
            When implemented, it extends the <see cref="T:NStl.Iterators.IInputIterator`1"/> with
            the possibility to iterate backwards over the range.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:NStl.Iterators.IBidirectionalInputIterator`1.PreDecrement">
             <summary>
            Moves this iterator one step back.
             </summary>
             <returns>Returns this iterator.</returns>
        </member>
        <member name="M:NStl.Iterators.IBidirectionalInputIterator`1.PostDecrement">
            <summary>
            oves this iterator one step back.
            </summary>
            <returns>returns a copy of this iterator poining to the previous position.</returns>
        </member>
        <member name="M:NStl.Iterators.Support.BidirectionalInputIterator`1.PreDecrement">
            <summary>
            See <see cref="M:NStl.Iterators.IBidirectionalInputIterator`1.PreDecrement"/> for details.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Iterators.Support.BidirectionalInputIterator`1.PostDecrement">
            <summary>
            See <see cref="M:NStl.Iterators.IBidirectionalInputIterator`1.PostDecrement"/> for details.
            </summary>
            <returns></returns>
        </member>
        <member name="T:NStl.SyntaxHelper.Select">
            <summary>
            Syntax helper that offers functors to select values of
            pair like objects such as <see cref="T:System.Collections.Generic.KeyValuePair`2"/>
            or <see cref="T:System.Collections.DictionaryEntry"/>.
            </summary>
        </member>
        <member name="M:NStl.SyntaxHelper.Select.FirstFromKeyValuePair``2">
            <summary>
            Returns a functor that will extract the first element for a KeyValuePair object.
            </summary>
            <typeparam name="Key"></typeparam>
            <typeparam name="Value"></typeparam>
            <returns></returns>
        </member>
        <member name="M:NStl.SyntaxHelper.Select.FirstFromDictionaryEntry``1">
            <summary>
            Returns a funcor that will extract the first value of a <see cref="T:System.Collections.DictionaryEntry"/>.
            </summary>
            <typeparam name="Key"></typeparam>
            <returns></returns>
        </member>
        <member name="M:NStl.SyntaxHelper.Select.SecondFromKeyValuePair``2">
            <summary>
            Returns a functor that will extract the second element for a KeyValuePair object.
            </summary>
            <typeparam name="Key"></typeparam>
            <typeparam name="Value"></typeparam>
            <returns></returns>
        </member>
        <member name="M:NStl.SyntaxHelper.Select.SecondFromDictionaryEntry``1">
            <summary>
            Returns a funcor that will extract the first value of a <see cref="T:System.Collections.DictionaryEntry"/>.
            </summary>
            <typeparam name="Value"></typeparam>
            <returns></returns>
        </member>
        <member name="M:NStl.Collections.Private.Position.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            See <see cref="M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)"/> for details.
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="T:NStl.IUnaryFunction`2">
            <summary>
            Represents a unary function, which is a method that takes one argument.
            </summary>
            <typeparam name="Result">The type to be returned.</typeparam>
            <typeparam name="Param">The type of the first parameter.</typeparam>
        </member>
        <member name="M:NStl.IUnaryFunction`2.Execute(`0)">
            <summary>
            This method gets called by the algorithms..
            </summary>
            <param name="par"></param>
            <returns></returns>
        </member>
        <member name="T:NStl.SyntaxHelper.Compare">
            <summary>
            Syntax helper to access all comparison related functors of the NSTL.
            </summary>
        </member>
        <member name="M:NStl.SyntaxHelper.Compare.EqualTo``1">
            <summary>
            Returns a functor that compares two objects by 
            calling <see cref="M:System.Object.Equals(System.Object,System.Object)"/>.
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:NStl.SyntaxHelper.Compare.NotEqualTo``1">
            <summary>
            Returns a functor that compares two objects. It is expected that 
            the objects to be compared implement the IComparable interface.
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:NStl.SyntaxHelper.Compare.Less``1">
            <summary>
            Returns a functor that compares two objects. It is expected that 
            the objects to be compared implement the IComparable interface.
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:NStl.SyntaxHelper.Compare.LessEqual``1">
            <summary>
            Returns a functor that compares two objects. It is expected that 
            the objects to be compared implement the IComparable interface.
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:NStl.SyntaxHelper.Compare.Greater``1">
            <summary>
            Returns a functor that compares two objects. It is expected that 
            the objects to be compared implement the IComparable interface.
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:NStl.SyntaxHelper.Compare.GreaterEqual``1">
            <summary>
            Returns a functor that compares two objects. It is expected that 
            the objects to be compared implement the IComparable interface.
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:NStl.SyntaxHelper.Compare.With``2(NStl.CompareAction,System.Collections.IComparer)">
            <summary>
            Returns a functor which provides the possibility to use an <see cref="T:System.Collections.IComparer"/>
            implementations inside stl.net algorithms. 
            </summary>
            <typeparam name="U"></typeparam>
            <typeparam name="V"></typeparam>
            <param name="action"></param>
            <param name="comparison"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.SyntaxHelper.Compare.With``1(NStl.CompareAction,System.Collections.Generic.IComparer{``0})">
            <summary>
            Returns a functor which provides the possibility to use an <see cref="T:System.Collections.Generic.IComparer`1"/>
            implementations inside NStl algorithms. 
            </summary>
            <typeparam name="T"></typeparam>
            <param name="action"></param>
            <param name="comparison"></param>
            <returns></returns>
        </member>
        <member name="T:NStl.Iterators.IRandomAccessInputIterator`1">
            <summary>
            A random acess input iterator extents the bidirectional input iterator with
            the possibility to do a constant time jump forward or backwards.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:NStl.Iterators.IRandomAccessInputIterator`1.Add(System.Int32)">
            <summary>
            When implemented, it returns a copy of this iterator moved
            count ahead/back. 
            </summary>
            <param name="count">How far the copied iterator will jump</param>
            <returns></returns>
            <remarks>This iterator stays where it is. The action performs in constant time</remarks>
        </member>
        <member name="M:NStl.Iterators.IRandomAccessInputIterator`1.Diff(NStl.Iterators.IRandomAccessInputIterator{`0})">
            <summary>
            Computes the distance between two iterators
            </summary>
            <param name="rhs"></param>
            <returns>The distance between two iterators</returns>
        </member>
        <member name="M:NStl.Iterators.IRandomAccessInputIterator`1.Less(NStl.Iterators.IRandomAccessInputIterator{`0})">
            <summary>
            Checks if this iterator is before the other
            </summary>
            <param name="rhs"></param>
            <returns></returns>
        </member>
        <member name="T:NStl.Algorithm">
            <summary>
            This static class contains all algorithms of the <b>NSTL</b>.
            </summary>
            <summary></summary>
        </member>
        <member name="M:NStl.Algorithm.Generate``2(``1,``1,NStl.INullaryFunction{``0})">
            <summary>
            <para>
            Generate assigns the result of invoking gen, a function object 
            that takes no arguments, to each element in the range [first, last).
            </para>
            <para>
            The complexity is linear.
            </para>
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="FwdIt"></typeparam>
            <param name="first">
            An <see cref="T:NStl.Iterators.IOutputIterator`1"/> pointing to the first item
            in the target range.
            </param>
            <param name="last">
            An <see cref="T:NStl.Iterators.IOutputIterator`1"/> pointing one past teh final item
            in the target range.
            </param>
            <param name="gen">
            The function object that is used to generate items.
            </param>
            <returns>
            An <see cref="T:NStl.Iterators.IOutputIterator`1"/> pointing to the end of the target range.
            </returns>
        </member>
        <member name="M:NStl.Algorithm.FindEnd``2(``1,``1,NStl.Iterators.IInputIterator{``0},NStl.Iterators.IInputIterator{``0},NStl.IBinaryFunction{``0,``0,System.Boolean})">
            <summary>
            <para>
            FindEnd is misnamed: it is much more similar to Search than to Find, 
            and a more accurate name would have been SearchEnd
            </para>
            <para>
            Like Search, FindEnd attempts to find a subsequence within the 
            range [first1, last1) that is identical to [first2, last2). 
            The difference is that while search finds the first such subsequence, 
            find_end finds the last such subsequence. FindEnd returns an iterator 
            pointing to the beginning of that subsequence; if no such subsequence 
            exists, it returns last1.
            </para>
            <para>
            The number of comparisons is proportional to (last1 - first1) * (last2 - first2). 
            </para>
            <para>
            The reason that this range is [first1, last1 - (last2 - first2)), 
            instead of simply [first1, last1), is that we are looking for 
            a subsequence that is equal to the complete sequence [first2, last2). 
            An iterator i can't be the beginning of such a subsequence unless last1 - i 
            is greater than or equal to last2 - first2. Note the implication of this: 
            you may call FindEnd with arguments such that last1 - first1 is less than last2 - first2,
            but such a search will always fail.
            </para>
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="FwdIt"></typeparam>
            <param name="first1">
            An <see cref="T:NStl.Iterators.IInputIterator`1"/> implementation pointing to 
            the first element of the range to be searched.
            </param>
            <param name="last1">
            An <see cref="T:NStl.Iterators.IInputIterator`1"/> implementation pointing 
            one past the final element of the range to be searched.
            </param>
            <param name="first2">
            An <see cref="T:NStl.Iterators.IInputIterator`1"/> implementation pointing to 
            the first element of the range to be found.
            </param>
            <param name="last2">
            An <see cref="T:NStl.Iterators.IInputIterator`1"/> implementation pointing 
            one past the final element of the range to be found.
            </param>
            <param name="equal">
            The functor that is used to determine if two elements are equal.
            </param>
            <returns>An iterator pointing to the first element of the 
            detected sub range or last1
            </returns>
        </member>
        <member name="M:NStl.Algorithm.FindEnd``2(``1,``1,NStl.Iterators.IInputIterator{``0},NStl.Iterators.IInputIterator{``0})">
            <summary>
            <para>
            FindEnd is misnamed: it is much more similar to Search than to Find, 
            and a more accurate name would have been SearchEnd
            </para>
            <para>
            Like Search, FindEnd attempts to find a subsequence within the 
            range [first1, last1) that is identical to [first2, last2). 
            The difference is that while search finds the first such subsequence, 
            find_end finds the last such subsequence. FindEnd returns an iterator 
            pointing to the beginning of that subsequence; if no such subsequence 
            exists, it returns last1.
            </para>
            <para>
            The number of comparisons is proportional to (last1 - first1) * (last2 - first2). 
            </para>
            <para>
            The reason that this range is [first1, last1 - (last2 - first2)), 
            instead of simply [first1, last1), is that we are looking for 
            a subsequence that is equal to the complete sequence [first2, last2). 
            An iterator i can't be the beginning of such a subsequence unless last1 - i 
            is greater than or equal to last2 - first2. Note the implication of this: 
            you may call FindEnd with arguments such that last1 - first1 is less than last2 - first2,
            but such a search will always fail.
            </para>
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="FwdIt"></typeparam>
            <param name="first1">
            An <see cref="T:NStl.Iterators.IInputIterator`1"/> implementation pointing to 
            the first element of the range to be searched.
            </param>
            <param name="last1">
            An <see cref="T:NStl.Iterators.IInputIterator`1"/> implementation pointing 
            one past the final element of the range to be searched.
            </param>
            <param name="first2">
            An <see cref="T:NStl.Iterators.IInputIterator`1"/> implementation pointing to 
            the first element of the range to be found.
            </param>
            <param name="last2">
            An <see cref="T:NStl.Iterators.IInputIterator`1"/> implementation pointing 
            one past the final element of the range to be found.
            </param>
            <returns>An iterator pointing to the first element of the 
            detected sub range or last1
            </returns>
        </member>
        <member name="M:NStl.Algorithm.FillN``2(``1,System.Int32,``0)">
            <summary>
            <para>
            FillN assigns the value val to every element in the range [dest, dest+n).
            </para>
            <para>
            The complexity is linear. FillN performs exactly n assignments.
            </para>
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="OutIt"></typeparam>
            <param name="dest">An output iterator pointing to the element in the
            destination range where the first assignment will happen.</param>
            <param name="count">The count of the assignments.</param>
            <param name="val">The value to assign.</param>
            <returns>An Output iterator pointing one past the last assigned value.</returns>
        </member>
        <member name="M:NStl.Algorithm.MakeHeap``1(NStl.Iterators.IRandomAccessIterator{``0},NStl.Iterators.IRandomAccessIterator{``0},NStl.IBinaryFunction{``0,``0,System.Boolean})">
            <summary>
            <para>
            MakeHeap turns the range [first, last) into a heap.
            </para>
            <para>
            The complexity is linear. At most 3*(last - first) comparisons.
            </para>
            </summary>
            <typeparam name="T"></typeparam>
            <param name="first">
            An <see cref="T:NStl.Iterators.IRandomAccessIterator`1"/> pointing to the first element of the range.
            </param>
            <param name="last">
            An <see cref="T:NStl.Iterators.IRandomAccessIterator`1"/> pointing one past the final element of the range.
            </param>
            <param name="comp">
            A predicate that defines the order of the heap.
            </param>
            <remarks>
            A heap is a particular way of ordering the elements in a range of <see cref="T:NStl.Iterators.IRandomAccessIterator`1"/>s [f, l). 
            The reason heaps are useful (especially for sorting, or as priority queues) is that they satisfy 
            two important properties. First, the value of f is the largest element in the heap. Second, 
            it is possible to add an element to a heap, 
            or to remove the first value, in logarithmic time. Internally, a heap is a tree represented as 
            a sequential range. The tree is constructed so that that each node is less than or equal to its parent node.
            </remarks>
        </member>
        <member name="M:NStl.Algorithm.MakeHeap``1(NStl.Iterators.IRandomAccessIterator{``0},NStl.Iterators.IRandomAccessIterator{``0})">
            <summary>
            <para>
            MakeHeap turns the range [first, last) into a heap.
            </para>
            <para>
            The complexity is linear. At most 3*(last - first) comparisons.
            </para>
            </summary>
            <typeparam name="T"></typeparam>
            <param name="first">
            An <see cref="T:NStl.Iterators.IRandomAccessIterator`1"/> pointing to the first element of the range.
            </param>
            <param name="last">
            An <see cref="T:NStl.Iterators.IRandomAccessIterator`1"/> pointing one past the final element of the range.
            </param>
            <remarks>
            A heap is a particular way of ordering the elements in a range of <see cref="T:NStl.Iterators.IRandomAccessIterator`1"/>s [f, l). 
            The reason heaps are useful (especially for sorting, or as priority queues) is that they satisfy 
            two important properties. First, the value of f is the largest element in the heap. Second, 
            it is possible to add an element to a heap, 
            or to remove the first value, in logarithmic time. Internally, a heap is a tree represented as 
            a sequential range. The tree is constructed so that that each node is less than or equal to its parent node.
            </remarks>
        </member>
        <member name="M:NStl.Algorithm.LowerBound``2(``1,``1,``0,NStl.IBinaryFunction{``0,``0,System.Boolean})">
            <summary>
            <para>
            Lower_bound attempts to find an element that is equal to or greater than 
            a given value in an ordered range.
            </para>
            <para>
            The complexity is logarithmic. At most log(last - first) + 1 comparisons.
            </para>
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="InIt"></typeparam>
            <param name="first">
            An input iterator pointing to the first element of the range.
            </param>
            <param name="last">
            An input iterator pointing one past the final element of the range.
            </param>
            <param name="val">
            The value to be searched for.
            </param>
            <param name="order">
            The order criterion of the range.
            </param>
            <returns>
            An iterator pointing to the found value or last.
            </returns>
        </member>
        <member name="M:NStl.Algorithm.LowerBound``2(``1,``1,``0)">
            <summary>
            <para>
            Lower_bound attempts to find an element that is equal to or greater than 
            a given value in an ordered range.
            </para>
            <para>
            The complexity is logarithmic. At most log(last - first) + 1 comparisons.
            </para>
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="InIt"></typeparam>
            <param name="first">
            An input iterator pointing to the first element of the range.
            </param>
            <param name="last">
            An input iterator pointing one past the final element of the range.
            </param>
            <param name="val">
            The value to be searched for.
            </param>
            <returns>
            An iterator pointing to the found value or last.
            </returns>
        </member>
        <member name="M:NStl.Algorithm.Mismatch``3(``1,``1,``2,NStl.IBinaryFunction{``0,``0,System.Boolean})">
            <summary>
            <para>
            Mismatch finds the first position where the two ranges [first1, last1) and [first2, first2 + (last1 - first1)) 
            differ by using a binary predicate.
            </para>
            <para>
            The complexity is linear. At most last1 - first1 comparisons.
            </para>
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="InIt1"></typeparam>
            <typeparam name="InIt2"></typeparam>
            <param name="first1">
            An input iterator pointing to the first element of the first range.
            </param>
            <param name="last1">
            An input iterator pointing one past the final element of the first range.
            </param>
            <param name="first2">
            An input iterator pointing to the first element of the second range.
            </param>
            <param name="pred">
            The binary predicate that is used to compare two elements.
            </param>
            <returns>
            A pair that contains the iterators pointing to the mismatching position, or a pair
            of end iterators if the ranges contain the same elements in the same order.
            </returns>
        </member>
        <member name="M:NStl.Algorithm.Mismatch``3(``1,``1,``2)">
            <summary>
            <para>
            Mismatch finds the first position where the two ranges [first1, last1) and [first2, first2 + (last1 - first1)) 
            differ by using <see cref="M:System.Object.Equals(System.Object,System.Object)"/>.
            </para>
            <para>
            The complexity is linear. At most last1 - first1 comparisons.
            </para>
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="FwdIt1"></typeparam>
            <typeparam name="FwdIt2"></typeparam>
            <param name="first1">
            An input iterator pointing to the first element of the first range.
            </param>
            <param name="last1">
            An input iterator pointing one past the final element of the first range.
            </param>
            <param name="first2">
            An input iterator pointing to the first element of the second range.
            </param>
            <returns>
            A pair that contains the iterators pointing to the mismatching position, or a pair
            of end iterators if the ranges contain the same elements in the same order.
            </returns>
            <remarks>
            Due to weak argument inference of C# you must specify the full generic argument list
            for this overload. It is recomanded to use <see cref="M:NStl.Algorithm.Mismatch``3(``1,``1,``2,NStl.IBinaryFunction{``0,``0,System.Boolean})"/>
            instead using <see cref="M:NStl.SyntaxHelper.Compare.EqualTo``1"/>, as the type inference will work here.
            </remarks>
        </member>
        <member name="M:NStl.Algorithm.LexicographicalCompare3Way``1(NStl.Iterators.IInputIterator{``0},NStl.Iterators.IInputIterator{``0},NStl.Iterators.IInputIterator{``0},NStl.Iterators.IInputIterator{``0},NStl.IBinaryFunction{``0,``0,System.Boolean})">
            <summary>
            <para>
            LexicographicalCompare3Way is essentially a generalization of the function strcmp 
            from the standard C library: it returns a negative number if the range [first1, last1) 
            is lexicographically less than the range [first2, last2), a positive number if 
            [first2, last2) is lexicographically less than [first1, last1), and zero if neither 
            range is lexicographically less than the other.
            </para>
            <para>
            As with <see cref="M:NStl.Algorithm.LexicographicalCompare``1(NStl.Iterators.IInputIterator{``0},NStl.Iterators.IInputIterator{``0},NStl.Iterators.IInputIterator{``0},NStl.Iterators.IInputIterator{``0},NStl.IBinaryFunction{``0,``0,System.Boolean})"/>, 
            lexicographical comparison means "dictionary" (element-by-element) ordering. That is, 
            LexicographicalCompare3Way returns a negative number if first1.value is less than first2.Value, 
            and a positive number if first1.Value is greater than first2.Value. If the two first 
            elements are equivalent then LexicographicalCompare3Way compares the two second elements, 
            and so on. LexicographicalCompare3Way returns 0 only if the two ranges [first1, last1) 
            and [first2, last2) have the same length and if every element in the first range is 
            equivalent to its corresponding element in the second.
            </para>
            <para>
            The complexity is linear. At most 2 * min(last1 - first1, last2 - first2) comparisons.
            </para>
            </summary>
            <typeparam name="T"></typeparam>
            <param name="first1">
            An <see cref="T:NStl.Iterators.IInputIterator`1"/> pointing to the first element of the first input range.
            </param>
            <param name="last1">
            An <see cref="T:NStl.Iterators.IInputIterator`1"/> pointing one past the final element of the first input range.
            </param>
            <param name="first2">
            An <see cref="T:NStl.Iterators.IInputIterator`1"/> pointing to the first element of the second input range.
            </param>
            <param name="last2">
            An <see cref="T:NStl.Iterators.IInputIterator`1"/> pointing one past the final element of the second input range.
            </param>
            <param name="less">The functor that is used to decide if one elemt is less than the other.</param>
            <returns>
            <list type="bullet">
            <item>-1 if the first range is lexicographical less than the second range.</item>
            <item>0 if the first range is lexicographical equal to the second range.</item>
            <item>1 if the first range is lexicographical greater than the second range.</item>
            </list>
            </returns>
        </member>
        <member name="M:NStl.Algorithm.LexicographicalCompare3Way``1(NStl.Iterators.IInputIterator{``0},NStl.Iterators.IInputIterator{``0},NStl.Iterators.IInputIterator{``0},NStl.Iterators.IInputIterator{``0})">
            <summary>
            <para>
            LexicographicalCompare3Way is essentially a generalization of the function strcmp 
            from the standard C library: it returns a negative number if the range [first1, last1) 
            is lexicographically less than the range [first2, last2), a positive number if 
            [first2, last2) is lexicographically less than [first1, last1), and zero if neither 
            range is lexicographically less than the other.
            </para>
            <para>
            As with <see cref="M:NStl.Algorithm.LexicographicalCompare``1(NStl.Iterators.IInputIterator{``0},NStl.Iterators.IInputIterator{``0},NStl.Iterators.IInputIterator{``0},NStl.Iterators.IInputIterator{``0},NStl.IBinaryFunction{``0,``0,System.Boolean})"/>, 
            lexicographical comparison means "dictionary" (element-by-element) ordering. That is, 
            LexicographicalCompare3Way returns a negative number if first1.value is less than first2.Value, 
            and a positive number if first1.Value is greater than first2.Value. If the two first 
            elements are equivalent then LexicographicalCompare3Way compares the two second elements, 
            and so on. LexicographicalCompare3Way returns 0 only if the two ranges [first1, last1) 
            and [first2, last2) have the same length and if every element in the first range is 
            equivalent to its corresponding element in the second.
            </para>
            <para>
            The complexity is linear. At most 2 * min(last1 - first1, last2 - first2) comparisons.
            </para>
            </summary>
            <typeparam name="T"></typeparam>
            <param name="first1">
            An <see cref="T:NStl.Iterators.IInputIterator`1"/> pointing to the first element of the first input range.
            </param>
            <param name="last1">
            An <see cref="T:NStl.Iterators.IInputIterator`1"/> pointing one past the final element of the first input range.
            </param>
            <param name="first2">
            An <see cref="T:NStl.Iterators.IInputIterator`1"/> pointing to the first element of the second input range.
            </param>
            <param name="last2">
            An <see cref="T:NStl.Iterators.IInputIterator`1"/> pointing one past the final element of the second input range.
            </param>
            <returns>
            <list type="bullet">
            <item>-1 if the first range is lexicographical less than the second range.</item>
            <item>0 if the first range is lexicographical equal to the second range.</item>
            <item>1 if the first range is lexicographical greater than the second range.</item>
            </list>
            </returns>
        </member>
        <member name="M:NStl.Algorithm.UniqueCopy``2(NStl.Iterators.IInputIterator{``0},NStl.Iterators.IInputIterator{``0},``1,NStl.IBinaryFunction{``0,``0,System.Boolean})">
            <summary>
            <para>
            UniqueCopy copies elements from the range [first, last) 
            to a range beginning with result, except that in 
            a consecutive group of duplicate elements only the first one is copied. 
            The return value is the end of the range to which the 
            elements are copied. This behavior is similar to the Unix filter uniq.
            </para>
            <para>
            The complexity is linear. Exactly last - first comparisons, 
            and at most last - first assignments.
            </para>
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="OutIt"></typeparam>
            <param name="first">
            An <see cref="T:NStl.Iterators.IInputIterator`1"/> pointing to the first element of the range.
            </param>
            <param name="last">
            An <see cref="T:NStl.Iterators.IInputIterator`1"/> pointing one past the final element of the range.
            </param>
            <param name="result">
            An <see cref="T:NStl.Iterators.IOutputIterator`1"/> specifying the first element of the target range.
            </param>
            <param name="equals">
            A functor that is used to determine of two values are equal.
            </param>
            <returns>
            An <see cref="T:NStl.Iterators.IOutputIterator`1"/> pointing to the end of the copied items.
            </returns>
        </member>
        <member name="M:NStl.Algorithm.UniqueCopy``2(NStl.Iterators.IInputIterator{``0},NStl.Iterators.IInputIterator{``0},``1)">
            <summary>
            <para>
            UniqueCopy copies elements from the range [first, last) 
            to a range beginning with result, except that in 
            a consecutive group of duplicate elements only the first one is copied. 
            The return value is the end of the range to which the 
            elements are copied. This behavior is similar to the Unix filter uniq.
            </para>
            <para>
            The complexity is linear. Exactly last - first comparisons, 
            and at most last - first assignments.
            </para>
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="OutIt"></typeparam>
            <param name="first">
            An <see cref="T:NStl.Iterators.IInputIterator`1"/> pointing to the first element of the range.
            </param>
            <param name="last">
            An <see cref="T:NStl.Iterators.IInputIterator`1"/> pointing one past the final element of the range.
            </param>
            <param name="result">
            An <see cref="T:NStl.Iterators.IOutputIterator`1"/> specifying the first element of the target range.
            </param>
            <returns>
            An <see cref="T:NStl.Iterators.IOutputIterator`1"/> pointing to the end of the copied items.
            </returns>
        </member>
        <member name="M:NStl.Algorithm.SwapRanges``2(NStl.Iterators.IForwardIterator{``0},NStl.Iterators.IForwardIterator{``0},``1)">
            <summary>
            <para>
            SwapRanges swaps each of the elements in the range [first1, last1) 
            with the corresponding element in the range [first2, first2 + (last1 - first1)). 
            </para>
            <para>
            The complexity is linear.
            </para>
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="FwdIt"></typeparam>
            <param name="first1">
            An <see cref="T:NStl.Iterators.IForwardIterator`1"/> implementation pointing
            to the first element of the first range to be swaped.
            </param>
            <param name="last1">
            An <see cref="T:NStl.Iterators.IForwardIterator`1"/> implementation pointing
            one past the final element of the first range to be swaped.</param>
            <param name="first2">
            An <see cref="T:NStl.Iterators.IForwardIterator`1"/> implementation pointing
            to the first element of the second range to be swaped.
            </param>
            <returns>
            Returns an iterator pointing one past the final swaped element in the
            second range.
            </returns>
        </member>
        <member name="M:NStl.Algorithm.Max``1(``0,``0,NStl.IBinaryFunction{``0,``0,System.Boolean})">
            <summary>
            <para>
            Max returns the greater of its two arguments; it returns 
            the first argument if neither is greater than the other.
            </para>
            <para>
            For primitive types such as <see cref="T:System.Single"/> or <see cref="T:System.SByte"/>
            consider using the <see cref="T:System.Math"/> class. Prefer this implementation
            if you need to provide an external comparison implementation.
            </para>
            </summary>
            <typeparam name="T"></typeparam>
            <param name="lhs">The first element to be compared.</param>
            <param name="rhs">The second element to be compared.</param>
            <param name="less">A functor that is used to determine if one element is less that another.</param>
            <returns>
            Returns the maximum element.
            </returns>
        </member>
        <member name="M:NStl.Algorithm.Max``1(``0,``0)">
            <summary>
            <para>
            Max returns the greater of its two arguments; it returns 
            the first argument if neither is greater than the other.
            </para>
            <para>
            For primitive types such as <see cref="T:System.Single"/> or <see cref="T:System.SByte"/>
            consider using the <see cref="T:System.Math"/> class.
            </para>
            </summary>
            <typeparam name="T"></typeparam>
            <param name="lhs">The first element to be compared.</param>
            <param name="rhs">The second element to be compared.</param>
            <returns>
            Returns the maximum element.
            </returns>
        </member>
        <member name="M:NStl.Algorithm.IsSorted``1(NStl.Iterators.IInputIterator{``0},NStl.Iterators.IInputIterator{``0},NStl.IBinaryFunction{``0,``0,System.Boolean})">
            <summary>
            <para>
            IsSorted returns true if the range [first, last) 
            is sorted in ascending order, and false otherwise.
            </para>
            <para>
            The complexity is linear. Zero comparisons if [first, last) 
            is an empty range, otherwise at most (last - first) - 1 comparisons.
            </para>
            </summary>
            <typeparam name="T"></typeparam>
            <param name="first">
            An <see cref="T:NStl.Iterators.IInputIterator`1"/> implementation pointing
            to first element of the range to be checked.
            </param>
            <param name="last">
            An <see cref="T:NStl.Iterators.IInputIterator`1"/> implementation pointing
            one past the final element of the range to be checked.
            </param>
            <param name="less">
            A functor that is used to determine if one element is less than the other.
            </param>
            <returns>
            True if the range is sorted, false otherwise.
            </returns>
        </member>
        <member name="M:NStl.Algorithm.IsSorted``1(NStl.Iterators.IInputIterator{``0},NStl.Iterators.IInputIterator{``0})">
            <summary>
            <para>
            IsSorted returns true if the range [first, last) 
            is sorted in ascending order, and false otherwise.
            </para>
            <para>
            The complexity is linear. Zero comparisons if [first, last) 
            is an empty range, otherwise at most (last - first) - 1 comparisons.
            </para>
            </summary>
            <typeparam name="T"></typeparam>
            <param name="first">
            An <see cref="T:NStl.Iterators.IInputIterator`1"/> implementation pointing
            to first element of the range to be checked.
            </param>
            <param name="last">
            An <see cref="T:NStl.Iterators.IInputIterator`1"/> implementation pointing
            one past the final element of the range to be checked.
            </param>
            <returns>
            True if the range is sorted, false otherwise.
            </returns>
        </member>
        <member name="M:NStl.Algorithm.EqualRange``2(``1,``1,``0,NStl.IBinaryFunction{``0,``0,System.Boolean})">
            <summary>
            <para>
            EqualRange is a version of binary search: it attempts to find the element value in an ordered range [first, last). 
            The value returned by EqualRange is essentially a combination of the values returned by LowerBound and UpperBound.
            </para>
            <para>
            The number of comparisons is logarithmic: at most 2 * log(last - first) + 1. 
            If the input iterator is a <see cref="T:NStl.Iterators.IRandomAccessIterator`1"/> then the number of steps through the range is 
            also logarithmic; otherwise, the number of steps is proportional to last - first.
            </para>
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="InIt"></typeparam>
            <param name="first">
            An input iterator pointing to the first element of the input range.
            </param>
            <param name="last">
            An input iterator pointing one past the final element of the input range.
            </param>
            <param name="val">The value to be searched for</param>
            <param name="less">The functor that rfepresents the order criteria.</param>
            <returns>
            A pair of iterators that represents the range of the found values. A pair of end 
            iterators if no value is found.
            </returns>
            <remarks>
            Note that you may use an ordering that is a strict weak ordering but not a total ordering; 
            that is, there might be values x and y such that x &lt; y, x &gt; y, and x == y are all false.
            </remarks>
        </member>
        <member name="M:NStl.Algorithm.EqualRange``2(``1,``1,``0)">
            <summary>
            <para>
            EqualRange is a version of binary search: it attempts to find the element value in an ordered range [first, last). 
            The value returned by EqualRange is essentially a combination of the values returned by LowerBound and UpperBound.
            </para>
            <para>
            The complexity is logarithmic: at most 2 * log(last - first) + 1 comparisons.
            </para>
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="InIt"></typeparam>
            <param name="first">
            An input iterator pointing to the first element of the input range.
            </param>
            <param name="last">
            An input iterator pointing one past the final element of the input range.
            </param>
            <param name="val">The value to be searched for</param>
            <returns>
            A pair of iterators that represents the range of the found values. A pair of end 
            iterators if no value is found.
            </returns>
            <remarks>
            Note that you may use an ordering that is a strict weak ordering but not a total ordering; 
            that is, there might be values x and y such that x &lt; y, x &gt; y, and x == y are all false.
            </remarks>
        </member>
        <member name="M:NStl.Algorithm.AdjacentFind``2(``1,``1,NStl.IBinaryFunction{``0,``0,System.Boolean})">
            <summary>
            <para>
            This algorithm searches for two adjacent elements that fullfill a
            condition specified by a binary predicate.
            </para>
            <para>
            The compexity is linear.
            </para>
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="InIt"></typeparam>
            <param name="first">
            An input iterator pointing to the first element of the range.
            </param>
            <param name="last">
            An input iterator pointing one past the final element of the range.
            </param>
            <param name="predicate">
            The predicate that has to to be satisfied.
            </param>
            <returns>
            An iterator pointing to the first element of the adjacent pair.
            </returns>
        </member>
        <member name="M:NStl.Algorithm.AdjacentFind``2(``1,``1)">
            <summary>
            <para>
            This algorithm searches for two adjacent elements that are equal.
            </para>
            <para>
            The compexity is linear.
            </para>
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="InIt"></typeparam>
            <param name="first">
            An input iterator pointing to the first element of the range.
            </param>
            <param name="last">
            An input iterator pointing one past the final element of the range.
            </param>
            <returns>
            An iterator pointing to the first element of the adjacent pair.
            </returns>
            <remarks>
            When using this overload you are forced to fully qualify all generic 
            arguments due to a lack in the C#'s compiler parameter inference.
            </remarks>
        </member>
        <member name="M:NStl.Algorithm.Swap``1(``0@,``0@)">
            <summary>
            <para>
            Assigns the contents of lhs to rhs and the contents of rhs to lhs. This is used as a 
            primitive operation by many other algorithms.
            </para>
            <para>
            The complexity is amortized constant time.
            </para>
            </summary>
            <typeparam name="T"></typeparam>
            <param name="lhs">The left hand side value to be swapped.</param>
            <param name="rhs">The right hand side value to be swapped.</param>
        </member>
        <member name="M:NStl.Algorithm.SetUnion``2(NStl.Iterators.IInputIterator{``0},NStl.Iterators.IInputIterator{``0},NStl.Iterators.IInputIterator{``0},NStl.Iterators.IInputIterator{``0},``1,NStl.IBinaryFunction{``0,``0,System.Boolean})">
            <summary>
            <para>
            SetUnion constructs a sorted range that is the union of the sorted ranges 
            [first1, last1) and [first2, last2). The return value is the end of the output 
            range.
            </para>
            <para>
            In the simplest case, SetUnion performs the "union" operation from set theory:
            the output range contains a copy of every element that is contained in 
            [first1, last1), [first2, last2), or both. The general case is more complicated,
            because the input ranges may contain duplicate elements. The generalization 
            is that if a value appears m times in [first1, last1) and n times in 
            [first2, last2) (where m or n may be zero), then it appears max(m,n) times 
            in the output range. [1] SetUnion is stable, meaning both that the relative 
            order of elements within each input range is preserved, and that if an element 
            is present in both input ranges it is copied from the first range rather than 
            the second.
            </para>
            <para>
            The two versions of SetUnion differ in how they define whether 
            one element is less than another. The first version compares objects using
            <see cref="M:NStl.SyntaxHelper.Compare.Less``1"/>, and the second compares objects using a function object comp.
            </para>
            <para>
            The complexity is linear.
            </para>
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="OutIt"></typeparam>
            <param name="first1">
            An input iterator pointing to the first element of the first input range.
            </param>
            <param name="last1">
            An input iterator pointing one past the final element of the first input range.
            </param>
            <param name="first2">
            An input iterator pointing to the first element of the first second range.
            </param>
            <param name="last2">
            An input iterator pointing one past the final element of the first second range.
            </param>
            <param name="dest">
            An output iterator pointing to the first element of the destination range.
            </param>
            <param name="less">
            The predicate defining a strict weak ordering of the elements.
            </param>
            <returns>
            An iterator pointing one past the final element of the output range.
            </returns>
        </member>
        <member name="M:NStl.Algorithm.SetUnion``2(NStl.Iterators.IInputIterator{``0},NStl.Iterators.IInputIterator{``0},NStl.Iterators.IInputIterator{``0},NStl.Iterators.IInputIterator{``0},``1)">
            <summary>
            <para>
            SetUnion constructs a sorted range that is the union of the sorted ranges 
            [first1, last1) and [first2, last2). The return value is the end of the output 
            range.
            </para>
            <para>
            In the simplest case, SetUnion performs the "union" operation from set theory:
            the output range contains a copy of every element that is contained in 
            [first1, last1), [first2, last2), or both. The general case is more complicated,
            because the input ranges may contain duplicate elements. The generalization 
            is that if a value appears m times in [first1, last1) and n times in 
            [first2, last2) (where m or n may be zero), then it appears max(m,n) times 
            in the output range. [1] SetUnion is stable, meaning both that the relative 
            order of elements within each input range is preserved, and that if an element 
            is present in both input ranges it is copied from the first range rather than 
            the second.
            </para>
            <para>
            The two versions of SetUnion differ in how they define whether 
            one element is less than another. The first version compares objects using
            <see cref="M:NStl.SyntaxHelper.Compare.Less``1"/>, and the second compares objects using a function object comp.
            </para>
            <para>
            The complexity is linear.
            </para>
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="OutIt"></typeparam>
            <param name="first1">
            An input iterator pointing to the first element of the first input range.
            </param>
            <param name="last1">
            An input iterator pointing one past the final element of the first input range.
            </param>
            <param name="first2">
            An input iterator pointing to the first element of the first second range.
            </param>
            <param name="last2">
            An input iterator pointing one past the final element of the first second range.
            </param>
            <param name="dest">
            An output iterator pointing to the first element of the destination range.
            </param>
            <returns>
            An iterator pointing one past the final element of the output range.
            </returns>
        </member>
        <member name="M:NStl.Algorithm.PopHeap``1(NStl.Iterators.IRandomAccessIterator{``0},NStl.Iterators.IRandomAccessIterator{``0},NStl.IBinaryFunction{``0,``0,System.Boolean})">
            <summary>
            PopHeap removes the largest element (that is, first.Value) from the heap [first, last). 
            The two versions of PopHeap differ in how they define whether one element is less 
            than another. This version compares objects using a function object comp.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="first">
            An <see cref="T:NStl.Iterators.IRandomAccessIterator`1"/> pointing to the first element of the range.
            </param>
            <param name="last">
            An <see cref="T:NStl.Iterators.IRandomAccessIterator`1"/> pointing one past the final element of the range.
            </param>
            <param name="comp">A predicate that defines the order of the heap.</param>
            <remarks>
            <para>
            The postcondition for the first version of PopHeap is that 
            Algorithm.IsHeap(first, last-1) is true and that *(last - 1) is the element that 
            was removed from the heap. The postcondition for the second version is that 
            Algorithm.IsHeap(first, last-1, comp) is true and that (last - 1).Value is the 
            element that was removed from the heap.
            </para>
            <para>
            A heap is a particular way of ordering the elements in a range of <see cref="T:NStl.Iterators.IRandomAccessIterator`1"/>s [f, l). 
            The reason heaps are useful (especially for sorting, or as priority queues) is that they satisfy 
            two important properties. First, the value of f is the largest element in the heap. Second, 
            it is possible to add an element to a heap, 
            or to remove the first value, in logarithmic time. Internally, a heap is a tree represented as 
            a sequential range. The tree is constructed so that that each node is less than or equal to its parent node.
            </para>
            </remarks>    
        </member>
        <member name="M:NStl.Algorithm.PopHeap``1(NStl.Iterators.IRandomAccessIterator{``0},NStl.Iterators.IRandomAccessIterator{``0})">
            <summary>
            PopHeap removes the largest element (that is, first.Value) from the heap [first, last). 
            The two versions of PopHeap differ in how they define whether one element is less 
            than another. This version compares objects using the <see cref="T:System.IComparable`1"/> implemetation.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="first">
            An <see cref="T:NStl.Iterators.IRandomAccessIterator`1"/> pointing to the first element of the range.
            </param>
            <param name="last">
            An <see cref="T:NStl.Iterators.IRandomAccessIterator`1"/> pointing one past the final element of the range.
            </param>
            <remarks>
            <para>
            The postcondition for the first version of PopHeap is that 
            Algorithm.IsHeap(first, last-1) is true and that *(last - 1) is the element that 
            was removed from the heap. The postcondition for the second version is that 
            Algorithm.IsHeap(first, last-1, comp) is true and that (last - 1).Value is the 
            element that was removed from the heap.
            </para>
            <para>
            A heap is a particular way of ordering the elements in a range of <see cref="T:NStl.Iterators.IRandomAccessIterator`1"/>s [f, l). 
            The reason heaps are useful (especially for sorting, or as priority queues) is that they satisfy 
            two important properties. First, the value of f is the largest element in the heap. Second, 
            it is possible to add an element to a heap, 
            or to remove the first value, in logarithmic time. Internally, a heap is a tree represented as 
            a sequential range. The tree is constructed so that that each node is less than or equal to its parent node.
            </para>
            </remarks>    
        </member>
        <member name="M:NStl.Algorithm.Min``1(``0,``0,NStl.IBinaryFunction{``0,``0,System.Boolean})">
            <summary>
            <para>
            Min returns the greater of its two arguments; it returns 
            the first argument if neither is greater than the other.
            </para>
            <para>
            For primitive types such as <see cref="T:System.Single"/> or <see cref="T:System.SByte"/>
            consider using the <see cref="T:System.Math"/> class. Prefer this implementation
            if you need to provide an external comparison implementation.
            </para>
            </summary>
            <typeparam name="T"></typeparam>
            <param name="lhs">The first element to be compared.</param>
            <param name="rhs">The second element to be compared.</param>
            <param name="less">A functor that is used to determine if one element is less that another.</param>
            <returns>
            Returns the minimum element.
            </returns>
        </member>
        <member name="M:NStl.Algorithm.Min``1(``0,``0)">
            <summary>
            <para>
            Min returns the greater of its two arguments; it returns 
            the first argument if neither is greater than the other.
            </para>
            <para>
            For primitive types such as <see cref="T:System.Single"/> or <see cref="T:System.SByte"/>
            consider using the <see cref="T:System.Math"/> class.
            </para>
            </summary>
            <typeparam name="T"></typeparam>
            <param name="lhs">The first element to be compared.</param>
            <param name="rhs">The second element to be compared.</param>
            <returns>
            Returns the minimum element.
            </returns>
        </member>
        <member name="M:NStl.Algorithm.FindFirstOf``2(``1,``1,NStl.Iterators.IInputIterator{``0},NStl.Iterators.IInputIterator{``0},NStl.IBinaryFunction{``0,``0,System.Boolean})">
            <summary>
            <para>
            FindFirstOf is similar to Find, in that it performs linear search 
            through a range of <see cref="T:NStl.Iterators.IInputIterator`1"/>. The difference 
            is that while Find searches for one particular value, FindFirstOf 
            searches for any of several values. Specifically, FindFirstOf 
            searches for the first occurrance in the range [first1, last1) 
            of any of the elements in [first2, last2). (Note that this behavior 
            is reminiscent of the function strpbrk from the standard C library.)
            </para>
            <para>
            The complexity is linear. At most (last1 - first1) * (last2 - first2) 
            comparisons.
            </para>
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="InIt"></typeparam>
            <param name="first1">
            An <see cref="T:NStl.Iterators.IInputIterator`1"/> pointing to the first element 
            of the range to be searched.
            </param>
            <param name="last1">
            An <see cref="T:NStl.Iterators.IInputIterator`1"/> pointing one past the final element 
            of the range to be searched.
            </param>
            <param name="first2">
            An <see cref="T:NStl.Iterators.IInputIterator`1"/> pointing to the first element 
            of the range to be searched for.
            </param>
            <param name="last2">
            An <see cref="T:NStl.Iterators.IInputIterator`1"/> pointing one past the final element 
            of the range to be searched for.
            </param>
            <param name="equal">
            A functor that is used to check two elements for equality.
            </param>
            <returns>
            An iterator pointing to the first occurence of one of the elements
            of the second range; otherwise the end iterator of the first range.
            </returns>
        </member>
        <member name="M:NStl.Algorithm.FindFirstOf``2(``1,``1,NStl.Iterators.IInputIterator{``0},NStl.Iterators.IInputIterator{``0})">
            <summary>
            <para>
            FindFirstOf is similar to Find, in that it performs linear search 
            through a range of <see cref="T:NStl.Iterators.IInputIterator`1"/>. The difference 
            is that while Find searches for one particular value, FindFirstOf 
            searches for any of several values. Specifically, FindFirstOf 
            searches for the first occurrance in the range [first1, last1) 
            of any of the elements in [first2, last2). (Note that this behavior 
            is reminiscent of the function strpbrk from the standard C library.)
            </para>
            <para>
            The complexity is linear. At most (last1 - first1) * (last2 - first2) 
            comparisons.
            </para>
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="InIt"></typeparam>
            <param name="first1">
            An <see cref="T:NStl.Iterators.IInputIterator`1"/> pointing to the first element 
            of the range to be searched.
            </param>
            <param name="last1">
            An <see cref="T:NStl.Iterators.IInputIterator`1"/> pointing one past the final element 
            of the range to be searched.
            </param>
            <param name="first2">
            An <see cref="T:NStl.Iterators.IInputIterator`1"/> pointing to the first element 
            of the range to be searched for.
            </param>
            <param name="last2">
            An <see cref="T:NStl.Iterators.IInputIterator`1"/> pointing one past the final element 
            of the range to be searched for.
            </param>
            <returns>
            An iterator pointing to the first occurence of one of the elements
            of the second range; otherwise the end iterator of the first range.
            </returns>
        </member>
        <member name="M:NStl.Algorithm.BinarySearch``2(``1,``1,``0,NStl.IBinaryFunction{``0,``0,System.Boolean})">
            <summary>
            <para>
            Tries to find a given value inside of a sorted range by doing a binary search.
            </para>
            <para>
            The number of comparisons is logarithmic: at most log(last - first) + 2.
            </para>
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="InIt"></typeparam>
            <param name="first">
            An input iterator pointing to the first element of the range.
            </param>
            <param name="last">
            An input iterator pointing one past the final element of the range.
            </param>
            <param name="value">
            The value to be searched for.
            </param>
            <param name="less">
            The order criterion of the range.
            </param>
            <returns>
            An iterator pointing to the value or last if the value is
            not in the range.
            </returns>
        </member>
        <member name="M:NStl.Algorithm.BinarySearch``2(``1,``1,``0)">
            <summary>
            <para>
            Tries to find a given value inside of a sorted range by doing a binary search.
            </para>
            <para>
            The number of comparisons is logarithmic: at most log(last - first) + 2.
            </para>
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="InIt"></typeparam>
            <param name="first">
            An input iterator pointing to the first element of the range.
            </param>
            <param name="last">
            An input iterator pointing one past the final element of the range.
            </param>
            <param name="value">
            The value to be searched for.
            </param>
            <returns>
            An iterator pointing to the value or last if the value is
            not in the range.
            </returns>
        </member>
        <member name="M:NStl.Algorithm.SortHeap``1(NStl.Iterators.IRandomAccessIterator{``0},NStl.Iterators.IRandomAccessIterator{``0},NStl.IBinaryFunction{``0,``0,System.Boolean})">
            <summary>
            SortHeap turns a heap [first, last) into a sorted range. Note that this is 
            not a stable sort: the relative order of equivalent elements is not guaranteed 
            to be preserved.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="first">
            An <see cref="T:NStl.Iterators.IRandomAccessIterator`1"/> pointing to the first element of the range.
            </param>
            <param name="last">
            An <see cref="T:NStl.Iterators.IRandomAccessIterator`1"/> pointing one past the last element of the range.
            </param>
            <param name="comp">
            A binary predicate that defines the order of the heap.
            </param>
        </member>
        <member name="M:NStl.Algorithm.SortHeap``1(NStl.Iterators.IRandomAccessIterator{``0},NStl.Iterators.IRandomAccessIterator{``0})">
            <summary>
            SortHeap turns a heap [first, last) into a sorted range. Note that this is 
            not a stable sort: the relative order of equivalent elements is not guaranteed 
            to be preserved.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="first">
            An <see cref="T:NStl.Iterators.IRandomAccessIterator`1"/> pointing to the first element of the range.
            </param>
            <param name="last">
            An <see cref="T:NStl.Iterators.IRandomAccessIterator`1"/> pointing one past the last element of the range.
            </param>
        </member>
        <member name="M:NStl.Algorithm.SetIntersection``2(NStl.Iterators.IInputIterator{``0},NStl.Iterators.IInputIterator{``0},NStl.Iterators.IInputIterator{``0},NStl.Iterators.IInputIterator{``0},``1,NStl.IBinaryFunction{``0,``0,System.Boolean})">
            <summary>
            <para>
            SetIntersection constructs a sorted range that is the intersection of the sorted 
            ranges [first1, last1) and [first2, last2). The return value is the end of the 
            output range.
            </para>
            <para>
            In the simplest case, SetIntersection performs the "intersection" operation 
            from set theory: the output range contains a copy of every element that is contained 
            in both [first1, last1) and [first2, last2). The general case is more complicated,
            because the input ranges may contain duplicate elements. The generalization 
            is that if a value appears m times in [first1, last1) and n times in [first2, last2)
            (where m or n may be zero), then it appears min(m,n) times in the output range.
            SetIntersection is stable, meaning both that elements are copied from the first 
            range rather than the second, and that the relative order of elements in the 
            output range is the same as in the first input range.
            </para>
            <para>
            The two versions of SetIntersection differ in how they define whether one element 
            is less than another. The first version compares objects using <see cref="M:NStl.SyntaxHelper.Compare.Less``1"/>, and 
            the second compares objects using a function object comp.
            </para>
            <para>
            The complexity is linear.
            </para>
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="OutIt"></typeparam>
            <param name="first1">
            An input iterator pointing to the first element of the first input range.
            </param>
            <param name="last1">
            An input iterator pointing one past the final element of the first input range.
            </param>
            <param name="first2">
            An input iterator pointing to the first element of the first second range.
            </param>
            <param name="last2">
            An input iterator pointing one past the final element of the first second range.
            </param>
            <param name="dest">
            An output iterator pointing to the first element of the destination range.
            </param>
            <param name="less">
            The predicate defining a strict weak ordering of the elements.
            </param>
            <returns>
            An iterator pointing one past the final element of the output range.
            </returns>
        </member>
        <member name="M:NStl.Algorithm.SetIntersection``2(NStl.Iterators.IInputIterator{``0},NStl.Iterators.IInputIterator{``0},NStl.Iterators.IInputIterator{``0},NStl.Iterators.IInputIterator{``0},``1)">
            <summary>
            <para>
            SetIntersection constructs a sorted range that is the intersection of the sorted 
            ranges [first1, last1) and [first2, last2). The return value is the end of the 
            output range.
            </para>
            <para>
            In the simplest case, SetIntersection performs the "intersection" operation 
            from set theory: the output range contains a copy of every element that is contained 
            in both [first1, last1) and [first2, last2). The general case is more complicated,
            because the input ranges may contain duplicate elements. The generalization 
            is that if a value appears m times in [first1, last1) and n times in [first2, last2)
            (where m or n may be zero), then it appears min(m,n) times in the output range.
            SetIntersection is stable, meaning both that elements are copied from the first 
            range rather than the second, and that the relative order of elements in the 
            output range is the same as in the first input range.
            </para>
            <para>
            The two versions of SetIntersection differ in how they define whether one element 
            is less than another. The first version compares objects using <see cref="M:NStl.SyntaxHelper.Compare.Less``1"/>, and 
            the second compares objects using a function object.
            </para>
            <para>
            The complexity is linear.
            </para>
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="OutIt"></typeparam>
            <param name="first1">
            An input iterator pointing to the first element of the first input range.
            </param>
            <param name="last1">
            An input iterator pointing one past the final element of the first input range.
            </param>
            <param name="first2">
            An input iterator pointing to the first element of the first second range.
            </param>
            <param name="last2">
            An input iterator pointing one past the final element of the first second range.
            </param>
            <param name="dest">
            An output iterator pointing to the first element of the destination range.
            </param>
            <returns>
            An iterator pointing one past the final element of the output range.
            </returns>
        </member>
        <member name="M:NStl.Algorithm.IterSwap``1(NStl.Iterators.IForwardIterator{``0},NStl.Iterators.IForwardIterator{``0})">
            <summary>
            Swaps the values of two iterators.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="lhs">The first iterator.</param>
            <param name="rhs">The second iterator.</param>
        </member>
        <member name="M:NStl.Algorithm.Iota``1(NStl.Iterators.IOutputIterator{``0},NStl.Iterators.IOutputIterator{``0},``0,``0,NStl.IBinaryFunction{``0,``0,``0})">
            <summary>
            Iota assigns sequentially increasing values to a range.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="first">An <see cref="T:NStl.Iterators.IOutputIterator`1"/> pointing to the first element of the target range.</param>
            <param name="last">An <see cref="T:NStl.Iterators.IOutputIterator`1"/> pointing one past the last element of the target range.</param>
            <param name="value">The initial value to be assigned</param>
            <param name="increment">The amount that the value is incremented on each step.</param>
            <param name="plus">The functor that is used to increment "value" by "increment".</param>
        </member>
        <member name="M:NStl.Algorithm.StableSort``1(NStl.Iterators.IRandomAccessIterator{``0},NStl.Iterators.IRandomAccessIterator{``0},NStl.IBinaryFunction{``0,``0,System.Boolean})">
            <summary>
            <para>
            StableSort is much like <see cref="M:NStl.Algorithm.Sort``1(NStl.Iterators.IRandomAccessIterator{``0},NStl.Iterators.IRandomAccessIterator{``0},NStl.IBinaryFunction{``0,``0,System.Boolean})"/>:
            it sorts the elements in [first, last) into ascending order, 
            meaning that if i and j are any two valid iterators in [first, last) 
            such that i precedes j, then j.Value is not less than i.Value. 
            StableSort differs from Sort in two ways. First, StableSort 
            uses an algorithm that has different run-time complexity than Sort. 
            Second, as the name suggests, StableSort is stable: 
            it preserves the relative ordering of equivalent elements.
            </para>
            <para>
            Note that two elements may be equivalent without being equal. 
            One standard example is sorting a sequence of names by last name: 
            if two people have the same last name but different first names, 
            then they are equivalent but not equal. This is why StableSort is sometimes 
            useful: if you are sorting a sequence of records that have several 
            different fields, then you may want to sort it by one field without 
            completely destroying the ordering that you previously obtained from 
            sorting it by a different field. You might, for example, sort by 
            first name and then do a stable sort by last name.
            </para>
            <para>
            StableSort is an adaptive algorithm: it attempts to allocate a 
            temporary memory buffer, and its run-time complexity depends 
            on how much memory is available. Worst-case behavior (if no auxiliary memory is available) 
            is N (log N)^2 comparisons, where N is last - first, and best 
            case (if a large enough auxiliary memory buffer is available) is N (log N).
            </para>
            </summary>
            <typeparam name="T"></typeparam>
            <param name="first">
            An <see cref="T:NStl.Iterators.IRandomAccessIterator`1"/> implementation pointing to the
            first element in the range to be sorted.
            </param>
            <param name="last">
            An <see cref="T:NStl.Iterators.IRandomAccessIterator`1"/> implementation pointing 
            one past the final element in the range to be sorted.
            </param>
            <param name="less">
            A functor object that is used to determine if one object is less than another.
            </param>
            <remarks>
            StableSort uses the merge sort algorithm; see section 5.2.4 of Knuth. 
            (D. E. Knuth, The Art of Computer Programming. Volume 3: Sorting and 
            Searching. Addison-Wesley, 1975.)
            </remarks>
        </member>
        <member name="M:NStl.Algorithm.StableSort``1(NStl.Iterators.IRandomAccessIterator{``0},NStl.Iterators.IRandomAccessIterator{``0})">
            <summary>
            <para>
            StableSort is much like <see cref="M:NStl.Algorithm.Sort``1(NStl.Iterators.IRandomAccessIterator{``0},NStl.Iterators.IRandomAccessIterator{``0})"/>:
            it sorts the elements in [first, last) into ascending order, 
            meaning that if i and j are any two valid iterators in [first, last) 
            such that i precedes j, then j.Value is not less than i.Value. 
            StableSort differs from Sort in two ways. First, StableSort 
            uses an algorithm that has different run-time complexity than Sort. 
            Second, as the name suggests, StableSort is stable: 
            it preserves the relative ordering of equivalent elements.
            </para>
            <para>
            Note that two elements may be equivalent without being equal. 
            One standard example is sorting a sequence of names by last name: 
            if two people have the same last name but different first names, 
            then they are equivalent but not equal. This is why StableSort is sometimes 
            useful: if you are sorting a sequence of records that have several 
            different fields, then you may want to sort it by one field without 
            completely destroying the ordering that you previously obtained from 
            sorting it by a different field. You might, for example, sort by 
            first name and then do a stable sort by last name.
            </para>
            <para>
            StableSort is an adaptive algorithm: it attempts to allocate a 
            temporary memory buffer, and its run-time complexity depends 
            on how much memory is available. Worst-case behavior (if no auxiliary memory is available) 
            is N (log N)^2 comparisons, where N is last - first, and best 
            case (if a large enough auxiliary memory buffer is available) is N (log N).
            </para>
            </summary>
            <typeparam name="T"></typeparam>
            <param name="first">
            An <see cref="T:NStl.Iterators.IRandomAccessIterator`1"/> implementation pointing to the
            first element in the range to be sorted.
            </param>
            <param name="last">
            An <see cref="T:NStl.Iterators.IRandomAccessIterator`1"/> implementation pointing 
            one past the final element in the range to be sorted.
            </param>
            <remarks>
            StableSort uses the merge sort algorithm; see section 5.2.4 of Knuth. 
            (D. E. Knuth, The Art of Computer Programming. Volume 3: Sorting and 
            Searching. Addison-Wesley, 1975.)
            </remarks>
        </member>
        <member name="M:NStl.Algorithm.Rotate``2(``1,``1,``1)">
            <summary>
            <para>
            Rotate rotates the elements in a range. That is, the element pointed 
            to by middle is moved to the position first, the element pointed to 
            by middle + 1 is moved to the position first + 1, and so on. 
            One way to think about this operation is that it exchanges the 
            two ranges [first, middle) and [middle, last). 
            </para>
            <para>
            The complexity is linear. At most last - first swaps are performed.
            </para>
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="FwdIt">
            </typeparam>
            <param name="first">
            An <see cref="T:NStl.Iterators.IForwardIterator`1"/> implementation pointing to
            the first element of the range to be rotated.
            </param>
            <param name="middle">
            An iterator pointing between first and last specifying the rotation axis.
            </param>
            <param name="last">
            An <see cref="T:NStl.Iterators.IForwardIterator`1"/> implementation pointing 
            one past the final element of the range to be rotated.</param>
            <returns>
            An iterator pointing to first + (last - middle).
            </returns>
            <remarks>
            Rotate uses a different algorithm depending on whether its arguments are 
            Forward Iterators, Bidirectional Iterators, or Random Access Iterators. 
            All three algorithms, however, are linear.
            </remarks>
        </member>
        <member name="M:NStl.Algorithm.Partition``2(``1,``1,NStl.IUnaryFunction{``0,System.Boolean})">
            <summary>
            <para>
            Partition reorders the elements in the range [first, last) based 
            on the function object pred, such that the elements that satisfy 
            pred precede the elements that fail to satisfy it. 
            </para>
            <para>
            The relative order of elements in these two blocks is not 
            necessarily the same as it was in the original sequence.
            A different algorithm, <see cref="M:NStl.Algorithm.StablePartition``2(``1,``1,NStl.IUnaryFunction{``0,System.Boolean})"/>, 
            does guarantee to preserve the relative order.
            </para>
            <para>
            The complexity is linear. Exactly last - first applications 
            of pred, and at most (last - first)/2 swaps.
            </para>
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="FwdIt"></typeparam>
            <param name="first">
            A <see cref="T:NStl.Iterators.IForwardIterator`1"/> implementation pointing 
            to the first element of the range to be partitioned.
            </param>
            <param name="last">
            A <see cref="T:NStl.Iterators.IForwardIterator`1"/> implementation pointing 
            to the first element of the range to be partitioned.
            </param>
            <param name="pred">The predicate to be satisfied.</param>
            <returns>
            A <see cref="T:NStl.Iterators.IForwardIterator`1"/> implementation pointing to the
            partition boundary.
            </returns>
        </member>
        <member name="M:NStl.Algorithm.NthElement``1(NStl.Iterators.IRandomAccessIterator{``0},NStl.Iterators.IRandomAccessIterator{``0},NStl.Iterators.IRandomAccessIterator{``0},NStl.IBinaryFunction{``0,``0,System.Boolean})">
            <summary>
            <para>
            NthElement is similar to <see cref="M:NStl.Algorithm.PartialSort``1(NStl.Iterators.IRandomAccessIterator{``0},NStl.Iterators.IRandomAccessIterator{``0},NStl.Iterators.IRandomAccessIterator{``0},NStl.IBinaryFunction{``0,``0,System.Boolean})"/>,
            in that it partially orders a range of elements: it arranges the range [first, last) 
            such that the element pointed to by the iterator nth is the same as the element 
            that would be in that position if the entire range [first, last) had been sorted. 
            Additionally, none of the elements in the range [nth, last) is less 
            than any of the elements in the range [first, nth).
            </para>
            <para>
            The complexity is linear, on average last - first. Note that 
            this is significantly less than the run-time complexity of PartialSort.
            </para>
            </summary>
            <typeparam name="T"></typeparam>
            <param name="first">
            An <see cref="T:NStl.Iterators.IRandomAccessIterator`1"/> implementation pointing to
            the first element of the range.
            </param>
            <param name="nth">
            An <see cref="T:NStl.Iterators.IRandomAccessIterator`1"/> implementation specifying the
            position of the nth element.
            </param>
            <param name="last">
            An <see cref="T:NStl.Iterators.IRandomAccessIterator`1"/> implementation pointing one
            past the final element of the range.
            </param>
            <param name="less">
            A functor that is used to determine if one element is less than the other.
            </param>
            <remarks>
            The way in which this differs from PartialSort is that neither the 
            range [first, nth) nor the range [nth, last) is be sorted: it is simply 
            guaranteed that none of the elements in [nth, last) is less than 
            any of the elements in [first, nth). In that sense, NthElement is 
            more similar to partition than to sort. NthElement does less work 
            than PartialSort, so, reasonably enough, it is faster. That's 
            the main reason to use NthElement instead of PartialSort.
            </remarks>
        </member>
        <member name="M:NStl.Algorithm.NthElement``1(NStl.Iterators.IRandomAccessIterator{``0},NStl.Iterators.IRandomAccessIterator{``0},NStl.Iterators.IRandomAccessIterator{``0})">
            <summary>
            <para>
            NthElement is similar to <see cref="M:NStl.Algorithm.PartialSort``1(NStl.Iterators.IRandomAccessIterator{``0},NStl.Iterators.IRandomAccessIterator{``0},NStl.Iterators.IRandomAccessIterator{``0})"/>,
            in that it partially orders a range of elements: it arranges the range [first, last) 
            such that the element pointed to by the iterator nth is the same as the element 
            that would be in that position if the entire range [first, last) had been sorted. 
            Additionally, none of the elements in the range [nth, last) is less 
            than any of the elements in the range [first, nth).
            </para>
            <para>
            The complexity is linear, on average last - first. Note that 
            this is significantly less than the run-time complexity of PartialSort.
            </para>
            </summary>
            <typeparam name="T"></typeparam>
            <param name="first">
            An <see cref="T:NStl.Iterators.IRandomAccessIterator`1"/> implementation pointing to
            the first element of the range.
            </param>
            <param name="nth">
            An <see cref="T:NStl.Iterators.IRandomAccessIterator`1"/> implementation specifying the
            position of the nth element.
            </param>
            <param name="last">
            An <see cref="T:NStl.Iterators.IRandomAccessIterator`1"/> implementation pointing one
            past the final element of the range.
            </param>
            <remarks>
            The way in which this differs from PartialSort is that neither the 
            range [first, nth) nor the range [nth, last) is be sorted: it is simply 
            guaranteed that none of the elements in [nth, last) is less than 
            any of the elements in [first, nth). In that sense, NthElement is 
            more similar to partition than to sort. NthElement does less work 
            than PartialSort, so, reasonably enough, it is faster. That's 
            the main reason to use NthElement instead of PartialSort.
            </remarks>
        </member>
        <member name="M:NStl.Algorithm.Merge``2(NStl.Iterators.IInputIterator{``0},NStl.Iterators.IInputIterator{``0},NStl.Iterators.IInputIterator{``0},NStl.Iterators.IInputIterator{``0},``1,NStl.IBinaryFunction{``0,``0,System.Boolean})">
            <summary>
            <para>
            Merge combines two sorted ranges [first1, last1) and [first2, last2) 
            into a single sorted range. 
            </para>
            <para>
            Merge is stable, meaning both that the relative order of 
            elements within each input range is preserved, and that 
            for equivalent elements in both input ranges the element 
            from the first range precedes the element from the second. 
            The return value is result + (last1 - first1) + (last2 - first2).
            </para>
            <para>
            </para>
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="OutputIt"></typeparam>
            <param name="first1">
            An <see cref="T:NStl.Iterators.IInputIterator`1"/> implementation pointing 
            to the first element of the first range to be merged.
            </param>
            <param name="last1">
            An <see cref="T:NStl.Iterators.IInputIterator`1"/> implementation pointing 
            one past the final element of the first range to be merged.
            </param>
            <param name="first2">
            An <see cref="T:NStl.Iterators.IInputIterator`1"/> implementation pointing 
            to the first element of the second range to be merged.
            </param>
            <param name="last2">
            An <see cref="T:NStl.Iterators.IInputIterator`1"/> implementation pointing 
            one past the final element of the second range to be merged.
            </param>
            <param name="result">
            Am <see cref="T:NStl.Iterators.IOutputIterator`1"/> implementation pointing to the
            start of the target range.
            </param>
            <param name="less">
            A functor that is used to determine if one element 
            is less than another.
            </param>
            <returns>
            Returns an <see cref="T:NStl.Iterators.IOutputIterator`1"/> implementation 
            pointing one past the last element of the target range.
            </returns>
            <remarks>
            Note that you may use an ordering that is a strict weak ordering but 
            not a total ordering; that is, there might be values x and y such 
            that x &lt; y, x &gt; y, and x == y are all false. 
            Two elements x and y are equivalent if neither x &lt; y nor y &lt; x. 
            If you're using a total ordering, however (if you're using strcmp, 
            for example, or if you're using ordinary arithmetic comparison on integers), 
            then you can ignore this technical distinction: for a total ordering, 
            equality and equivalence are the same.
            </remarks>
        </member>
        <member name="M:NStl.Algorithm.Merge``2(NStl.Iterators.IInputIterator{``0},NStl.Iterators.IInputIterator{``0},NStl.Iterators.IInputIterator{``0},NStl.Iterators.IInputIterator{``0},``1)">
            <summary>
            <para>
            Merge combines two sorted ranges [first1, last1) and [first2, last2) 
            into a single sorted range. 
            </para>
            <para>
            Merge is stable, meaning both that the relative order of 
            elements within each input range is preserved, and that 
            for equivalent elements in both input ranges the element 
            from the first range precedes the element from the second. 
            The return value is result + (last1 - first1) + (last2 - first2).
            </para>
            <para>
            </para>
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="OutputIt"></typeparam>
            <param name="first1">
            An <see cref="T:NStl.Iterators.IInputIterator`1"/> implementation pointing 
            to the first element of the first range to be merged.
            </param>
            <param name="last1">
            An <see cref="T:NStl.Iterators.IInputIterator`1"/> implementation pointing 
            one past the final element of the first range to be merged.
            </param>
            <param name="first2">
            An <see cref="T:NStl.Iterators.IInputIterator`1"/> implementation pointing 
            to the first element of the second range to be merged.
            </param>
            <param name="last2">
            An <see cref="T:NStl.Iterators.IInputIterator`1"/> implementation pointing 
            one past the final element of the second range to be merged.
            </param>
            <param name="result">
            Am <see cref="T:NStl.Iterators.IOutputIterator`1"/> implementation pointing to the
            start of the target range.
            </param>
            <returns>
            Returns an <see cref="T:NStl.Iterators.IOutputIterator`1"/> implementation 
            pointing one past the last element of the target range.
            </returns>
            <remarks>
            Note that you may use an ordering that is a strict weak ordering but 
            not a total ordering; that is, there might be values x and y such 
            that x &lt; y, x &gt; y, and x == y are all false. 
            Two elements x and y are equivalent if neither x &lt; y nor y &lt; x. 
            If you're using a total ordering, however (if you're using strcmp, 
            for example, or if you're using ordinary arithmetic comparison on integers), 
            then you can ignore this technical distinction: for a total ordering, 
            equality and equivalence are the same.
            </remarks>
        </member>
        <member name="M:NStl.Algorithm.RotateCopy``2(NStl.Iterators.IInputIterator{``0},NStl.Iterators.IInputIterator{``0},NStl.Iterators.IInputIterator{``0},``1)">
            <summary>
            <para>
            RotateCopy copies elements from the range [first, last) 
            to the range [result, result + (last - first)).
            </para>
            <para>
            The complexity is linear. RotateCopy performs exactly last - first assignments.
            </para>
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="OutputIt"></typeparam>
            <param name="first">
            An <see cref="T:NStl.Iterators.IInputIterator`1"/> implementation pointing to
            the first element of the range to be rotated and copied.
            </param>
            <param name="middle">
            An iterator pointing between first and last specifying the rotation axis.
            </param>
            <param name="last">
            An <see cref="T:NStl.Iterators.IInputIterator`1"/> implementation pointing 
            one past the final element of the range to be rotated and copied.
            </param>
            <param name="result"></param>
            <returns>
            An iterator pointing one past the final element of the target range.
            </returns>
        </member>
        <member name="M:NStl.Algorithm.InnerProduct``1(NStl.Iterators.IInputIterator{``0},NStl.Iterators.IInputIterator{``0},NStl.Iterators.IInputIterator{``0},``0,NStl.IBinaryFunction{``0,``0,``0},NStl.IBinaryFunction{``0,``0,``0})">
            <summary>
            <para>
            InnerProduct returns init plus the inner product of the two ranges.
            That is, it first initializes the result to init and then, for each 
            iterator i in [first1, last1), in order from the beginning to the 
            end of the range, updates the result by 
            result = opPlus.Execute(result, opMultiply.Execute(first1.Value, first2.Value)).
            </para>
            <para>
            There are several reasons why it is important that InnerProduct starts with 
            the value init. One of the most basic is that this allows InnerProduct to 
            have a well-defined result even if [first1, last1) is an empty range: 
            if it is empty, the return value is init. The ordinary inner product 
            corresponds to setting init to 0.
            </para>
            <para>
            The complexity is linear. Exactly last1 - first1 applications of each binary operation.
            </para>
            </summary>
            <typeparam name="T"></typeparam>
            <param name="first1">
            An <see cref="T:NStl.Iterators.IInputIterator`1"/> implementation pointing 
            to the first element of the first input range.
            </param>
            <param name="last1">
            An <see cref="T:NStl.Iterators.IInputIterator`1"/> implementation pointing 
            one past the final element of the first input range.
            </param>
            <param name="first2">
            An <see cref="T:NStl.Iterators.IInputIterator`1"/> implementation pointing 
            to the first element of the second input range.
            </param>
            <param name="init">The initial value.</param>
            <param name="opPlus">The functor that is used to add the result of opMultiply.</param>
            <param name="opMultiply">The functor that is used to multiply the corresponding elements of both ranges.</param>
            <returns></returns>
            <remarks>
            Neither binary operation is required to be either associative or 
            commutative: the order of all operations is specified.
            </remarks>
        </member>
        <member name="M:NStl.Algorithm.Fill``1(NStl.Iterators.IOutputIterator{``0},NStl.Iterators.IOutputIterator{``0},``0)">
            <summary>
            <para>Fill assigns the value value to every element in the range [first, last).</para>
            <para>The complexity is linear.</para>
            </summary>
            <typeparam name="T"></typeparam>
            <param name="first">An output iterator pointing to the first element to assign.</param>
            <param name="last">An output iterator pointing one past the last element to assign to.</param>
            <param name="val">The value to assign.</param>
        </member>
        <member name="M:NStl.Algorithm.Copy``2(NStl.Iterators.IInputIterator{``0},NStl.Iterators.IInputIterator{``0},``1)">
            <summary>
            <para>
            Copy copies elements from the range [first, last) to the 
            destination range. Assignments are performed in forward order.
            </para>
            The complexity is linear. Exactly last - first assignments are performed.
            <para>
            </para>
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="OutputIt"></typeparam>
            <param name="first">
            An input iterator pointing to the first element of the range.
            </param>
            <param name="last">
            An input iterator pointing one past the final element of the range.
            </param>
            <param name="destination">
            An output iterator pointing to the first element of the destination range.
            </param>
            <returns>
            Returns an iterator pointing one past the last copied element in the 
            destination range.
            </returns>
            <remarks>
            <para>
            Copy cannot be used to insert elements into an empty range: it overwrites 
            elements, rather than inserting elements. If you want to insert elements into 
            a range, you can use copy along with insertion adaptors that can be obtained
            from the <see cref="T:NStl.NStlUtil"/> helper class.
            </para>
            <para>
            The order of assignments matters in the case where the input and output ranges 
            overlap: copy may not be used if result is in the range [first, last). That 
            is, it may not be used if the beginning of the output range overlaps with the 
            input range, but it may be used if the end of the output range overlaps with 
            the input range; CopyBackward has opposite restrictions. If the two ranges 
            are completely nonoverlapping, of course, then either algorithm may be used. 
            </para>
            </remarks>
        </member>
        <member name="M:NStl.Algorithm.Copy``2(System.Collections.Generic.IEnumerable{``0},``1)">
            <summary>
            <para>
            Copy copies elements from the source range to the 
            destination range. Assignments are performed in forward order.
            </para>
            The complexity is linear. Exactly source.Count assignments are performed.
            <para>
            </para>
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="OutputIt"></typeparam>
            <param name="source">The source range.</param>
            <param name="dest">
            An output iterator pointing to the first element of the destination range.
            </param>
            <returns>
            Returns an iterator pointing one past the last copied element in the 
            destination range.
            </returns>
            <remarks>
            <para>
            Copy cannot be used to insert elements into an empty range: it overwrites 
            elements, rather than inserting elements. If you want to insert elements into 
            a range, you can use copy along with insertion adaptors that can be obtained
            from the <see cref="T:NStl.NStlUtil"/> helper class.
            </para>
            <para>
            The order of assignments matters in the case where the input and output ranges 
            overlap: copy may not be used if result is in the source range. That 
            is, it may not be used if the beginning of the output range overlaps with the 
            input range, but it may be used if the end of the output range overlaps with 
            the input range; CopyBackward has opposite restrictions. If the two ranges 
            are completely nonoverlapping, of course, then either algorithm may be used. 
            </para>
            </remarks>
        </member>
        <member name="M:NStl.Algorithm.CopyIf``2(NStl.Iterators.IInputIterator{``0},NStl.Iterators.IInputIterator{``0},``1,NStl.IUnaryFunction{``0,System.Boolean})">
            <summary>
            <para>
            CopyIf copies elements from the range [first, last) to the 
            destination range if the predicate avaluates to true. 
            Assignments are performed in forward order.
            </para>
            <para>
            The complexity is linear. Al most last - first assignments are performed.
            </para>
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="OutputIt"></typeparam>
            <param name="first">
            An input iterator pointing to the first element of the range.
            </param>
            <param name="last">
            An input iterator pointing one past the final element of the range.
            </param>
            <param name="dest">
            An output iterator pointing to the first element of the destination range.
            </param>
            <param name="pred">
            The predicate that decides if a value is copied to the destination range.
            </param>
            <returns>
            Returns an iterator pointing one past the last copied element in the 
            destination range.
            </returns>
            <remarks>
            <para>
            Copy cannot be used to insert elements into an empty range: it overwrites 
            elements, rather than inserting elements. If you want to insert elements into 
            a range, you can use copy along with insertion adaptors that can be obtained
            from the <see cref="T:NStl.NStlUtil"/> helper class.
            </para>
            <para>
            The order of assignments matters in the case where the input and output ranges 
            overlap: copy may not be used if result is in the range [first, last). That 
            is, it may not be used if the beginning of the output range overlaps with the 
            input range, but it may be used if the end of the output range overlaps with 
            the input range; copy_backward has opposite restrictions. If the two ranges 
            are completely nonoverlapping, of course, then either algorithm may be used. 
            </para>
            </remarks>
        </member>
        <member name="M:NStl.Algorithm.MaxElement``2(``1,``1,NStl.IBinaryFunction{``0,``0,System.Boolean})">
            <summary>
            <para>
            MaxElement finds the largest element in the range [first, last). 
            It returns the first iterator i in [first, last) such that no 
            other iterator in [first, last) points to a value greater than i.Value. 
            The return value is last if and only if [first, last) is an empty range.
            </para>
            <para>
            The complexity is linear. Zero comparisons if [first, last) is an 
            empty range, otherwise exactly (last - first) - 1 comparisons.
            </para>
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="FwdIt"></typeparam>
            <param name="first">
            An <see cref="T:NStl.Iterators.IForwardIterator`1"/> pointing to the first element of the range.
            </param>
            <param name="last">
            An <see cref="T:NStl.Iterators.IForwardIterator`1"/> pointing one past the last element of the range.
            </param>
            <param name="less">The function object that determines if one element is less than another.</param>
            <returns>An iterator pointing to the maximum element of the range.</returns>
        </member>
        <member name="M:NStl.Algorithm.MaxElement``2(``1,``1)">
            <summary>
            <para>
            MaxElement finds the largest element in the range [first, last). 
            It returns the first iterator i in [first, last) such that no 
            other iterator in [first, last) points to a value greater than i.Value. 
            The return value is last if and only if [first, last) is an empty range.
            </para>
            <para>
            The complexity is linear. Zero comparisons if [first, last) is an 
            empty range, otherwise exactly (last - first) - 1 comparisons.
            </para>
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="FwdIt"></typeparam>
            <param name="first">
            An <see cref="T:NStl.Iterators.IForwardIterator`1"/> pointing to the first element of the range.
            </param>
            <param name="last">
            An <see cref="T:NStl.Iterators.IForwardIterator`1"/> pointing one past the last element of the range.
            </param>
            <returns>An iterator pointing to the maximum element of the range.</returns>
        </member>
        <member name="M:NStl.Algorithm.Sort``1(NStl.Iterators.IRandomAccessIterator{``0},NStl.Iterators.IRandomAccessIterator{``0},NStl.IBinaryFunction{``0,``0,System.Boolean})">
            <summary>
            <para>
            Sort sorts the elements in [first, last) into ascending order. 
            </para>
            <para>
            The complexity is O(N log(N))(both average and worst-case).
            </para>
            </summary>
            <typeparam name="T"></typeparam>
            <param name="first">
            An <see cref="T:NStl.Iterators.IRandomAccessIterator`1"/> implementation pointing 
            to the first element of the range to be sorted.
            </param>
            <param name="last">
            An <see cref="T:NStl.Iterators.IRandomAccessIterator`1"/> implementation pointing 
            one past the final element of the range to be sorted.
            </param>
            <param name="less">
            A functor that is used to determine if one value is less than another.
            </param>
            <remarks>
            <para>
            Sort is not guaranteed to be stable. That is, suppose that i.Value and j.Value
            are equivalent: neither one is less than the other. It is not guaranteed 
            that the relative order of these two elements will be preserved by Sort.
            </para>
            <para>
            Also using build in sort methods, e.g. <see cref="M:System.Collections.Generic.List`1.Sort"/> 
            of containers is usually faster.
            </para>
            </remarks>
        </member>
        <member name="M:NStl.Algorithm.Sort``1(NStl.Iterators.IRandomAccessIterator{``0},NStl.Iterators.IRandomAccessIterator{``0})">
            <summary>
            <para>
            Sort sorts the elements in [first, last) into ascending order. 
            </para>
            <para>
            The complexity is O(N log(N))(both average and worst-case).
            </para>
            </summary>
            <typeparam name="T"></typeparam>
            <param name="first">
            An <see cref="T:NStl.Iterators.IRandomAccessIterator`1"/> implementation pointing 
            to the first element of the range to be sorted.
            </param>
            <param name="last">
            An <see cref="T:NStl.Iterators.IRandomAccessIterator`1"/> implementation pointing 
            one past the final element of the range to be sorted.
            </param>
            <remarks>
            <para>
            Sort is not guaranteed to be stable. That is, suppose that i.Value and j.Value
            are equivalent: neither one is less than the other. It is not guaranteed 
            that the relative order of these two elements will be preserved by Sort.
            </para>
            <para>
            Also using build in sort methods, e.g. <see cref="M:System.Collections.Generic.List`1.Sort"/> 
            of containers is usually faster.
            </para>
            </remarks>
        </member>
        <member name="M:NStl.Algorithm.Accumulate``1(NStl.Iterators.IInputIterator{``0},NStl.Iterators.IInputIterator{``0},``0,NStl.IBinaryFunction{``0,``0,``0})">
            <summary>
            <para>
            Accumulate is a generalization of summation: 
            it computes the sum (or some other binary operation)
            of init and all of the elements in the range [first, last). 
            </para>
            <para>
            The complexity is linear. Exactly last - first 
            invocations of the binary operation.
            </para>
            </summary>
            <typeparam name="T"></typeparam>
            <param name="first">
            An <see cref="T:NStl.Iterators.IInputIterator`1"/> implementation pointing to
            the first element of the range.
            </param>
            <param name="last">
            An <see cref="T:NStl.Iterators.IInputIterator`1"/> implementation pointing to
            the end of the range.
            </param>
            <param name="init">The initial value that every element is added to.</param>
            <param name="binaryFunction">
            A functor that combines two elements to one output.
            </param>
            <returns>
            The sum of all items in the range.
            </returns>
            <remarks>
            There are several reasons why it is important that accumulate 
            starts with the value init. One of the most basic is that this 
            allows Accumulate to have a well-defined result even 
            if [first, last) is an empty range: if it is empty, the 
            return value is init. If you want to find the sum of all 
            of the elements in [first, last), you can just pass 0 as init.
            </remarks>
        </member>
        <member name="M:NStl.Algorithm.Accumulate``1(System.Collections.Generic.IEnumerable{``0},``0,NStl.IBinaryFunction{``0,``0,``0})">
            <summary>
            <para>
            Accumulate is a generalization of summation: 
            it computes the sum (or some other binary operation)
            of init and all of the elements in the input range. 
            </para>
            <para>
            The complexity is linear. Exactly last - first 
            invocations of the binary operation.
            </para>
            </summary>
            <typeparam name="T"></typeparam>
            <param name="range">The input range.</param>
            <param name="init">The initial value that every element is added to.</param>
            <param name="binaryFunction">
            A functor that combines two elements to one output.
            </param>
            <returns>
            The sum of all items in the range.
            </returns>
            <remarks>
            There are several reasons why it is important that accumulate 
            starts with the value init. One of the most basic is that this 
            allows Accumulate to have a well-defined result even 
            if input range is an empty range: if it is empty, the 
            return value is init. If you want to find the sum of all 
            of the elements in input range, you can just pass 0 as init.
            </remarks>
        </member>
        <member name="M:NStl.Algorithm.Search``2(``1,``1,NStl.Iterators.IInputIterator{``0},NStl.Iterators.IInputIterator{``0},NStl.IBinaryFunction{``0,``0,System.Boolean})">
            <summary>
            <para>
            Search finds a subsequence within the range [first1, last1) that 
            is identical to [first2, last2) when compared element-by-element. 
            It returns an iterator pointing to the beginning of that subsequence, 
            or else last1 if no such subsequence exists.
            </para>
            <para>
            The worst case behavior is quadratic: at most (last1 - first1) * (last2 - first2) 
            comparisons. This worst case, however, is rare. Average complexity is linear.
            </para>
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="FwdIt"></typeparam>
            <param name="first1">
            An <see cref="T:NStl.Iterators.IInputIterator`1"/> implementation that points to 
            the first element of the range to be searched.
            </param>
            <param name="last1">
            An <see cref="T:NStl.Iterators.IInputIterator`1"/> implementation that points one past the final
            element of the range to be searched.
            </param>
            <param name="first2">
            An <see cref="T:NStl.Iterators.IInputIterator`1"/> implementation that points to 
            the first element of the sub range to be searched for.
            </param>
            <param name="last2">
            An <see cref="T:NStl.Iterators.IInputIterator`1"/> implementation that points one past the final
            element of the sub range to be searched for.
            </param>
            <param name="equal">A functor that is used to determine if two elements are equal.</param>
            <returns>
            An iterator pointing to the first element in [first1, last1)
            where a subsequence starts that is equal to [first2, last2). It returns last1 
            if no match is found or first1 if one or both ranges are empty.
            </returns>
        </member>
        <member name="M:NStl.Algorithm.Search``2(``1,``1,NStl.Iterators.IInputIterator{``0},NStl.Iterators.IInputIterator{``0})">
            <summary>
            <para>
            Search finds a subsequence within the range [first1, last1) that 
            is identical to [first2, last2) when compared element-by-element. 
            It returns an iterator pointing to the beginning of that subsequence, 
            or else last1 if no such subsequence exists.
            </para>
            <para>
            The worst case behavior is quadratic: at most (last1 - first1) * (last2 - first2) 
            comparisons. This worst case, however, is rare. Average complexity is linear.
            </para>
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="FwdIt"></typeparam>
            <param name="first1">
            An <see cref="T:NStl.Iterators.IInputIterator`1"/> implementation that points to 
            the first element of the range to be searched.
            </param>
            <param name="last1">
            An <see cref="T:NStl.Iterators.IInputIterator`1"/> implementation that points one past the final
            element of the range to be searched.
            </param>
            <param name="first2">
            An <see cref="T:NStl.Iterators.IInputIterator`1"/> implementation that points to 
            the first element of the sub range to be searched for.
            </param>
            <param name="last2">
            An <see cref="T:NStl.Iterators.IInputIterator`1"/> implementation that points one past the final
            element of the sub range to be searched for.
            </param>
            <returns>
            An iterator pointing to the first element in [first1, last1)
            where a subsequence starts that is equal to [first2, last2). It returns last1 
            if no match is found or first1 if one or both ranges are empty.
            </returns>
        </member>
        <member name="M:NStl.Algorithm.RemoveCopyIf``2(NStl.Iterators.IInputIterator{``0},NStl.Iterators.IInputIterator{``0},``1,NStl.IUnaryFunction{``0,System.Boolean})">
            <summary>
            <para>
            RemoveCopyIf copies elements from the range [first, last) to a range beginning 
            at result, except that elements for which pred is true are not copied. The 
            return value is the end of the resulting range. This operation is stable, meaning 
            that the relative order of the elements that are copied is the same as in 
            the range [first, last).
            </para>
            <para>
            The complexity is linear. Exactly last - first applications of pred, and at 
            most last - first assignments.
            </para>
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="OutputIt"></typeparam>
            <param name="first">
            An input iterator pointing to the first element of the range.
            </param>
            <param name="last">
            An input iterator pointing one past the final element of the range.
            </param>
            <param name="dest">
            An output iterator pointing to the first element of the destination range.
            </param>
            <param name="pred">
            The preidcate that decides if a a value is removed and copied.
            </param>
            <returns>
            An output iterator pointing one past the final element of the destination range.
            </returns>
        </member>
        <member name="M:NStl.Algorithm.RemoveCopy``2(NStl.Iterators.IInputIterator{``0},NStl.Iterators.IInputIterator{``0},``1,``0)">
            <summary>
            <para>
            RemoveCopy copies elements that are not equal to value from the range [first, last) 
            to a range beginning at result. The return value is the end of the resulting 
            range. This operation is stable, meaning that the relative order of the elements 
            that are copied is the same as in the range [first, last).
            </para>
            <para>
            The complexity is linear. Exactly last - first comparisons for equality, and at 
            most last - first assignments.
            </para>
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="OutputIt"></typeparam>
            <param name="first">
            An input iterator pointing to the first element of the range.
            </param>
            <param name="last">
            An input iterator pointing one past the final element of the range.
            </param>
            <param name="dest">
            An output iterator pointing to the first element of the destination range.
            </param>
            <param name="val">
            The value that will be removed from the source range and copied into the 
            destination range.
            </param>
            <returns>
            An output iterator pointing one past the final element of the destination range.
            </returns>
        </member>
        <member name="M:NStl.Algorithm.PushHeap``1(NStl.Iterators.IRandomAccessIterator{``0},NStl.Iterators.IRandomAccessIterator{``0},NStl.IBinaryFunction{``0,``0,System.Boolean})">
            <summary>
            <para>
            PushHeap adds an element to a heap. It is assumed that [first, last - 1) is already a heap
            and that the element to be added to the heap is the last in the range.
            </para>
            <para>
            The complexity is logarithmic. At most log(last - first) comparisons.
            </para>
            </summary>
            <typeparam name="T"></typeparam>
            <param name="first">
            An <see cref="T:NStl.Iterators.IRandomAccessIterator`1"/> pointing to the first element of the range.
            </param>
            <param name="last">
            An <see cref="T:NStl.Iterators.IRandomAccessIterator`1"/> pointing one past the final element of the range.
            </param>
            <param name="comp">
            A predicate that defines the order of the heap.
            </param>
            <remarks>
            A heap is a particular way of ordering the elements in a range of <see cref="T:NStl.Iterators.IRandomAccessIterator`1"/>s [f, l). 
            The reason heaps are useful (especially for sorting, or as priority queues) is that they satisfy 
            two important properties. First, the value of f is the largest element in the heap. Second, 
            it is possible to add an element to a heap, 
            or to remove the first value, in logarithmic time. Internally, a heap is a tree represented as 
            a sequential range. The tree is constructed so that that each node is less than or equal to its parent node.
            </remarks>
        </member>
        <member name="M:NStl.Algorithm.PushHeap``1(NStl.Iterators.IRandomAccessIterator{``0},NStl.Iterators.IRandomAccessIterator{``0})">
            <summary>
            <para>
            PushHeap adds an element to a heap. It is assumed that [first, last - 1) is already a heap
            and that the element to be added to the heap is the last in the range.
            </para>
            <para>
            The complexity is logarithmic. At most log(last - first) comparisons.
            </para>
            </summary>
            <typeparam name="T"></typeparam>
            <param name="first">
            An input iterator pointing to the first element of the range.
            </param>
            <param name="last">
            An input iterator pointing one past the final element of the range.
            </param>
            <remarks>
            A heap is a particular way of ordering the elements in a range of random access iterators [f, l). 
            The reason heaps are useful (especially for sorting, or as priority queues) is that they satisfy 
            two important properties. First, the value of f is the largest element in the heap. Second, 
            it is possible to add an element to a heap, 
            or to remove the first value, in logarithmic time. Internally, a heap is a tree represented as 
            a sequential range. The tree is constructed so that that each node is less than or equal to its parent node.
            </remarks>
        </member>
        <member name="M:NStl.Algorithm.GenerateN``2(``1,System.Int32,NStl.INullaryFunction{``0})">
            <summary>
            <para>
            GenerateN assigns the result of invoking gen, a function object 
            that takes no arguments, to each element in the range [first, first + n).
            </para>
            <para>
            The complexity is linear.
            </para>
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="FwdIt"></typeparam>
            <param name="first">
            An <see cref="T:NStl.Iterators.IOutputIterator`1"/> pointing to the first item
            in the target range.
            </param>
            <param name="n">
            The amount of items to be generated.
            </param>
            <param name="gen">
            The function object that is used to generate items.
            </param>
            <returns>
            An <see cref="T:NStl.Iterators.IOutputIterator`1"/> pointing to the end of the target range.
            </returns>
        </member>
        <member name="M:NStl.Algorithm.CountIf``1(NStl.Iterators.IInputIterator{``0},NStl.Iterators.IInputIterator{``0},NStl.IUnaryFunction{``0,System.Boolean})">
            <summary>
            <para>
            Count_if finds the number of elements in [first, last) that satisfy the predicate pred.
            </para>
            The complexity is linear.
            <para>
            </para>
            </summary>
            <typeparam name="T"></typeparam>
            <param name="first">
            An input iterator pointing to the first element of the range.
            </param>
            <param name="last">
            An input iterator pointing one past the final element of the range.
            </param>
            <param name="pred"></param>
            <returns>The count of elements that let the predicate evaluet to true.</returns>
        </member>
        <member name="M:NStl.Algorithm.Count``1(NStl.Iterators.IInputIterator{``0},NStl.Iterators.IInputIterator{``0},``0)">
            <summary>
            <para>
            Count finds the number of elements in [first, last).
            </para>
            The complexity is linear.
            <para>
            </para>
            </summary>
            <typeparam name="T"></typeparam>
            <param name="first">
            An input iterator pointing to the first element of the range.
            </param>
            <param name="last">
            An input iterator pointing one past the final element of the range.
            </param>
            <param name="val">The value to be counted.</param>
            <returns>The count of elements that are equal to the input value.</returns>
        </member>
        <member name="M:NStl.Algorithm.RandomSampleN``2(NStl.Iterators.IInputIterator{``0},NStl.Iterators.IInputIterator{``0},``1,System.Int32,NStl.IUnaryFunction{System.Int32,System.Int32})">
            <summary>
            RandomSampleN randomly copies a sample of the elements from the range [first, last) 
            into the range [out, out + n). Each element in the input range appears at most once 
            in the output range, and samples are chosen with uniform probability. 
            Elements in the output range appear in the same relative order as their relative order 
            within the input range.
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="OutIt"></typeparam>
            <param name="first">
            An <see cref="T:NStl.Iterators.IInputIterator`1"/> that points to the first element of the sample input range.
            </param>
            <param name="last">
            An <see cref="T:NStl.Iterators.IInputIterator`1"/> that points one past the final element of the sample input range.
            </param>
            <param name="target">
            An <see cref="T:NStl.Iterators.IOutputIterator`1"/> that points to the first element of target range.
            </param>
            <param name="n">The amout of elements to be copied.</param>
            <param name="randomNumber">A functor that generates random numbers.</param>
            <returns></returns>
        </member>
        <member name="M:NStl.Algorithm.RandomSampleN``2(NStl.Iterators.IInputIterator{``0},NStl.Iterators.IInputIterator{``0},``1,System.Int32)">
            <summary>
            RandomSampleN randomly copies a sample of the elements from the range [first, last) 
            into the range [out, out + n). Each element in the input range appears at most once 
            in the output range, and samples are chosen with uniform probability. 
            Elements in the output range appear in the same relative order as their relative order 
            within the input range.
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="OutIt"></typeparam>
            <param name="first">
            An <see cref="T:NStl.Iterators.IInputIterator`1"/> that points to the first element of the sample input range.
            </param>
            <param name="last">
            An <see cref="T:NStl.Iterators.IInputIterator`1"/> that points one past the final element of the sample input range.
            </param>
            <param name="target">
            An <see cref="T:NStl.Iterators.IOutputIterator`1"/> that points to the first element of target range.
            </param>
            <param name="n">The amout of elements to be copied.</param>
            <returns></returns>
        </member>
        <member name="M:NStl.Algorithm.PrevPermutation``1(NStl.Iterators.IBidirectionalIterator{``0},NStl.Iterators.IBidirectionalIterator{``0},NStl.IBinaryFunction{``0,``0,System.Boolean})">
            <summary>
            <para>
            PrevPermutation transforms the range of elements [first, last) into 
            the lexicographically next smaller permutation of the elements. 
            There is a finite number of distinct permutations 
            (at most N!, where N is last - first), so, if the permutations 
            are ordered by <see cref="M:NStl.Algorithm.LexicographicalCompare``1(NStl.Iterators.IInputIterator{``0},NStl.Iterators.IInputIterator{``0},NStl.Iterators.IInputIterator{``0},NStl.Iterators.IInputIterator{``0},NStl.IBinaryFunction{``0,``0,System.Boolean})"/>, 
            there is an unambiguous definition of which permutation is 
            lexicographically previous. If such a permutation exists, 
            PrevPermutation transforms [first, last) into that permutation 
            and returns true. Otherwise it transforms [first, last) into the 
            lexicographically greatest permutation [2] and returns false.
            Note that the lexicographically greatest permutation is, by definition, 
            sorted in nonascending order.
            </para>
            <para>
            The complexity is linear. At most (last - first) / 2 swaps.
            </para>
            </summary>
            <typeparam name="T"></typeparam>
            <param name="first">
            A <see cref="T:NStl.Iterators.IBidirectionalInputIterator`1"/> implemenation pointing
            to the first element of the range.
            </param>
            <param name="last">
            A <see cref="T:NStl.Iterators.IBidirectionalInputIterator`1"/> implemenation pointing
            one past the final element of the range.
            </param>
            <param name="comp">
            A functor that is used to determine if one lement is less than another.
            </param>
            <returns>
            True, if the ange was transformed, false if this is the smallest permutation.
            </returns>
        </member>
        <member name="M:NStl.Algorithm.PrevPermutation``1(NStl.Iterators.IBidirectionalIterator{``0},NStl.Iterators.IBidirectionalIterator{``0})">
            <summary>
            <para>
            PrevPermutation transforms the range of elements [first, last) into 
            the lexicographically next smaller permutation of the elements. 
            There is a finite number of distinct permutations 
            (at most N!, where N is last - first), so, if the permutations 
            are ordered by <see cref="M:NStl.Algorithm.LexicographicalCompare``1(NStl.Iterators.IInputIterator{``0},NStl.Iterators.IInputIterator{``0},NStl.Iterators.IInputIterator{``0},NStl.Iterators.IInputIterator{``0},NStl.IBinaryFunction{``0,``0,System.Boolean})"/>, 
            there is an unambiguous definition of which permutation is 
            lexicographically previous. If such a permutation exists, 
            PrevPermutation transforms [first, last) into that permutation 
            and returns true. Otherwise it transforms [first, last) into the 
            lexicographically greatest permutation [2] and returns false.
            Note that the lexicographically greatest permutation is, by definition, 
            sorted in nonascending order.
            </para>
            <para>
            The complexity is linear. At most (last - first) / 2 swaps.
            </para>
            </summary>
            <typeparam name="T"></typeparam>
            <param name="first">
            A <see cref="T:NStl.Iterators.IBidirectionalInputIterator`1"/> implemenation pointing
            to the first element of the range.
            </param>
            <param name="last">
            A <see cref="T:NStl.Iterators.IBidirectionalInputIterator`1"/> implemenation pointing
            one past the final element of the range.
            </param>
            <returns>
            True, if the ange was transformed, false if this is the smalles permutation.
            </returns>
        </member>
        <member name="M:NStl.Algorithm.SetDifference``2(NStl.Iterators.IInputIterator{``0},NStl.Iterators.IInputIterator{``0},NStl.Iterators.IInputIterator{``0},NStl.Iterators.IInputIterator{``0},``1,NStl.IBinaryFunction{``0,``0,System.Boolean})">
            <summary>
            <para>
            SetDifference constructs a sorted range that is the set difference of the sorted 
            ranges [first1, last1) and [first2, last2). The return value is the end of the 
            sorted output range.
            </para>
            <para>
            In the simplest case, SetDifference performs the "difference" operation from 
            set theory: the output range contains a copy of every element that is contained 
            in [first1, last1) and not contained in [first2, last2). The general case is 
            more complicated, because the input ranges may contain duplicate elements. The 
            generalization is that if a value appears m times in [first1, last1) and n times 
            in [first2, last2) (where m or n may be zero), then it appears max(m-n, 0) times 
            in the output range. SetDifference is stable, meaning both that elements 
            are copied from the first range rather than the second, and that the relative 
            order of elements in the output range is the same as in the first input range.
            </para>
            <para>
            The two versions of SetDifference differ in how they define whether one element 
            is less than another. The first version compares objects using <see cref="M:NStl.SyntaxHelper.Compare.Less``1"/>, and 
            the second compares objects using a function object comp.
            </para>
            <para>
            The complexity is linear.
            </para>
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="OutIt">The output parameter type.</typeparam>
            <param name="first1">
            An input iterator pointing to the first element of the first input range.
            </param>
            <param name="last1">
            An input iterator pointing one past the final element of the first input range.
            </param>
            <param name="first2">
            An input iterator pointing to the first element of the first second range.
            </param>
            <param name="last2">
            An input iterator pointing one past the final element of the first second range.
            </param>
            <param name="dest">
            An output iterator pointing to the first element of the destination range.
            </param>
            <param name="less">
            The predicate defining a strict weak ordering of the elements.
            </param>
            <returns>
            An iterator pointing one past the final element of the output range.
            </returns>
        </member>
        <member name="M:NStl.Algorithm.SetDifference``2(NStl.Iterators.IInputIterator{``0},NStl.Iterators.IInputIterator{``0},NStl.Iterators.IInputIterator{``0},NStl.Iterators.IInputIterator{``0},``1)">
            <summary>
            <para>
            SetDifference constructs a sorted range that is the set difference of the sorted 
            ranges [first1, last1) and [first2, last2). The return value is the end of the 
            sorted output range. The ordering criterion is <see cref="M:NStl.SyntaxHelper.Compare.Less``1"/>.
            </para>
            <para>
            In the simplest case, SetDifference performs the "difference" operation from 
            set theory: the output range contains a copy of every element that is contained 
            in [first1, last1) and not contained in [first2, last2). The general case is 
            more complicated, because the input ranges may contain duplicate elements. The 
            generalization is that if a value appears m times in [first1, last1) and n times 
            in [first2, last2) (where m or n may be zero), then it appears max(m-n, 0) times 
            in the output range. SetDifference is stable, meaning both that elements 
            are copied from the first range rather than the second, and that the relative 
            order of elements in the output range is the same as in the first input range.
            </para>
            <para>
            The two versions of SetDifference differ in how they define whether one element 
            is less than another. The first version compares objects using <see cref="M:NStl.SyntaxHelper.Compare.Less``1"/>, and 
            the second compares objects using a function object comp.
            </para>
            <para>
            The complexity is linear.
            </para>
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="OutIt">The output parameter type.</typeparam>
            <param name="first1">
            An input iterator pointing to the first element of the first input range.
            </param>
            <param name="last1">
            An input iterator pointing one past the final element of the first input range.
            </param>
            <param name="first2">
            An input iterator pointing to the first element of the first second range.
            </param>
            <param name="last2">
            An input iterator pointing one past the final element of the first second range.
            </param>
            <param name="dest">
            An output iterator pointing to the first element of the destination range.
            </param>
            <returns>
            An iterator pointing one past the final element of the output range.
            </returns>
        </member>
        <member name="M:NStl.Algorithm.PartialSortCopy``2(NStl.Iterators.IForwardIterator{``0},NStl.Iterators.IForwardIterator{``0},``1,``1,NStl.IBinaryFunction{``0,``0,System.Boolean})">
            <summary>
            PartialSortCopy copies the smallest N elements from the range 
            [first, last) to the range [resultFirst, resultFirst + N), 
            where N is the smaller of last - first and resultLast - resultFirst. 
            The elements in [result_first, resultDirst + N) will be in ascending order.
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="RndIt"></typeparam>
            <param name="first">
            An <see cref="T:NStl.Iterators.IForwardIterator`1"/> implementation pointing to first element
            of the input range.
            </param>
            <param name="last">
            An <see cref="T:NStl.Iterators.IForwardIterator`1"/> implementation pointing one past the final element
            of the input range.
            </param>
            <param name="resultFirst">
            An <see cref="T:NStl.Iterators.IRandomAccessIterator`1"/> implementation pointing to first element
            of the target range.
            </param>
            <param name="resultLast">
            An <see cref="T:NStl.Iterators.IRandomAccessIterator`1"/> implementation pointing one past the final element
            of the target range.
            </param>
            <param name="less">
            A functor that is used to determine if one element is less than another.
            </param>
            <returns>
            An <see cref="T:NStl.Iterators.IRandomAccessIterator`1"/> pointing to the end of the target range.
            </returns>
        </member>
        <member name="M:NStl.Algorithm.PartialSortCopy``2(NStl.Iterators.IForwardIterator{``0},NStl.Iterators.IForwardIterator{``0},``1,``1)">
            <summary>
            PartialSortCopy copies the smallest N elements from the range 
            [first, last) to the range [resultFirst, resultFirst + N), 
            where N is the smaller of last - first and resultLast - resultFirst. 
            The elements in [result_first, resultDirst + N) will be in ascending order.
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="RndIt"></typeparam>
            <param name="first">
            An <see cref="T:NStl.Iterators.IForwardIterator`1"/> implementation pointing to first element
            of the input range.
            </param>
            <param name="last">
            An <see cref="T:NStl.Iterators.IForwardIterator`1"/> implementation pointing one past the final element
            of the input range.
            </param>
            <param name="resultFirst">
            An <see cref="T:NStl.Iterators.IRandomAccessIterator`1"/> implementation pointing to first element
            of the target range.
            </param>
            <param name="resultLast">
            An <see cref="T:NStl.Iterators.IRandomAccessIterator`1"/> implementation pointing one past the final element
            of the target range.
            </param>
            <returns>
            An <see cref="T:NStl.Iterators.IRandomAccessIterator`1"/> pointing to the end of the target range.
            </returns>
        </member>
        <member name="M:NStl.Algorithm.LexicographicalCompare``1(NStl.Iterators.IInputIterator{``0},NStl.Iterators.IInputIterator{``0},NStl.Iterators.IInputIterator{``0},NStl.Iterators.IInputIterator{``0},NStl.IBinaryFunction{``0,``0,System.Boolean})">
            <summary>
            <para>
            LexicographicalCompare returns true if the range of 
            elements [first1, last1) is lexicographically less 
            than the range of elements [first2, last2), and 
            false otherwise. Lexicographical comparison means 
            "dictionary" (element-by-element) ordering. That is, 
            [first1, last1) is less than [first2, last2) if 
            first1.Value is less than *first2, and greater if first1.Value
             is greater than first2.Value. If the two first elements 
            are equivalent then LexicographicalCompare compares 
            the two second elements, and so on. As with ordinary 
            dictionary order, the first range is considered to be 
            less than the second if every element in the first range 
            is equal to the corresponding element in the second but 
            the second contains more elements.
            </para>
            <para>
            The complexity is linear. At most 2 * min(last1 - first1, last2 - first2) comparisons.
            </para>
            </summary>
            <typeparam name="T"></typeparam>
            <param name="first1">
            An <see cref="T:NStl.Iterators.IInputIterator`1"/> pointing to the first element of the first input range.
            </param>
            <param name="last1">
            An <see cref="T:NStl.Iterators.IInputIterator`1"/> pointing one past the final element of the first input range.
            </param>
            <param name="first2">
            An <see cref="T:NStl.Iterators.IInputIterator`1"/> pointing to the first element of the second input range.
            </param>
            <param name="last2">
            An <see cref="T:NStl.Iterators.IInputIterator`1"/> pointing one past the final element of the second input range.
            </param>
            <param name="less">The functor that is used to decide if one elemt is less than the other.</param>
            <returns>
            True if the first range is lexicographical less than the second range, false otherwise.
            </returns>
        </member>
        <member name="M:NStl.Algorithm.LexicographicalCompare``1(NStl.Iterators.IInputIterator{``0},NStl.Iterators.IInputIterator{``0},NStl.Iterators.IInputIterator{``0},NStl.Iterators.IInputIterator{``0})">
            <summary>
            <para>
            LexicographicalCompare returns true if the range of 
            elements [first1, last1) is lexicographically less 
            than the range of elements [first2, last2), and 
            false otherwise. Lexicographical comparison means 
            "dictionary" (element-by-element) ordering. That is, 
            [first1, last1) is less than [first2, last2) if 
            first1.Value is less than *first2, and greater if first1.Value
             is greater than first2.Value. If the two first elements 
            are equivalent then LexicographicalCompare compares 
            the two second elements, and so on. As with ordinary 
            dictionary order, the first range is considered to be 
            less than the second if every element in the first range 
            is equal to the corresponding element in the second but 
            the second contains more elements.
            </para>
            <para>
            The complexity is linear. At most 2 * min(last1 - first1, last2 - first2) comparisons.
            </para>
            </summary>
            <typeparam name="T"></typeparam>
            <param name="first1">
            An <see cref="T:NStl.Iterators.IInputIterator`1"/> pointing to the first element of the first input range.
            </param>
            <param name="last1">
            An <see cref="T:NStl.Iterators.IInputIterator`1"/> pointing one past the final element of the first input range.
            </param>
            <param name="first2">
            An <see cref="T:NStl.Iterators.IInputIterator`1"/> pointing to the first element of the second input range.
            </param>
            <param name="last2">
            An <see cref="T:NStl.Iterators.IInputIterator`1"/> pointing one past the final element of the second input range.
            </param>
            <returns>
            True if the first range is lexicographical less than the second range, false otherwise.
            </returns>
        </member>
        <member name="M:NStl.Algorithm.ForEach``2(NStl.Iterators.IInputIterator{``0},NStl.Iterators.IInputIterator{``0},NStl.IUnaryFunction{``0,``1})">
            <summary>
            <para>
            Applies the function object func to each element in the range [first, last); 
            func's return value, if any, is ignored. Applications are performed in forward order, 
            i.e. from first to last. ForEach returns the function object after it has been
            applied to each element.
            </para>
            <para>
            The complexity is linear. Exactly last - first applications of func.
            </para>
            </summary>
            <param name="first">
            An input iterator pointing to the first element of the range.</param>
            <param name="last">
            An input iterator pointing one past the final element of the range.
            </param>
            <param name="func">The functor that is applied to each element of the range.</param>
            <returns></returns>
            <remarks>
            This return value is sometimes useful, since a function object may have local state. 
            It might, for example, count the number of times that it is called, 
            or it might have a status flag to indicate whether or not a call succeeded.
            </remarks>
        </member>
        <member name="M:NStl.Algorithm.RemoveIf``2(``1,``1,NStl.IUnaryFunction{``0,System.Boolean})">
            <summary>
            <para>
            RemoveIf removes from the range [first, last) every element x such that pred.Execute(x)
            is true. That is, RemoveIf returns an iterator new_last such that the range 
            [first, new_last) contains no elements for which pred is true. The iterators 
            in the range [new_last, last) are all still dereferenceable, but the elements 
            that they point to are unspecified. RemoveIf is stable, meaning that the relative 
            order of elements that are not removed is unchanged.
            </para>
            <para>
            The complexity is linear. RemoveIf performs exactly last - first applications of pred.
            </para>
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="InputIter"></typeparam>
            <param name="first">
            An input iterator pointing to the first element of the range.
            </param>
            <param name="last">
            An input iterator pointing one past the final element of the range.
            </param>
            <param name="pred">
            The predicate that decides if an element is removed from the range.
            </param>
            <returns>
            An iterator pointing one past the final element of the range that is 
            free of the removed values.
            </returns>
            <remarks>
            The meaning of "removal" is somewhat subtle. RemoveIf does not destroy any 
            iterators, and does not change the distance between first and last. (There's 
            no way that it could do anything of the sort.) So, for example, if V is a vector,
            RemoveIf(V.Begin(), V.End(), pred) does not change V.Size: V will contain 
            just as many elements as it did before. RemoveIf returns an iterator that points 
            to the end of the resulting range after elements have been removed from it; 
            it follows that the elements after that iterator are of no interest, and may 
            be discarded. If you are removing elements from a Sequence, you may simply erase 
            them. That is, a reasonable way of removing elements from a range is:
            <c>S.Erase(Algorithm.RemoveIf(S.Begin(), S.End(), pred), S.End())</c>
            </remarks>
        </member>
        <member name="M:NStl.Algorithm.Remove``2(``1,``1,``0)">
            <summary>
            <para>
            Remove removes from the range [first, last) all elements that are equal to value.
            That is, remove returns an iterator new_last such that the range [first, new_last)
            contains no elements equal to value. The iterators in the 
            range [new_last, last) are all still dereferenceable, but the elements that 
            they point to are unspecified. Remove is stable, meaning that the relative order 
            of elements that are not equal to value is unchanged.
            </para>
            The complexity is linear. Remove performs exactly last - first comparisons for equality.
            <para>
            </para>
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="InputIter"></typeparam>
            <param name="first">
            An input iterator pointing to the first element of the range.
            </param>
            <param name="last">
            An input iterator pointing one past the final element of the range.
            </param>
            <param name="val">he value to be removed.</param>
            <returns>
            An iterator pointing one past the final element of the range that is 
            free of the removed values.
            </returns>
            <remarks>
            The meaning of "removal" is somewhat subtle. Remove does not destroy any 
            iterators, and does not change the distance between first and last. (There's 
            no way that it could do anything of the sort.) So, for example, if V is a vector,
            RemoveIf(V.Begin(), V.End(), pred) does not change V.Size: V will contain 
            just as many elements as it did before. RemoveIf returns an iterator that points 
            to the end of the resulting range after elements have been removed from it; 
            it follows that the elements after that iterator are of no interest, and may 
            be discarded. If you are removing elements from a Sequence, you may simply erase 
            them. That is, a reasonable way of removing elements from a range is:
            <c>S.erase(Algorithm.RemoveIf(S.Begin(), S.End(), pred), S.End())</c>
            </remarks>
        </member>
        <member name="M:NStl.Algorithm.TopologicalSort``3(``1,``1,``2,NStl.IUnaryFunction{``0,System.Collections.Generic.IEnumerable{``0}})">
            <summary>
            <para>
            Sorts the input range toplogically, that is that each item is placed after all its predecessing
            items in the graph. This algorithm is similar to unix's tsort.
            </para>
            </summary>
            <typeparam name="GraphNode"></typeparam>
            <typeparam name="InIt"></typeparam>
            <typeparam name="OutIt"></typeparam>
            <param name="first">
            An <see cref="T:NStl.Iterators.IInputIterator`1"/> implementation pointing to the first element
            of the input range.
            </param>
            <param name="last">
            An <see cref="T:NStl.Iterators.IInputIterator`1"/> implementation pointing one past the final element
            of the input range.
            </param>
            <param name="target">
            An <see cref="T:NStl.Iterators.IOutputIterator`1"/> implemetation that is the target for the sorted elements.
            </param>
            <param name="parents"></param>
            <returns>
            An <see cref="T:NStl.Iterators.IOutputIterator`1"/> implemetation pointing one past the final
            sorted element in the destination range.
            </returns>
        </member>
        <member name="M:NStl.Algorithm.TopologicalSort``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``0}})">
            <summary>
            <para>
            Sorts the input range toplogically, that is that each item is placed after all its predecessing
            items in the graph. This algorithm is similar to unix's tsort.
            </para>
            </summary>
            <typeparam name="GraphNode"></typeparam>
            <param name="graph"></param>
            <param name="predecessors"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.Algorithm.MinAndMaxElement``2(``1,``1,NStl.IBinaryFunction{``0,``0,System.Boolean})">
            <summary>
            <para>
            MinAndMaxElement finds the smallest and largest element in the range [first, last). 
            </para>
            <para>
            The complexity is linear. Zero comparisons if [first, last) is an 
            empty range, otherwise exactly (last - first) - 1 comparisons.
            </para>
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="FwdIt"></typeparam>
            <param name="first">
            An <see cref="T:NStl.Iterators.IForwardIterator`1"/> pointing to the first element of the range.
            </param>
            <param name="last">
            An <see cref="T:NStl.Iterators.IForwardIterator`1"/> pointing one past the last element of the range.
            </param>
            <param name="less">The function object that determines if one element is less than another.</param>
            <returns>
            An <see cref="T:System.Collections.Generic.KeyValuePair`2"/> containing iterators pointing to the
            minimum and maximum elements of the range.
            </returns>
        </member>
        <member name="M:NStl.Algorithm.MinAndMaxElement``2(``1,``1)">
            <summary>
            <para>
            MinAndMaxElement finds the smallest and largest element in the range [first, last). 
            </para>
            <para>
            The complexity is linear. Zero comparisons if [first, last) is an 
            empty range, otherwise exactly (last - first) - 1 comparisons.
            </para>
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="FwdIt"></typeparam>
            <param name="first">
            An <see cref="T:NStl.Iterators.IForwardIterator`1"/> pointing to the first element of the range.
            </param>
            <param name="last">
            An <see cref="T:NStl.Iterators.IForwardIterator`1"/> pointing one past the last element of the range.
            </param>
            <returns>
            An <see cref="T:System.Collections.Generic.KeyValuePair`2"/> containing iterators pointing to the
            minimum and maximum elements of the range.
            </returns>
        </member>
        <member name="M:NStl.Algorithm.UpperBound``2(``1,``1,``0,NStl.IBinaryFunction{``0,``0,System.Boolean})">
            <summary>
            <para>
            UpperBound is a version of binary search: it attempts to find the element value in 
            an ordered range [first, last). Specifically, it returns the last position where 
            value could be inserted without violating the ordering. The first version of UpperBound 
            uses <see cref="T:System.IComparable`1"/> for comparison, and the second uses the function object less.
            </para>
            <para>
            The number of comparisons is logarithmic: at most log(last - first) + 1. If the iterator is an 
            <see cref="T:NStl.Iterators.IRandomAccessIterator`1"/> then the number of steps through the range is also 
            logarithmic; otherwise, the number of steps is proportional to last - first.
            </para>
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="InIt"></typeparam>
            <param name="first">
            An input iterator pointing to the first element of the range.
            </param>
            <param name="last">
            An input iterator pointing one past the final element of the range.
            </param>
            <param name="val">
            The value to be searched for.
            </param>
            <param name="less">
            The order criterion of the range.
            </param>
            <returns>
            An iterator pointing to the found value or last.
            </returns>
        </member>
        <member name="M:NStl.Algorithm.UpperBound``2(``1,``1,``0)">
            <summary>
            
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="FwdIt"></typeparam>
            <param name="first"></param>
            <param name="last"></param>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.Algorithm.ReverseCopy``2(NStl.Iterators.IBidirectionalInputIterator{``0},NStl.Iterators.IBidirectionalInputIterator{``0},``1)">
            <summary>
            ReverseCopy copies elements from the range [first, last) 
            to the range [result, result + (last - first)) such that 
            the copy is a reverse of the original range. 
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="OutIt"></typeparam>
            <param name="first">
            An <see cref="T:NStl.Iterators.IBidirectionalInputIterator`1"/> implemention
            pointing to the first element of the range to be reversed.
            </param>
            <param name="last">
            An <see cref="T:NStl.Iterators.IBidirectionalInputIterator`1"/> implemention
            pointing one past the final element of the range to be reversed.
            </param>
            <param name="result">
            An <see cref="T:NStl.Iterators.IOutputIterator`1"/> implementation pointing on the first
            element of the target range.
            </param>
            <returns></returns>
        </member>
        <member name="M:NStl.Algorithm.ReplaceCopyIf``2(NStl.Iterators.IInputIterator{``0},NStl.Iterators.IInputIterator{``0},``1,NStl.IUnaryFunction{``0,System.Boolean},``0)">
            <summary>
            ReplaceCopyIf copies elements from the range [first, last) 
            to the range [result, result + (last-first)), 
            except that any element for which predicate is true is not copied; 
            newValue is copied instead. 
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="FwdIt"></typeparam>
            <param name="first">
            An <see cref="T:NStl.Iterators.IForwardIterator`1"/> implementation
            pointing to the start of the input range.
            </param>
            <param name="last">
            An <see cref="T:NStl.Iterators.IForwardIterator`1"/> implementation
            pointing to the end of the input range.
            </param>
            <param name="result">An <see cref="T:NStl.Iterators.IOutputIterator`1"/> 
            implementation pointing at the first element of the target range.
            </param>
            <param name="predicate">
            The predicate functor that is used to determine if an element is replaced during the copy.
            </param>
            <param name="newValue">The new value.</param>
            <returns>
            An <see cref="T:NStl.Iterators.IOutputIterator`1"/> implementation pointing to the end of the target range.
            </returns>
        </member>
        <member name="M:NStl.Algorithm.ReplaceCopy``2(NStl.Iterators.IInputIterator{``0},NStl.Iterators.IInputIterator{``0},``1,``0,``0)">
            <summary>
            ReplaceCopy copies elements from the range [first, last) 
            to the range [result, result + (last-first)), 
            except that any element that equals oldValue is not copied; 
            newValue is copied instead. 
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="FwdIt"></typeparam>
            <param name="first">
            An <see cref="T:NStl.Iterators.IForwardIterator`1"/> implementation
            pointing to the start of the input range.
            </param>
            <param name="last">
            An <see cref="T:NStl.Iterators.IForwardIterator`1"/> implementation
            pointing to the end of the input range.
            </param>
            <param name="result">An <see cref="T:NStl.Iterators.IOutputIterator`1"/> 
            implementation pointing at the first element of the target range.
            </param>
            <param name="oldValue">The value to be replaced.</param>
            <param name="newValue">The replaced value.</param>
            <returns>
            An <see cref="T:NStl.Iterators.IOutputIterator`1"/> implementation pointing to the end of the target range.
            </returns>
        </member>
        <member name="M:NStl.Algorithm.SearchN``2(``1,``1,System.Int32,``0,NStl.IBinaryFunction{``0,``0,System.Boolean})">
            <summary>
            <para>
            SearchN searches for a subsequence of count consecutive elements in the 
            range [first, last), all of which are equal to value. 
            </para>
            <para>
            The complexity is inear. SearchN performs at most last - first comparisons. 
            </para>
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="FwdIt"></typeparam>
            <param name="first">
            An <see cref="T:NStl.Iterators.IForwardIterator`1"/> implementation pointing 
            to the first element of the range to be searched.
            </param>
            <param name="last">
            An <see cref="T:NStl.Iterators.IForwardIterator`1"/> implementation pointing 
            one past the final element of the range to be searched.</param>
            <param name="count">The length of the sub range.</param>
            <param name="val">The value contained in the sub range.</param>
            <param name="equal">A functor that is used to determine if to values are equal.</param>
            <returns>
            It returns an iterator pointing to the beginning of that subsequence, 
            or else last if no such subsequence exists.
            </returns>
            <remarks>
            Note that count is permitted to be zero: a subsequence of zero elements 
            is well defined. If you call SearchN with count equal to zero, then 
            the search will always succeed: no matter what value is, every range contains 
            a subrange of zero consecutive elements that are equal to value. When SearchN
            is called with count equal to zero, the return value is always first. 
            </remarks>
        </member>
        <member name="M:NStl.Algorithm.SearchN``2(``1,``1,System.Int32,``0)">
            <summary>
            <para>
            SearchN searches for a subsequence of count consecutive elements in the 
            range [first, last), all of which are equal to value. 
            </para>
            <para>
            The complexity is inear. SearchN performs at most last - first comparisons. 
            </para>
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="FwdIt"></typeparam>
            <param name="first">
            An <see cref="T:NStl.Iterators.IForwardIterator`1"/> implementation pointing 
            to the first element of the range to be searched.
            </param>
            <param name="last">
            An <see cref="T:NStl.Iterators.IForwardIterator`1"/> implementation pointing 
            one past the final element of the range to be searched.</param>
            <param name="count">The length of the sub range.</param>
            <param name="val">The value contained in the sub range.</param>
            <returns>
            It returns an iterator pointing to the beginning of that subsequence, 
            or else last if no such subsequence exists.
            </returns>
            <remarks>
            Note that count is permitted to be zero: a subsequence of zero elements 
            is well defined. If you call SearchN with count equal to zero, then 
            the search will always succeed: no matter what value is, every range contains 
            a subrange of zero consecutive elements that are equal to value. When SearchN
            is called with count equal to zero, the return value is always first. 
            </remarks>
        </member>
        <member name="M:NStl.Algorithm.StablePartition``2(``1,``1,NStl.IUnaryFunction{``0,System.Boolean})">
            <summary>
            <para>
            StablePartition is much like <see cref="M:NStl.Algorithm.Partition``2(``1,``1,NStl.IUnaryFunction{``0,System.Boolean})"/>: 
            it reorders the elements in the range [first, last) based 
            on the function object pred, such that all of the elements 
            that satisfy pred appear before all of the elements that fail 
            to satisfy it. 
            </para>
            <para>
            StablePartition differs from <see cref="M:NStl.Algorithm.Partition``2(``1,``1,NStl.IUnaryFunction{``0,System.Boolean})"/> 
            in that StablePartition is guaranteed to preserve relative order.
             That is, if x and y are elements in [first, last) such that 
            pred.Execute(x) == pred.Execute(y), and if x precedes y, 
            then it will still be true after stable_partition is true that 
            x precedes y. Note that the complexity of StablePartition is 
            greater than that of <see cref="M:NStl.Algorithm.Partition``2(``1,``1,NStl.IUnaryFunction{``0,System.Boolean})"/>: the guarantee 
            that the relative order will be preserved has a significant runtime cost. 
            If this guarantee isn't important to you, you should use <see cref="M:NStl.Algorithm.Partition``2(``1,``1,NStl.IUnaryFunction{``0,System.Boolean})"/>.
            </para>
            <para>
            StablePartition is an adaptive algorithm: it attempts to allocate 
            a temporary memory buffer. The complexity is linear in N, pred is 
            applied exactly N times.
            </para>
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="FwdIt"></typeparam>
            <param name="first">
            An <see cref="T:NStl.Iterators.IForwardIterator`1"/> implementation pointing
            to the first element of the range to be patitioned.
            </param>
            <param name="last">
            An <see cref="T:NStl.Iterators.IForwardIterator`1"/> implementation pointing
            one apst the final element of the range to be patitioned.
            </param>
            <param name="pred">
            The predciate functor that is used as the partition criterion.
            </param>
            <returns>
            Returns an iterator that points to the first element that
            does not fulfill pred: The partition boundary.
            </returns>
        </member>
        <member name="M:NStl.Algorithm.Reverse``1(NStl.Iterators.IBidirectionalIterator{``0},NStl.Iterators.IBidirectionalIterator{``0})">
            <summary>
            Reverse reverses a range. The complexity is linear.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="first">
            An <see cref="T:NStl.Iterators.IBidirectionalIterator`1"/> implemention
            pointing to the first element of the range to be reversed.
            </param>
            <param name="last">
            An <see cref="T:NStl.Iterators.IBidirectionalIterator`1"/> implemention
            pointing one past the final element of the range to be reversed.
            </param>
        </member>
        <member name="M:NStl.Algorithm.CopyN``3(``1,System.Int32,``2)">
            <summary>
            <para>
            CopyN copies elements from the range [first, first + n) to the range [result, result + n).
            </para>
            <para>
            he complexity is linear. Exactly n assignments are performed.
            </para>
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="InIt"></typeparam>
            <typeparam name="OutIt"></typeparam>
            <param name="first">
            An <see cref="T:NStl.Iterators.IInputIterator`1"/> pointing to the first element of the range.
            </param>
            <param name="n">
            The number of elements beginning at first that will be copied to the
            destination range.
            </param>
            <param name="result">
            An <see cref="T:NStl.Iterators.IOutputIterator`1"/> pointing to the first element of the destination range.
            </param>
            <returns></returns>
            <remarks>
            As the type inference will fail on this algorithm, it is recommended to use 
            <see cref="M:NStl.Algorithm.Copy``2(NStl.Iterators.IInputIterator{``0},NStl.Iterators.IInputIterator{``0},``1)"/> instead.
            </remarks>
        </member>
        <member name="M:NStl.Algorithm.RandomShuffle``1(NStl.Iterators.IRandomAccessIterator{``0},NStl.Iterators.IRandomAccessIterator{``0})">
            <summary>
            Random_shuffle randomly rearranges the elements in the range [first, last):
            that is, it randomly picks one of the N! possible orderings, 
            where N is last - first.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="first">
            An input iterator pointing to the first element of the range.
            </param>
            <param name="last">
            An input iterator pointing one past the final element of the range.
            </param>
        </member>
        <member name="M:NStl.Algorithm.RandomShuffle``1(NStl.Iterators.IRandomAccessIterator{``0},NStl.Iterators.IRandomAccessIterator{``0},NStl.IUnaryFunction{System.Int32,System.Int32})">
            <summary>
            Random_shuffle randomly rearranges the elements in the range [first, last):
            that is, it randomly picks one of the N! possible orderings, 
            where N is last - first.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="first">
            An input iterator pointing to the first element of the range.
            </param>
            <param name="last">
            An input iterator pointing one past the final element of the range.
            </param>
            <param name="randomNumber">A function that generates random numbers.</param>
        </member>
        <member name="M:NStl.Algorithm.NextPermutation``1(NStl.Iterators.IBidirectionalIterator{``0},NStl.Iterators.IBidirectionalIterator{``0},NStl.IBinaryFunction{``0,``0,System.Boolean})">
            <summary>
            <para>
            NextPermutation transforms the range of elements [first, last) 
            into the lexicographically next greater permutation of the elements. 
            There is a finite number of distinct permutations 
            (at most N! [1], where N is last - first), so, if the permutations 
            are ordered by <see cref="M:NStl.Algorithm.LexicographicalCompare``1(NStl.Iterators.IInputIterator{``0},NStl.Iterators.IInputIterator{``0},NStl.Iterators.IInputIterator{``0},NStl.Iterators.IInputIterator{``0},NStl.IBinaryFunction{``0,``0,System.Boolean})"/>
            there is an unambiguous definition of which permutation is lexicographically next. 
            If such a permutation exists, next_permutation transforms [first, last) 
            into that permutation and returns true. Otherwise it transforms [first, last) 
            into the lexicographically smallest permutation [2] and returns false.
            </para>
            The postcondition is that the new permutation of elements is 
            lexicographically greater than the old (as determined by lexicographical_compare) if and only if the return value is true.
            <para>
            </para>
            <para>
            The compexity is linear. At most (last - first) / 2 swaps.</para>
            </summary>
            <typeparam name="T"></typeparam>
            <param name="first">
            An <see cref="T:NStl.Iterators.IBidirectionalInputIterator`1"/> implementation pointing
            to the first element of the range.
            </param>
            <param name="last">
            An <see cref="T:NStl.Iterators.IBidirectionalInputIterator`1"/> implementation pointing
            one past the final element of the range.
            </param>
            <param name="less">
            A functor that is used to determine if one element is less than another.
            </param>
            <returns>
            True, if the range was transformed int the lexicographically 
            next greater permutation of the elements.
            </returns>
        </member>
        <member name="M:NStl.Algorithm.NextPermutation``1(NStl.Iterators.IBidirectionalIterator{``0},NStl.Iterators.IBidirectionalIterator{``0})">
            <summary>
            <para>
            NextPermutation transforms the range of elements [first, last) 
            into the lexicographically next greater permutation of the elements. 
            There is a finite number of distinct permutations 
            (at most N! [1], where N is last - first), so, if the permutations 
            are ordered by <see cref="M:NStl.Algorithm.LexicographicalCompare``1(NStl.Iterators.IInputIterator{``0},NStl.Iterators.IInputIterator{``0},NStl.Iterators.IInputIterator{``0},NStl.Iterators.IInputIterator{``0})"/>
            there is an unambiguous definition of which permutation is lexicographically next. 
            If such a permutation exists, next_permutation transforms [first, last) 
            into that permutation and returns true. Otherwise it transforms [first, last) 
            into the lexicographically smallest permutation [2] and returns false.
            </para>
            The postcondition is that the new permutation of elements is 
            lexicographically greater than the old (as determined by lexicographical_compare) if and only if the return value is true.
            <para>
            </para>
            <para>
            The compexity is linear. At most (last - first) / 2 swaps.</para>
            </summary>
            <typeparam name="T"></typeparam>
            <param name="first">
            An <see cref="T:NStl.Iterators.IBidirectionalInputIterator`1"/> implementation pointing
            to the first element of the range.
            </param>
            <param name="last">
            An <see cref="T:NStl.Iterators.IBidirectionalInputIterator`1"/> implementation pointing
            one past the final element of the range.
            </param>
            <returns>
            True, if the range was transformed int the lexicographically 
            next greater permutation of the elements.
            </returns>
        </member>
        <member name="M:NStl.Algorithm.RandomSample``2(NStl.Iterators.IInputIterator{``0},NStl.Iterators.IInputIterator{``0},``1,``1,NStl.IUnaryFunction{System.Int32,System.Int32})">
            <summary>
            RandomSample randomly copies a sample of the elements from the range [first, last) into 
            the range [target, target + n). Each element in the input range appears at most once 
            in the output range, and samples are chosen with uniform probability. 
            Elements in the output range might appear in any order: relative order within the 
            input range is not guaranteed to be preserved.
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="RandIt"></typeparam>
            <param name="first">
            An <see cref="T:NStl.Iterators.IInputIterator`1"/> that points to the first element of the sample input range.
            </param>
            <param name="last">
            An <see cref="T:NStl.Iterators.IInputIterator`1"/> that points one past the final element of the sample input range.
            </param>
            <param name="outFirst">
            An <see cref="T:NStl.Iterators.IRandomAccessIterator`1"/> that points to the first element of target range.
            </param>
            <param name="outLast">
            An <see cref="T:NStl.Iterators.IRandomAccessIterator`1"/> that points one past the final element of target range.
            </param>
            <param name="randomNumber">
            A <see cref="T:NStl.IUnaryFunction`2"/> that generates random numbers.
            </param>
            <returns></returns>
        </member>
        <member name="M:NStl.Algorithm.RandomSample``2(NStl.Iterators.IInputIterator{``0},NStl.Iterators.IInputIterator{``0},``1,``1)">
            <summary>
            RandomSample randomly copies a sample of the elements from the range [first, last) into 
            the range [target, target + n). Each element in the input range appears at most once 
            in the output range, and samples are chosen with uniform probability. 
            Elements in the output range might appear in any order: relative order within the 
            input range is not guaranteed to be preserved.
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="RandIt"></typeparam>
            <param name="first">
            An <see cref="T:NStl.Iterators.IInputIterator`1"/> that points to the first element of the sample input range.
            </param>
            <param name="last">
            An <see cref="T:NStl.Iterators.IInputIterator`1"/> that points one past the final element of the sample input range.
            </param>
            <param name="outFirst">
            An <see cref="T:NStl.Iterators.IRandomAccessIterator`1"/> that points to the first element of target range.
            </param>
            <param name="outLast">
            An <see cref="T:NStl.Iterators.IRandomAccessIterator`1"/> that points one past the final element of target range.
            </param>
            <returns></returns>
        </member>
        <member name="M:NStl.Algorithm.PartialSort``1(NStl.Iterators.IRandomAccessIterator{``0},NStl.Iterators.IRandomAccessIterator{``0},NStl.Iterators.IRandomAccessIterator{``0},NStl.IBinaryFunction{``0,``0,System.Boolean})">
            <summary>
            <para>
            PartialSort rearranges the elements in the range [first, last) 
            so that they are partially in ascending order. Specifically, 
            it places the smallest middle - first elements, sorted in 
            ascending order, into the range [first, middle). The remaining 
            last - middle elements are placed, in an unspecified order, into 
            the range [middle, last).
            </para>
            <para>
            Note that the elements in the range [first, middle) will be the same 
            (ignoring, for the moment, equivalent elements) as if you had sorted 
            the entire range using Algorithm.Sort(first, last). The reason for 
            using PartialSort in preference to sort is simply efficiency: a 
            partial sort, in general, takes less time.
            </para>
            </summary>
            <typeparam name="T"></typeparam>
            <param name="first">
            An <see cref="T:NStl.Iterators.IRandomAccessIterator`1"/> implementation pointing 
            to the first element of the range.
            </param>
            <param name="middle">
            An <see cref="T:NStl.Iterators.IRandomAccessIterator`1"/> implementation pointing 
            to one  past the final position to be sortded.
            </param>
            <param name="last">
            An <see cref="T:NStl.Iterators.IRandomAccessIterator`1"/> implementation pointing 
            one past the final element of the total range.</param>
            <param name="comp">
            A functor that is used to determine if two elements are less to another.</param>
            <remarks>
            PartialSort(first, last, last) has the effect of sorting the entire 
            range [first, last), just like sort(first, last). They use different 
            algorithms, however: sort uses the introsort algorithm (a variant of quicksort), 
            and PartialSort uses Algorithm.HeapSort. See section 5.2.3 of Knuth 
            (D. E. Knuth, The Art of Computer Programming. Volume 3: Sorting and 
            Searching. Addison-Wesley, 1975.), and J. W. J. Williams (CACM 7, 347, 1964). 
            Both heapsort and introsort have complexity of order N log(N), but 
            introsort is usually faster by a factor of 2 to 5.
            </remarks>
        </member>
        <member name="M:NStl.Algorithm.PartialSort``1(NStl.Iterators.IRandomAccessIterator{``0},NStl.Iterators.IRandomAccessIterator{``0},NStl.Iterators.IRandomAccessIterator{``0})">
            <summary>
            <para>
            PartialSort rearranges the elements in the range [first, last) 
            so that they are partially in ascending order. Specifically, 
            it places the smallest middle - first elements, sorted in 
            ascending order, into the range [first, middle). The remaining 
            last - middle elements are placed, in an unspecified order, into 
            the range [middle, last).
            </para>
            <para>
            Note that the elements in the range [first, middle) will be the same 
            (ignoring, for the moment, equivalent elements) as if you had sorted 
            the entire range using Algorithm.Sort(first, last). The reason for 
            using PartialSort in preference to sort is simply efficiency: a 
            partial sort, in general, takes less time.
            </para>
            </summary>
            <typeparam name="T"></typeparam>
            <param name="first">
            An <see cref="T:NStl.Iterators.IRandomAccessIterator`1"/> implementation pointing 
            to the first element of the range.
            </param>
            <param name="middle">
            An <see cref="T:NStl.Iterators.IRandomAccessIterator`1"/> implementation pointing 
            to one  past the final position to be sortded.
            </param>
            <param name="last">
            An <see cref="T:NStl.Iterators.IRandomAccessIterator`1"/> implementation pointing 
            one past the final element of the total range.</param>
            <remarks>
            PartialSort(first, last, last) has the effect of sorting the entire 
            range [first, last), just like sort(first, last). They use different 
            algorithms, however: sort uses the introsort algorithm (a variant of quicksort), 
            and PartialSort uses Algorithm.HeapSort. See section 5.2.3 of Knuth 
            (D. E. Knuth, The Art of Computer Programming. Volume 3: Sorting and 
            Searching. Addison-Wesley, 1975.), and J. W. J. Williams (CACM 7, 347, 1964). 
            Both heapsort and introsort have complexity of order N log(N), but 
            introsort is usually faster by a factor of 2 to 5.
            </remarks>
        </member>
        <member name="M:NStl.Algorithm.PartialSum``2(NStl.Iterators.IInputIterator{``0},NStl.Iterators.IInputIterator{``0},``1,NStl.IBinaryFunction{``0,``0,``0})">
            <summary>
            PartialSum calculates a generalized partial sum: 
            first.Value is assigned to result.Value, 
            the sum of first.Value and (first + 1).Value is 
            assigned to (result + 1).Value, and so on.
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="FwdIt"></typeparam>
            <param name="first">
            An <see cref="T:NStl.Iterators.IInputIterator`1"/> pointing to the first element of the i.
            </param>
            <param name="last"></param>
            <param name="result"></param>
            <param name="opAdd"></param>
            <returns>
            An <see cref="T:NStl.Iterators.IOutputIterator`1"/> pointing to the new end of the target range.
            </returns>
        </member>
        <member name="M:NStl.Algorithm.MinElement``2(``1,``1,NStl.IBinaryFunction{``0,``0,System.Boolean})">
            <summary>
            <para>
            MinElement finds the smallest element in the range [first, last). 
            It returns the first iterator i in [first, last) such that no other 
            iterator in [first, last) points to a value smaller than i.Value. The 
            return value is last if and only if [first, last) is an empty range.
            </para>
            <para>
            The complexity is linear. Zero comparisons if [first, last) is an 
            empty range, otherwise exactly (last - first) - 1 comparisons.
            </para>
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="FwdIt"></typeparam>
            <param name="first">
            An <see cref="T:NStl.Iterators.IForwardIterator`1"/> pointing to the first element of the range.
            </param>
            <param name="last">
            An <see cref="T:NStl.Iterators.IForwardIterator`1"/> pointing one past the last element of the range.
            </param>
            <param name="less">The function object that determines if one element is less than another.</param>
            <returns>
            An iterator pointing to the minimum element of the range.
            </returns>
        </member>
        <member name="M:NStl.Algorithm.MinElement``2(``1,``1)">
            <summary>
            <para>
            MinElement finds the smallest element in the range [first, last). 
            It returns the first iterator i in [first, last) such that no other 
            iterator in [first, last) points to a value smaller than i.Value. The 
            return value is last if and only if [first, last) is an empty range.
            </para>
            <para>
            The two versions of MinElement differ in how they define whether 
            one element is less than another. The first version compares objects 
            using <see cref="T:System.IComparable`1"/>, and the second compares objects 
            using a function object less.
            </para>
            <para>
            The complexity is linear. Zero comparisons if [first, last) is an 
            empty range, otherwise exactly (last - first) - 1 comparisons.
            </para>
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="FwdIt"></typeparam>
            <param name="first">
            An <see cref="T:NStl.Iterators.IForwardIterator`1"/> pointing to the first element of the range.
            </param>
            <param name="last">
            An <see cref="T:NStl.Iterators.IForwardIterator`1"/> pointing one past the last element of the range.
            </param>
            <returns>
            An iterator pointing to the minimum element of the range.
            </returns>
        </member>
        <member name="M:NStl.Algorithm.AdjacentDifference``2(NStl.Iterators.IInputIterator{``0},NStl.Iterators.IInputIterator{``0},``1,NStl.IBinaryFunction{``0,``0,``0})">
            <summary>
            <para>
            AdjacentDifference calculates the differences of 
            adjacent elements in the range [first, last). 
            This is, first.Value is assigned to result.Value, and, 
            for each iterator i in the range [first + 1, last), 
            the result of the passed in binary functor with i.Value and (i - 1).Value is assigned 
            to (result + (i - first)).Value.
            </para>
            <para>
            Note that result is permitted to be the same iterator as first. This is useful for computing differences "in place".
            </para>
            <para>
            The reason it is useful to store the value of the first 
            element, as well as simply storing the differences, 
            is that this provides enough information to reconstruct 
            the input range. In particular, if addition and subtraction 
            have the usual arithmetic definitions, then 
            AdjacentDifference and <see cref="M:NStl.Algorithm.PartialSum``2(NStl.Iterators.IInputIterator{``0},NStl.Iterators.IInputIterator{``0},``1,NStl.IBinaryFunction{``0,``0,``0})"/> 
            inverses of each other.
            </para>
            <para>
            The complexity is linear.
            </para>
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="OutIt"></typeparam>
            <param name="first">
            An <see cref="T:NStl.Iterators.IInputIterator`1"/> implementation pointing 
            to the first element of the input range.
            </param>
            <param name="last">
            An <see cref="T:NStl.Iterators.IInputIterator`1"/> implementation pointing 
            to the end element of the input range.
            </param>
            <param name="result">
            An <see cref="T:NStl.Iterators.IOutputIterator`1"/> implementation pointing
            to the first element of the target range.
            </param>
            <param name="difference">
            A functor object that is used to calculate the difference of two elements.
            </param>
            <returns>
            An <see cref="T:NStl.Iterators.IOutputIterator`1"/> pointing to the new end of the target range.
            </returns>
        </member>
        <member name="M:NStl.Algorithm.AdjacentDifference``1(System.Collections.Generic.IEnumerable{``0},NStl.IBinaryFunction{``0,``0,``0})">
            <summary>
            <para>
            AdjacentDifference calculates the differences of 
            adjacent elements in the input range.
            </para>
            <para>
            The reason it is useful to store the value of the first 
            element, as well as simply storing the differences, 
            is that this provides enough information to reconstruct 
            the input range. In particular, if addition and subtraction 
            have the usual arithmetic definitions, then 
            AdjacentDifference and <see cref="M:NStl.Algorithm.PartialSum``2(NStl.Iterators.IInputIterator{``0},NStl.Iterators.IInputIterator{``0},``1,NStl.IBinaryFunction{``0,``0,``0})"/> 
            inverses of each other.
            </para>
            <para>
            The complexity is linear.
            </para>
            </summary>
            <typeparam name="T"></typeparam>
            <param name="range">The input range.</param>
            <param name="difference">
            A functor object that is used to calculate the difference of two elements.
            </param>
            <returns>
            An <see cref="T:System.Collections.Generic.IEnumerable`1"/> representing the result range.
            </returns>
        </member>
        <member name="M:NStl.Algorithm.AdjacentDifference``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``0,``0})">
            <summary>
            <para>
            AdjacentDifference calculates the differences of 
            adjacent elements in the input range.
            </para>
            <para>
            The reason it is useful to store the value of the first 
            element, as well as simply storing the differences, 
            is that this provides enough information to reconstruct 
            the input range. In particular, if addition and subtraction 
            have the usual arithmetic definitions, then 
            AdjacentDifference and <see cref="M:NStl.Algorithm.PartialSum``2(NStl.Iterators.IInputIterator{``0},NStl.Iterators.IInputIterator{``0},``1,NStl.IBinaryFunction{``0,``0,``0})"/> 
            inverses of each other.
            </para>
            <para>
            The complexity is linear.
            </para>
            </summary>
            <typeparam name="T"></typeparam>
            <param name="range">The input range.</param>
            <param name="difference">
            A functor object that is used to calculate the difference of two elements.
            </param>
            <returns>
            An <see cref="T:System.Collections.Generic.IEnumerable`1"/> representing the result range.
            </returns>
        </member>
        <member name="M:NStl.Algorithm.Unique``2(``1,``1,NStl.IBinaryFunction{``0,``0,System.Boolean})">
            <summary>
            <para>
            Every time a consecutive group of duplicate elements appears 
            in the range [first, last), the algorithm Unique removes all 
            but the first element. That is, Unique returns an iterator 
            newLast such that the range [first, newLast) contains no 
            two consecutive elements that are duplicates. The range [newLast, last) 
            contains unspecified elements. Unique is stable, meaning that the 
            relative order of elements that are not removed is unchanged.
            </para>
            <para>
            The complexity is linear.Exactly (last - first) - 1 comparisons.
            </para>
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="FwdIt"></typeparam>
            <param name="first">
            An <see cref="T:NStl.Iterators.IForwardIterator`1"/> pointing to the first element of the range.
            </param>
            <param name="last">
            An <see cref="T:NStl.Iterators.IForwardIterator`1"/> pointing one past the final element of the range.
            </param>
            <param name="equals">
            A functor that is used to determine of two values are equal.
            </param>
            <returns>
            An iterator specifying the end of the unique range.
            </returns>
        </member>
        <member name="M:NStl.Algorithm.Unique``2(``1,``1)">
            <summary>
            <para>
            Every time a consecutive group of duplicate elements appears 
            in the range [first, last), the algorithm Unique removes all 
            but the first element. That is, Unique returns an iterator 
            newLast such that the range [first, newLast) contains no 
            two consecutive elements that are duplicates. The range [newLast, last) 
            contains unspecified elements. Unique is stable, meaning that the 
            relative order of elements that are not removed is unchanged.
            </para>
            <para>
            The complexity is linear.Exactly (last - first) - 1 comparisons.
            </para>
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="FwdIt"></typeparam>
            <param name="first">
            An <see cref="T:NStl.Iterators.IForwardIterator`1"/> pointing to the first element of the range.
            </param>
            <param name="last">
            An <see cref="T:NStl.Iterators.IForwardIterator`1"/> pointing one past the final element of the range.
            </param>
            <returns>
            An iterator specifying the end of the unique range.
            </returns>
        </member>
        <member name="M:NStl.Algorithm.ReplaceIf``1(NStl.Iterators.IForwardIterator{``0},NStl.Iterators.IForwardIterator{``0},NStl.IUnaryFunction{``0,System.Boolean},``0)">
            <summary>
            ReplaceIf replaces every element in the range [first, last)
            that fulfills the predicate with newValue.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="first">
            An <see cref="T:NStl.Iterators.IForwardIterator`1"/> implementation
            pointing to the start of the range.
            </param>
            <param name="last">
            An <see cref="T:NStl.Iterators.IForwardIterator`1"/> implementation
            pointing to the end of the range.
            </param>
            <param name="pred">
            The predicate functor that is used to determine if one element is replaced.
            </param>
            <param name="newValue">
            The replacing value.
            </param>
        </member>
        <member name="M:NStl.Algorithm.Replace``1(NStl.Iterators.IForwardIterator{``0},NStl.Iterators.IForwardIterator{``0},``0,``0)">
            <summary>
            Replace replaces every element in the range [first, last)
            that equals oldValue with newValue.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="first">
            An <see cref="T:NStl.Iterators.IForwardIterator`1"/> implementation
            pointing to the start of the range.
            </param>
            <param name="last">
            An <see cref="T:NStl.Iterators.IForwardIterator`1"/> implementation
            pointing to the end of the range.
            </param>
            <param name="newValue">
            The replacing value.
            </param>
            <param name="oldValue">
            The value to be replaced.
            </param>
        </member>
        <member name="M:NStl.Algorithm.InplaceMerge``1(NStl.Iterators.IBidirectionalIterator{``0},NStl.Iterators.IBidirectionalIterator{``0},NStl.Iterators.IBidirectionalIterator{``0},NStl.IBinaryFunction{``0,``0,System.Boolean})">
            <summary>
            <para>
            InplaceMerge combines two consecutive sorted ranges [first, middle)
            and [middle, last) into a single sorted range [first, last). 
            That is, it starts with a range [first, last) that consists of two pieces 
            each of which is in ascending order, and rearranges it so that the 
            entire range is in ascending order. InplaceMerge is stable, meaning 
            both that the relative order of elements within each input range is 
            preserved, and that for equivalent elements in both input 
            ranges the element from the first range precedes the element from 
            the second.
            </para>
            <para>
            InplaceMerge is an adaptive algorithm: it attempts to allocate 
            a temporary memory buffer, and its run-time complexity depends on 
            how much memory is available. Inplace_merge performs no comparisons 
            if [first, last) is an empty range. Otherwise, worst-case 
            behavior (if no auxiliary memory is available) is O(N log(N)), 
            where N is last - first, and best case (if a large enough auxiliary 
            memory buffer is available) is at most (last - first) - 1 comparisons.
            </para>
            </summary>
            <typeparam name="T"></typeparam>
            <param name="first">
            An <see cref="T:NStl.Iterators.IBidirectionalIterator`1"/> pointing to the start of the 
            first sub range to be merged.
            </param>
            <param name="middle">
            An <see cref="T:NStl.Iterators.IBidirectionalIterator`1"/> pointing one past the final
            element of the first sub range to be merged. It is also the first element 
            of the second subrange to to be merged.
            </param>
            <param name="last">
            An <see cref="T:NStl.Iterators.IBidirectionalIterator`1"/> pointing one past the final
            element of the second sub range to be merged.
            </param>
            <param name="less">
            A functor that is used to determine if one element is less then the other.
            </param>
        </member>
        <member name="M:NStl.Algorithm.InplaceMerge``1(NStl.Iterators.IBidirectionalIterator{``0},NStl.Iterators.IBidirectionalIterator{``0},NStl.Iterators.IBidirectionalIterator{``0})">
            <summary>
            <para>
            InplaceMerge combines two consecutive sorted ranges [first, middle)
            and [middle, last) into a single sorted range [first, last). 
            That is, it starts with a range [first, last) that consists of two pieces 
            each of which is in ascending order, and rearranges it so that the 
            entire range is in ascending order. InplaceMerge is stable, meaning 
            both that the relative order of elements within each input range is 
            preserved, and that for equivalent elements in both input 
            ranges the element from the first range precedes the element from 
            the second.
            </para>
            <para>
            InplaceMerge is an adaptive algorithm: it attempts to allocate 
            a temporary memory buffer, and its run-time complexity depends on 
            how much memory is available. Inplace_merge performs no comparisons 
            if [first, last) is an empty range. Otherwise, worst-case 
            behavior (if no auxiliary memory is available) is O(N log(N)), 
            where N is last - first, and best case (if a large enough auxiliary 
            memory buffer is available) is at most (last - first) - 1 comparisons.
            </para>
            </summary>
            <typeparam name="T"></typeparam>
            <param name="first">
            An <see cref="T:NStl.Iterators.IBidirectionalIterator`1"/> pointing to the start of the 
            first sub range to be merged.
            </param>
            <param name="middle">
            An <see cref="T:NStl.Iterators.IBidirectionalIterator`1"/> pointing one past the final
            element of the first sub range to be merged. It is also the first element 
            of the second subrange to to be merged.
            </param>
            <param name="last">
            An <see cref="T:NStl.Iterators.IBidirectionalIterator`1"/> pointing one past the final
            element of the second sub range to be merged.
            </param>
        </member>
        <member name="M:NStl.Algorithm.FindIf``2(``1,``1,NStl.IUnaryFunction{``0,System.Boolean})">
            <summary>
            <para>
            Returns the first iterator i in the range [first, last) such that pred.Execute(i.Value) is true. 
            Returns last if no such iterator exists.
            </para>
            <para>
            The complexity is linear. At most last - first applications of Pred.
            </para>
            </summary>
            <param name="first">A forward iterator addressing the position 
            of the first element in the range.</param>
            <param name="last">A forward iterator addressing the position 
            behind the last element in the range.</param>
            <param name="pred">A binary predicate that specifies if two values are equal</param>
            <returns>An iterator that points to the Element or "last".</returns>
        </member>
        <member name="M:NStl.Algorithm.Find``2(``1,``1,``0)">
            <summary>
            <para>
            Returns the first iterator i in the range [first, last] such that 
            Object.Equals(i.value, value) == true. Returns last if no such iterator exists.
            </para>
            <para>
            The complexity is linear. At most last - first comparisons for equality.
            </para>
            </summary>
            <param name="first">
            An input iterator pointing to the first element of the range.
            </param>
            <param name="last">
            An input iterator pointing one past the final element of the range.
            </param>
            <param name="val">The value to be searched for</param>
            <returns>
            An forward iterator addressing the first occurrence of the 
            specified value in the range
            </returns>
        </member>
        <member name="M:NStl.Algorithm.Transform``3(NStl.Iterators.IInputIterator{``0},NStl.Iterators.IInputIterator{``0},``2,NStl.IUnaryFunction{``0,``1})">
            <summary>
            <para>
            Transform aplies the unary function object to each object in the
            input range and assigns the result to the destination range.
            </para>
            <para>
            The complexity is linear. The operation is applied exactly 
            last - first times in the case of the unary version, or last1 - first1 
            in the case of the binary version.
            </para>
            </summary>
            <typeparam name="InType">
            The type of the input range.
            </typeparam>
            <typeparam name="OutType">
            The type of thy output range.
            </typeparam>
            <typeparam name="OutIt"></typeparam>
            <param name="first">
            An input iterator pointing to the first element of the input range.
            </param>
            <param name="last">
            An input iterator pointing one past the final element of the input range.
            </param>
            <param name="result">
            An output iterator pointing to the first element of the destination range.
            </param>
            <param name="func">
            The unary function that is applied to each object.
            </param>
            <returns>
            An iterator pointing one past the final element of the output range.
            </returns>
        </member>
        <member name="M:NStl.Algorithm.Transform``4(NStl.Iterators.IInputIterator{``0},NStl.Iterators.IInputIterator{``0},NStl.Iterators.IInputIterator{``1},``3,NStl.IBinaryFunction{``0,``1,``2})">
            <summary>
            <para>
            Transform applies the binary fnction to a pair of elements from both 
            source ranges and assigns the result to the destination range.
            </para>
            <para>
            The complexity is linear. The operation is applied exactly 
            last - first times in the case of the unary version, or last1 - first1 
            in the case of the binary version.
            </para>
            </summary>
            <typeparam name="InType1">
            The type of the first input range.
            </typeparam>
            /// <typeparam name="InType2">
            The type of the second input range.
            </typeparam>
            <typeparam name="OutType">
            The type of thy output range.
            </typeparam>
            <typeparam name="OutIt"></typeparam>
            <param name="first1">
            An input iterator pointing to the first element of the first input range.
            </param>
            <param name="last1">
            An input iterator pointing one past the final element of the first input range.
            </param>
            <param name="first2">
            An input iterator pointing to the first element of the second input range.
            </param>
            <param name="result">
            An output iterator pointing to the first element of the destination range.
            </param>
            <param name="func">
            The binary function that is applied.
            </param>
            <returns>
            An iterator pointing one past the final element of the output range.
            </returns>
        </member>
        <member name="M:NStl.Algorithm.SetSymmetricDifference``2(NStl.Iterators.IInputIterator{``0},NStl.Iterators.IInputIterator{``0},NStl.Iterators.IInputIterator{``0},NStl.Iterators.IInputIterator{``0},``1,NStl.IBinaryFunction{``0,``0,System.Boolean})">
            <summary>
            <para>
            SetSymmetricDifference constructs a sorted range that is the set symmetric 
            difference of the sorted ranges [first1, last1) and [first2, last2). The return 
            value is the end of the output range.
            </para>
            <para>
            In the simplest case, SetSymmetricDifference performs a set theoretic calculation:
            it constructs the union of the two sets A - B and B - A, where A and B are 
            the two input ranges. That is, the output range contains a copy of every element 
            that is contained in [first1, last1) but not [first2, last2), and a copy of 
            every element that is contained in [first2, last2) but not [first1, last1). 
            The general case is more complicated, because the input ranges may contain duplicate 
            elements. The generalization is that if a value appears m times in [first1, 
            last1) and n times in [first2, last2) (where m or n may be zero), then it appears 
            |m-n| times in the output range. SetSymmetricDifference is stable, meaning 
            that the relative order of elements within each input range is preserved.
            </para>
            <para>
            The two versions of SetSymmetricDifference differ in how they define whether 
            one element is less than another. The first version compares objects using
            <see cref="M:NStl.SyntaxHelper.Compare.Less``1"/>, and the second compares objects using a function object comp.
            </para>
            <para>
            The complexity is linear.
            </para>
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="OutIt"></typeparam>
            <param name="first1">
            An input iterator pointing to the first element of the first input range.
            </param>
            <param name="last1">
            An input iterator pointing one past the final element of the first input range.
            </param>
            <param name="first2">
            An input iterator pointing to the first element of the first second range.
            </param>
            <param name="last2">
            An input iterator pointing one past the final element of the first second range.
            </param>
            <param name="dest">
            An output iterator pointing to the first element of the destination range.
            </param>
            <param name="less">
            The predicate defining a strict weak ordering of the elements.
            </param>
            <returns>
            An iterator pointing one past the final element of the output range.
            </returns>
        </member>
        <member name="M:NStl.Algorithm.SetSymmetricDifference``2(NStl.Iterators.IInputIterator{``0},NStl.Iterators.IInputIterator{``0},NStl.Iterators.IInputIterator{``0},NStl.Iterators.IInputIterator{``0},``1)">
            <summary>
            <para>
            SetSymmetricDifference constructs a sorted range that is the set symmetric 
            difference of the sorted ranges [first1, last1) and [first2, last2). The return 
            value is the end of the output range.
            </para>
            <para>
            In the simplest case, SetSymmetricDifference performs a set theoretic calculation:
            it constructs the union of the two sets A - B and B - A, where A and B are 
            the two input ranges. That is, the output range contains a copy of every element 
            that is contained in [first1, last1) but not [first2, last2), and a copy of 
            every element that is contained in [first2, last2) but not [first1, last1). 
            The general case is more complicated, because the input ranges may contain duplicate 
            elements. The generalization is that if a value appears m times in [first1, 
            last1) and n times in [first2, last2) (where m or n may be zero), then it appears 
            |m-n| times in the output range. SetSymmetricDifference is stable, meaning 
            that the relative order of elements within each input range is preserved.
            </para>
            <para>
            The two versions of SetSymmetricDifference differ in how they define whether 
            one element is less than another. The first version compares objects using
            <see cref="M:NStl.SyntaxHelper.Compare.Less``1"/>, and the second compares objects using a function object comp.
            </para>
            <para>
            The complexity is linear.
            </para>
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="OutIt"></typeparam>
            <param name="first1">
            An input iterator pointing to the first element of the first input range.
            </param>
            <param name="last1">
            An input iterator pointing one past the final element of the first input range.
            </param>
            <param name="first2">
            An input iterator pointing to the first element of the first second range.
            </param>
            <param name="last2">
            An input iterator pointing one past the final element of the first second range.
            </param>
            <param name="dest">
            An output iterator pointing to the first element of the destination range.
            </param>
            <returns>
            An iterator pointing one past the final element of the output range.
            </returns>
        </member>
        <member name="M:NStl.Algorithm.IsHeap``1(NStl.Iterators.IRandomAccessIterator{``0},NStl.Iterators.IRandomAccessIterator{``0},NStl.IBinaryFunction{``0,``0,System.Boolean})">
            <summary>
            IsHeap returns true if the range [first, last) is a heap, and false otherwise. 
            </summary>
            <typeparam name="T"></typeparam>
            <param name="first">
            An <see cref="T:NStl.Iterators.IRandomAccessIterator`1"/> pointing to the first element of the range.
            </param>
            <param name="last">
            An <see cref="T:NStl.Iterators.IRandomAccessIterator`1"/> pointing one past the last element of the range.
            </param>
            <param name="comp">
            A binary predicate that defines the order of the heap.
            </param>
            <returns></returns>
            <remarks>
            A heap is a particular way of ordering the elements in a range of <see cref="T:NStl.Iterators.IRandomAccessIterator`1"/>s [f, l). 
            The reason heaps are useful (especially for sorting, or as priority queues) is that they satisfy 
            two important properties. First, the value of f is the largest element in the heap. Second, 
            it is possible to add an element to a heap, 
            or to remove the first value, in logarithmic time. Internally, a heap is a tree represented as 
            a sequential range. The tree is constructed so that that each node is less than or equal to its parent node.
            </remarks>
        </member>
        <member name="M:NStl.Algorithm.IsHeap``1(NStl.Iterators.IRandomAccessIterator{``0},NStl.Iterators.IRandomAccessIterator{``0})">
            <summary>
            IsHeap returns true if the range [first, last) is a heap, and false otherwise. The heap is
            ordered using <see cref="M:NStl.SyntaxHelper.Compare.Less``1"/>.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="first">
            An <see cref="T:NStl.Iterators.IRandomAccessIterator`1"/> pointing to the first element of the range.
            </param>
            <param name="last">
            An <see cref="T:NStl.Iterators.IRandomAccessIterator`1"/> pointing one past the last element of the range.
            </param>
            <returns></returns>
            <remarks>
            A heap is a particular way of ordering the elements in a range of <see cref="T:NStl.Iterators.IRandomAccessIterator`1"/>s [f, l). 
            The reason heaps are useful (especially for sorting, or as priority queues) is that they satisfy 
            two important properties. First, the value of f is the largest element in the heap. Second, 
            it is possible to add an element to a heap, 
            or to remove the first value, in logarithmic time. Internally, a heap is a tree represented as 
            a sequential range. The tree is constructed so that that each node is less than or equal to its parent node.
            </remarks>
        </member>
        <member name="M:NStl.Algorithm.Includes``1(NStl.Iterators.IInputIterator{``0},NStl.Iterators.IInputIterator{``0},NStl.Iterators.IInputIterator{``0},NStl.Iterators.IInputIterator{``0},NStl.IBinaryFunction{``0,``0,System.Boolean})">
            <summary>
            <para>
            Includes tests whether one sorted range includes another sorted range. 
            That is, it returns true if and only if, for every element in 
            [first2, last2), an equivalent element is also present in [first1, last1).
            </para>
            <para>
            The complexity is linear. Zero comparisons if either [first1, last1) 
            or [first2, last2) is an empty range, otherwise at most 
            2 * ((last1 - first1) + (last2 - first2)) - 1 comparisons.
            </para>
            </summary>
            <typeparam name="T"></typeparam>
            <param name="first1">
            An <see cref="T:NStl.Iterators.IInputIterator`1"/> pointing to the first element of the sorted range
            that is the potential super set.
            </param>
            <param name="last1">
            An <see cref="T:NStl.Iterators.IInputIterator`1"/> pointing one past the final element of the sorted range
            that is the potential super set.
            </param>
            <param name="first2">
            An <see cref="T:NStl.Iterators.IInputIterator`1"/> pointing to the first element of the sorted range
            that is the potential sub set.
            </param>
            <param name="last2">
            An <see cref="T:NStl.Iterators.IInputIterator`1"/> pointing one past the final element of the sorted range
            that is the potential sub set.
            </param>
            <param name="less">
            The functor that is used to check if one element is less than the other.
            </param>
            <returns>
            True if the second range is a subset of the first, false otherwise.
            </returns>
        </member>
        <member name="M:NStl.Algorithm.Includes``1(NStl.Iterators.IInputIterator{``0},NStl.Iterators.IInputIterator{``0},NStl.Iterators.IInputIterator{``0},NStl.Iterators.IInputIterator{``0})">
            <summary>
            <para>
            Includes tests whether one sorted range includes another sorted range. 
            That is, it returns true if and only if, for every element in 
            [first2, last2), an equivalent element is also present in [first1, last1).
            </para>
            <para>
            The complexity is linear. Zero comparisons if either [first1, last1) 
            or [first2, last2) is an empty range, otherwise at most 
            2 * ((last1 - first1) + (last2 - first2)) - 1 comparisons.
            </para>
            </summary>
            <typeparam name="T"></typeparam>
            <param name="first1">
            An <see cref="T:NStl.Iterators.IInputIterator`1"/> pointing to the first element of the sorted range
            that is the potential super set.
            </param>
            <param name="last1">
            An <see cref="T:NStl.Iterators.IInputIterator`1"/> pointing one past the final element of the sorted range
            that is the potential super set.
            </param>
            <param name="first2">
            An <see cref="T:NStl.Iterators.IInputIterator`1"/> pointing to the first element of the sorted range
            that is the potential sub set.
            </param>
            <param name="last2">
            An <see cref="T:NStl.Iterators.IInputIterator`1"/> pointing one past the final element of the sorted range
            that is the potential sub set.
            </param>
            <returns>
            True if the second range is a subset of the first, false otherwise.
            </returns>
        </member>
        <member name="M:NStl.Algorithm.Equal``1(NStl.Iterators.IInputIterator{``0},NStl.Iterators.IInputIterator{``0},NStl.Iterators.IInputIterator{``0},NStl.IBinaryFunction{``0,``0,System.Boolean})">
            <summary>
            <para>
            Equal returns true if the two ranges [first1, last1) and [first2, first2 + (last1 - first1)) 
            are identical when compared element-by-element, and otherwise returns false.
            </para>
            <para>
            The complexity is linear.
            </para>
            </summary>
            <typeparam name="T"></typeparam>
            <param name="first1">
            An input iterator pointing to the first element of the first range.
            </param>
            <param name="last1">
            An input iterator pointing one past the final element of the first range.
            </param>
            <param name="first2">
            An input iterator pointing to the first element of the second range.
            </param>
            <param name="pred">
            The binary predicate that is used to compare two elements.
            </param>
            <returns>TRUE, if both ranges contain the same elements int the same order.</returns>
        </member>
        <member name="M:NStl.Algorithm.Equal``1(NStl.Iterators.IInputIterator{``0},NStl.Iterators.IInputIterator{``0},NStl.Iterators.IInputIterator{``0})">
            <summary>
            <para>
            Equal returns true if the two ranges [first1, last1) and [first2, first2 + (last1 - first1)) 
            are identical when compared element-by-element, and otherwise returns false.
            </para>
            <para>
            The complexity is linear.
            </para>
            </summary>
            <typeparam name="T"></typeparam>
            <param name="first1">
            An input iterator pointing to the first element of the first range.
            </param>
            <param name="last1">
            An input iterator pointing one past the final element of the first range.
            </param>
            <param name="first2">
            An input iterator pointing to the first element of the second range.
            </param>
            <returns>TRUE, if both ranges contain the same elements int the same order.</returns>
        </member>
        <member name="M:NStl.Algorithm.CopyBackward``2(NStl.Iterators.IBidirectionalInputIterator{``0},NStl.Iterators.IBidirectionalInputIterator{``0},``1)">
            <summary>
            <para>Copies the source range backwards into the destination range.</para>
            <para>The compelxity is linear. Exactly last - first assignments are performed.</para>
            <para>
            The order of assignments matters in the case where the input and output ranges overlap: 
            CopyBackward may not be used if result is in the range [first, last). That is, it may 
            not be used if the end of the output range overlaps with the input range, but it may 
            be used if the beginning of the output range overlaps with the input range; 
            <see cref="M:NStl.Algorithm.Copy``2(NStl.Iterators.IInputIterator{``0},NStl.Iterators.IInputIterator{``0},``1)"/> has opposite restrictions. 
            If the two ranges are completely nonoverlapping,  of course, then either algorithm may be used.
            </para>
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="OutIt"></typeparam>
            <param name="first"></param>
            <param name="last"></param>
            <param name="destEnd"></param>
            <returns></returns>
            <remarks>
            DestEnd is an iterator that points to the end of the output range. This is highly unusual: 
            in all other STL algorithms that denote an output range by a single iterator, that 
            iterator points to the beginning of the range.
            </remarks>
        </member>
        <member name="T:NStl.IInsertable`2">
            <summary>
            A IInsertable is a range that allows insertion at a specific iterator
            </summary>
        </member>
        <member name="M:NStl.IInsertable`2.Insert(`1,`0)">
            <summary>
            Insert the object at the given postion
            </summary>
            <param name="where"></param>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="T:NStl.Adapt">
            <summary>
            This class provides a set of methods that adapt existing
            collections without copying them.
            </summary>
        </member>
        <member name="M:NStl.Adapt.Weak``1(System.Collections.Generic.IList{``0})">
            <summary>
            Creates an adpter that allows to use a generic collectiona as its non generic counterpart.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <returns></returns>
            <remarks>
            This is a dangerous tool only suited to satisfy compatibility issues
            with older APIs.
            </remarks>
        </member>
        <member name="M:NStl.Adapt.Weak``1(System.Collections.Generic.ICollection{``0})">
            <summary>
            Creates an adapter that allows to use a generic collectiona as its non generic counterpart.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <returns></returns>
            <remarks>
            This is a dangerous tool only suited to satisfy compatibility issues
            with older APIs.
            </remarks>
        </member>
        <member name="M:NStl.Adapt.Covariant``2(System.Collections.Generic.IEnumerable{``1})">
            <summary>
            Adapts an IEnumerable of derived types to an IEnumerable of
            base types without copying the range.
            </summary>
            <typeparam name="Base"></typeparam>
            <typeparam name="Derived"></typeparam>
            <param name="src"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.Adapt.Range``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Adapts an <see cref="T:System.Collections.Generic.IEnumerable`1"/> to a NSTL compatible range.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="e"></param>
            <returns></returns>
            <remarks>
            This is an alternative to the <see cref="T:NStl.NStlUtil"/>'s Begin(..) 
            an End(..) adapter methods.
            </remarks>
        </member>
        <member name="M:NStl.Adapt.Range``1(System.Collections.Generic.LinkedList{``0})">
            <summary>
            Adapts an <see cref="T:System.Collections.Generic.LinkedList`1"/> to a NSTL compatible range.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="l"></param>
            <returns></returns>
            <remarks>
            This is an alternative to the <see cref="T:NStl.NStlUtil"/>'s Begin(..) 
            an End(..) adapter methods.
            </remarks>
        </member>
        <member name="M:NStl.Adapt.Range``1(System.Collections.Generic.IList{``0})">
            <summary>
            Adapts an <see cref="T:System.Collections.Generic.IList`1"/> to a NSTL compatible range.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="l"></param>
            <returns></returns>
            <remarks>
            This is an alternative to the <see cref="T:NStl.NStlUtil"/>'s Begin(..) 
            an End(..) adapter methods.
            </remarks>
        </member>
        <member name="M:NStl.Adapt.Generic``1(System.Collections.IList)">
            <summary>
            Adapts an <see cref="T:System.Collections.IList"/> implementation to an <see cref="T:System.Collections.Generic.IList`1"/>
            without copying it.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="src"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.Adapt.Generic``1(System.Collections.IEnumerable)">
            <summary>
            Adapts an <see cref="T:System.Collections.IEnumerable"/> implementation to an <see cref="T:System.Collections.Generic.IEnumerable`1"/>
            without copying it.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="src"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.Adapt.Generic``2(System.Collections.IDictionary)">
            <summary>
            Adapts an <see cref="T:System.Collections.IDictionary"/> implementation to an <see cref="T:System.Collections.Generic.IDictionary`2"/>
            without copying it.
            </summary>
            <typeparam name="Key"></typeparam>
            <typeparam name="Value"></typeparam>
            <param name="src"></param>
            <returns></returns>
        </member>
        <member name="T:NStl.Iterators.Support.OutputIterator`1">
            <summary>
            A simple helper class to implement output iterators, e.g. an iterator that
            simply appends each passed value to a list.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:NStl.Iterators.IOutputIterator`1">
            <summary>
            A interface for output iterators- output iterators usually serve as a target 
            for algorithms, e.g. they append the result of an algorithm to the end of a range.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:NStl.Iterators.IOutputIterator`1.PreIncrement">
            <summary>
            When implemented, it will move the iterator
            one step ahead. It will return this iterator afterwards.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Iterators.IOutputIterator`1.PostIncrement">
            <summary>
            When implemented, it will move the iterator
            one step ahead. It will return a copy of this
            iterator at the old position.
            </summary>
            <returns></returns>
        </member>
        <member name="P:NStl.Iterators.IOutputIterator`1.Value">
            <summary>
            When implemented, it sets the value
            that the iterator points to. 
            </summary>
        </member>
        <member name="M:NStl.Iterators.Support.OutputIterator`1.Clone">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="P:NStl.Iterators.Support.OutputIterator`1.Value">
            <summary>
            
            </summary>
        </member>
        <member name="T:NStl.INullaryFunction`1">
            <summary>
            Represents a nullary function, which is a method that takes no arguments.
            </summary>
            <typeparam name="Result">The type to be returned.</typeparam>
        </member>
        <member name="M:NStl.INullaryFunction`1.Execute">
            <summary>
            This method gets called by the algorithms.
            </summary>
            <returns></returns>
        </member>
        <member name="T:NStl.Collections.Vector`1">
            <summary>
            A vector is a sequence that supports random access to elements, constant time 
            insertion and removal of elements at the end, and linear time insertion and 
            removal of elements at the beginning or in the middle. The number of elements 
            in a vector may vary dynamically; memory management is automatic. Vector is 
            the simplest of the NSTL's container classes, and in many cases the most efficient.
            </summary>
            <remarks>
            The vector is very similar to <see cref="T:System.Collections.Generic.List`1"/>. It addditionally features more possibilities 
            to query and regulate the size and allocated storage of the container. If these features are not
            needed, <see cref="T:System.Collections.Generic.List`1"/> should be preferred.
            </remarks>
        </member>
        <member name="T:NStl.IBackInsertable`1">
            <summary>
            When implemented, this range can have objects added to its end. 
            You can obtain an <see cref="T:NStl.Iterators.IOutputIterator`1"/>
            via <see cref="M:NStl.NStlUtil.BackInserter``1(NStl.IBackInsertable{``0})"/>.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:NStl.IBackInsertable`1.PushBack(`0)">
            <summary>
            Appends the value at the end of the range.
            </summary>
            <param name="val"></param>
        </member>
        <member name="T:NStl.IRange`1">
            <summary>
            This interface defines a range bounded by two iterators.
            </summary>
        </member>
        <member name="M:NStl.IRange`1.Begin">
            <summary>
            A forward iterator pointing to the first element of the range
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.IRange`1.End">
            <summary>
            Returns a forward iterator pointing one past the last element of the range
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Collections.Vector`1.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            See <see cref="M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)"/> for details.
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="M:NStl.Collections.Vector`1.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Deserialization constructor.
            </summary>
            <param name="info"></param>
            <param name="ctxt"></param>
        </member>
        <member name="M:NStl.Collections.Vector`1.#ctor">
            <summary>
            ctor
            </summary>
        </member>
        <member name="M:NStl.Collections.Vector`1.#ctor(System.Int32)">
            <summary>
            ctor, initializes the vector with count "null" entries
            </summary>
            <param name="count"></param>
        </member>
        <member name="M:NStl.Collections.Vector`1.#ctor(System.Collections.IEnumerable)">
            <summary>
            ctor, copies the given list into this vector.
            </summary>
            <param name="list"></param>
        </member>
        <member name="M:NStl.Collections.Vector`1.#ctor(`0[])">
            <summary>
            ctor, copies the given parameters into this vector
            </summary>
        </member>
        <member name="M:NStl.Collections.Vector`1.#ctor(NStl.Iterators.IInputIterator{`0},NStl.Iterators.IInputIterator{`0})">
            <summary>
            Ctor. Copies the given range into this vector
            </summary>
            <param name="first"></param>
            <param name="last"></param>
        </member>
        <member name="M:NStl.Collections.Vector`1.Begin">
            <summary>
            Returns a random-access iterator to the first element in the container.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Collections.Vector`1.End">
            <summary>
            Returns a random-access iterator that points just beyond the end of the vector.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Collections.Vector`1.RBegin">
            <summary>
            Returns a reverse-random-access iterator to the last element in the container.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Collections.Vector`1.REnd">
            <summary>
            Returns a reverse-random-access iterator that points just before the begin of the vector.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Collections.Vector`1.ToArray">
            <summary>
            Copies the content of this vector to a native array.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Collections.Vector`1.Back">
            <summary>
            Returns a reference to the last element of the vector.
            </summary>
            <returns>
            Returns a reference to the last element of the vector.
            </returns>
            <remarks>
            If the vector is empty, this method will cause undefined behavior. 
            Under .NET this means an Exception ;-)
            </remarks>
        </member>
        <member name="M:NStl.Collections.Vector`1.Front">
            <summary>
            Returns a reference to the first element in a vector.
            </summary>
            <returns>Returns a reference to the first element in a vector.</returns>
            <remarks>
            If the vector is empty, this method will cause undefined behavior.
            Under .NET this means an Exception ;-)</remarks>
        </member>
        <member name="M:NStl.Collections.Vector`1.Capacity">
            <summary>
            Returns the number of elements that the vector could 
            contain without allocating more storage.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Collections.Vector`1.Resize(System.Int32,`0)">
            <summary>
            Specifies a new size for a vector.
            </summary>
            <param name="newSize">The new size of the vector</param>
            <param name="val">
            The value of new elements added to the vector if the new size is larger that 
            the original size
            </param>
            <remarks>
            If newSize is smaller that the current size, the elements that are too many 
            are erased from the vector
            </remarks>
        </member>
        <member name="M:NStl.Collections.Vector`1.Resize(System.Int32)">
            <summary>
            Specifies a new size for a vector.
            </summary>
            <param name="newSize">The new size of the vector</param>
        </member>
        <member name="M:NStl.Collections.Vector`1.Clear">
            <summary>
            Erases the elements of the vector.
            </summary>
        </member>
        <member name="M:NStl.Collections.Vector`1.Erase(NStl.Collections.Vector{`0}.Iterator,NStl.Collections.Vector{`0}.Iterator)">
            <summary>
            Removes an a range of elements in a vector from specified positions.
            </summary>
            <param name="first"></param>
            <param name="last"></param>
            <returns>
            An iterator that designates the first element remaining 
            beyond any elements removed, or a pointer to the end of 
            the Vector if no such element exists.
            </returns>
        </member>
        <member name="M:NStl.Collections.Vector`1.Erase(NStl.Collections.Vector{`0}.Iterator)">
            <summary>
            Removes an an element in a vector from a specified position.
            </summary>
            <param name="where"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.Collections.Vector`1.Insert(NStl.Collections.Vector{`0}.Iterator,`0)">
            <summary>
            Inserts an element of elements of elements into the 
            vector at a specified position.
            </summary>
            <param name="where"></param>
            <param name="val"></param>
            <returns>
            The first insert function returns an iterator that points 
            to the position where the new element was inserted into the vector.
            </returns>
        </member>
        <member name="M:NStl.Collections.Vector`1.Insert(NStl.Collections.Vector{`0}.Iterator,NStl.Iterators.IForwardIterator{`0},NStl.Iterators.IForwardIterator{`0})">
            <summary>
            Inserts a range  of elements into the vector at a specified position.
            </summary>
            <param name="where"></param>
            <param name="first"></param>
            <param name="last"></param>
        </member>
        <member name="M:NStl.Collections.Vector`1.Insert(NStl.Collections.Vector{`0}.Iterator,System.Int32,`0)">
            <summary>
            Inserts a number of elements into the vector at a specified position.
            </summary>
            <param name="where">The position in the vector where the first element is inserted</param>
            <param name="count">The number of elements being inserted into the vector</param>
            <param name="val">The value of the element being inserted into the vector</param>
        </member>
        <member name="M:NStl.Collections.Vector`1.PopBack">
            <summary>
            Deletes the element at the end of the vector.
            </summary>
            <remarks>The vector must not be empty!</remarks>
        </member>
        <member name="M:NStl.Collections.Vector`1.PushBack(`0)">
            <summary>
            Adds an element to the end of the vector.
            </summary>
            <param name="val"></param>
        </member>
        <member name="M:NStl.Collections.Vector`1.PushBackRange(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Adds a range of elements to the endo of this vector.
            </summary>
            <param name="vals"></param>
        </member>
        <member name="M:NStl.Collections.Vector`1.Reserve(System.Int32)">
            <summary>
            Reserves a minimum length of storage for a vector object, allocating space if necessary.
            </summary>
            <param name="newSize"></param>
            <remarks>If the new size is les than the current size, nothing will happen</remarks>
        </member>
        <member name="M:NStl.Collections.Vector`1.Swap(NStl.Collections.Vector{`0})">
            <summary>
            Exchanges the elements of two vectors.
            </summary>
            <param name="right"></param>
            <remarks>This is an extremely cheap operation, as it is just a buffer swap!!</remarks>
        </member>
        <member name="M:NStl.Collections.Vector`1.CreateIterator(System.Int32)">
            <summary>
            private helper, to create an iterator
            </summary>
            <param name="atIdx"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.Collections.Vector`1.CreateIterator(NStl.Collections.Vector{`0}.Iterator)">
            <summary>
            private helper, to create an iterator
            </summary>
            <param name="it"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.Collections.Vector`1.EnsureSize(System.Int32)">
            <summary>
            Enlarges or shrinks the undelying buffer
            </summary>
            <param name="requestedSize"></param>
        </member>
        <member name="P:NStl.Collections.Vector`1.Count">
            <summary>
            Returns the number of elements in the vector.
            </summary>
            <returns></returns>
        </member>
        <member name="P:NStl.Collections.Vector`1.Item(System.Int32)">
            <summary>
            Returns a reference to the vector element at a specified position. 
            Fast uchecked access.
            </summary>
        </member>
        <member name="P:NStl.Collections.Vector`1.Empty">
            <summary>
            Tests if the vector is empty.
            </summary>
            <returns></returns>
        </member>
        <member name="T:NStl.Collections.Vector`1.Iterator">
            <summary>
            The iterator of the vector container.
            </summary>
        </member>
        <member name="T:NStl.Iterators.Support.ListIteratorBase`2">
            <summary>
            Base class for all iterators that work for containser hat implement <see cref="T:System.Collections.Generic.IList`1"/>.
            </summary>
            <typeparam name="Container"></typeparam>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:NStl.Iterators.Support.RandomAccessIterator`1">
            <summary>
            A random acess iterator extents the bidirectional iterator with
            the possibility to do a constant time jump forward or backwards.
            </summary>
        </member>
        <member name="T:NStl.Iterators.Support.BidirectionalIterator`1">
            <summary>
            A bidirectional iterator extents the forward iterator 
            with the possibility to run backwards over the range.
            </summary>
        </member>
        <member name="T:NStl.Iterators.Support.ForwardIterator`1">
            <summary>
            A forward iterator is expected to provide read/write access to the underlying
            values and it also provides the user with the possibility to move forward over 
            the range.
            </summary>
        </member>
        <member name="T:NStl.Iterators.IForwardIterator`1">
            <summary>
            A forward iterator is expected to provide read/write access to the underlying
            values and it also provides the user with the possibility to move forward over 
            the range.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:NStl.Iterators.IForwardIterator`1.PreIncrement">
            <summary>
            When implemented, it will move the iterator
            one step ahead. It will return this iterator afterwards.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Iterators.IForwardIterator`1.PostIncrement">
            <summary>
            When implemented, it will move the iterator
            one step ahead. It will return a copy of this
            iterator at the old position.
            </summary>
            <returns></returns>
        </member>
        <member name="P:NStl.Iterators.IForwardIterator`1.Value">
            <summary>
            When implemented, it sets the value
            that the iterator points to. 
            </summary>
        </member>
        <member name="M:NStl.Iterators.Support.ForwardIterator`1.PreIncrement">
            <summary>
            Moves this iterator one ahead.
            </summary>
            <returns>This iterator.</returns>
        </member>
        <member name="M:NStl.Iterators.Support.ForwardIterator`1.PostIncrement">
            <summary>
            Moves this iterator one ahead.
            </summary>
            <returns>A copy of this iterator at the old position.</returns>
        </member>
        <member name="M:NStl.Iterators.Support.ForwardIterator`1.op_Increment(NStl.Iterators.Support.ForwardIterator{`0})">
            <summary>
            
            </summary>
            <param name="it"></param>
            <returns></returns>
        </member>
        <member name="P:NStl.Iterators.Support.ForwardIterator`1.Value">
            <summary>
            The value that this iterator points to.
            </summary>
        </member>
        <member name="T:NStl.Iterators.IBidirectionalIterator`1">
            <summary>
            A bidirectional iterator extents the IForwardIterator interface
            with the possibility to run backwards over the range.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:NStl.Iterators.IBidirectionalIterator`1.PreDecrement">
             <summary>
            Moves this iterator one step back.
             </summary>
             <returns>Returns this iterator.</returns>
        </member>
        <member name="M:NStl.Iterators.IBidirectionalIterator`1.PostDecrement">
            <summary>
            oves this iterator one step back.
            </summary>
            <returns>returns a copy of this iterator poining to the previous position.</returns>
        </member>
        <member name="M:NStl.Iterators.Support.BidirectionalIterator`1.PreDecrement">
             <summary>
            Moves this iterator one step back.
             </summary>
             <returns>Returns this iterator.</returns>
        </member>
        <member name="M:NStl.Iterators.Support.BidirectionalIterator`1.PostDecrement">
            <summary>
            oves this iterator one step back.
            </summary>
            <returns>returns a copy of this iterator poining to the previous position.</returns>
        </member>
        <member name="T:NStl.Iterators.IRandomAccessIterator`1">
            <summary>
            A random acess iterator extents the bidirectional iterator with
            the possibility to do a constant time jump forward or backwards.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:NStl.Iterators.IRandomAccessIterator`1.Add(System.Int32)">
            <summary>
            When implemented, it returns a copy of this iterator moved
            count ahead/back. 
            </summary>
            <param name="count">How far the copied iterator will jump</param>
            <returns></returns>
            <remarks>This iterator stays where it is. The action performs in constant time</remarks>
        </member>
        <member name="M:NStl.Iterators.IRandomAccessIterator`1.Diff(NStl.Iterators.IRandomAccessIterator{`0})">
            <summary>
            Computes the distance between two iterators.
            <code>
            IRandomAccessIterator{T} first = list.Begin();
            IRandomAccessIterator{T} last = list.End();
            int dist = last.Diff(first);
            </code>
            </summary>
            <param name="rhs"></param>
            <returns>The distance between two iterators</returns>
        </member>
        <member name="M:NStl.Iterators.IRandomAccessIterator`1.Less(NStl.Iterators.IRandomAccessIterator{`0})">
            <summary>
            Checks if this iterator is before the other
            </summary>
            <param name="rhs"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.Iterators.Support.RandomAccessIterator`1.Add(System.Int32)">
            <summary>
            When implemented, it returns a copy of this iterator moved
            count ahead/back. 
            </summary>
            <param name="count">How far the copied iterator will jump</param>
            <returns></returns>
            <remarks>This iterator stays where it is. The action performs in constant time</remarks>
        </member>
        <member name="M:NStl.Iterators.Support.RandomAccessIterator`1.op_Addition(NStl.Iterators.Support.RandomAccessIterator{`0},System.Int32)">
            <summary>
            
            </summary>
            <param name="it"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.Iterators.Support.RandomAccessIterator`1.op_Subtraction(NStl.Iterators.Support.RandomAccessIterator{`0},System.Int32)">
            <summary>
            
            </summary>
            <param name="it"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.Iterators.Support.RandomAccessIterator`1.Diff(NStl.Iterators.IRandomAccessIterator{`0})">
            <summary>
            Computes the distance between two iterators
            </summary>
            <param name="rhs"></param>
            <returns>The distance between two iterators</returns>
        </member>
        <member name="M:NStl.Iterators.Support.RandomAccessIterator`1.op_Subtraction(NStl.Iterators.Support.RandomAccessIterator{`0},NStl.Iterators.Support.RandomAccessIterator{`0})">
            <summary>
            
            </summary>
            <param name="lhs"></param>
            <param name="rhs"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.Iterators.Support.RandomAccessIterator`1.Less(NStl.Iterators.IRandomAccessIterator{`0})">
            <summary>
            Checks if this iterator is before the other
            </summary>
            <param name="rhs"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.Iterators.Support.RandomAccessIterator`1.op_LessThan(NStl.Iterators.Support.RandomAccessIterator{`0},NStl.Iterators.Support.RandomAccessIterator{`0})">
            <summary>
            
            </summary>
            <param name="lhs"></param>
            <param name="rhs"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.Iterators.Support.RandomAccessIterator`1.op_GreaterThan(NStl.Iterators.Support.RandomAccessIterator{`0},NStl.Iterators.Support.RandomAccessIterator{`0})">
            <summary>
            
            </summary>
            <param name="lhs"></param>
            <param name="rhs"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.Iterators.Support.RandomAccessIterator`1.op_LessThanOrEqual(NStl.Iterators.Support.RandomAccessIterator{`0},NStl.Iterators.Support.RandomAccessIterator{`0})">
            <summary>
            
            </summary>
            <param name="lhs"></param>
            <param name="rhs"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.Iterators.Support.RandomAccessIterator`1.op_GreaterThanOrEqual(NStl.Iterators.Support.RandomAccessIterator{`0},NStl.Iterators.Support.RandomAccessIterator{`0})">
            <summary>
            
            </summary>
            <param name="lhs"></param>
            <param name="rhs"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.Iterators.Support.RandomAccessIterator`1.Compare(NStl.Iterators.Support.RandomAccessIterator{`0},NStl.Iterators.Support.RandomAccessIterator{`0})">
            <summary>
            Overload for languages without operator overloading.
            </summary>
            <param name="lhs"></param>
            <param name="rhs"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.Iterators.Support.RandomAccessIterator`1.op_Increment(NStl.Iterators.Support.RandomAccessIterator{`0})">
            <summary>
            
            </summary>
            <param name="it"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.Iterators.Support.RandomAccessIterator`1.op_Decrement(NStl.Iterators.Support.RandomAccessIterator{`0})">
            <summary>
            
            </summary>
            <param name="it"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.Iterators.Support.ListIteratorBase`2.#ctor(`0,System.Int32)">
            <summary>
            
            </summary>
            <param name="list"></param>
            <param name="idx"></param>
        </member>
        <member name="M:NStl.Iterators.Support.ListIteratorBase`2.Equals(NStl.Iterators.Support.EquatableIterator{`1})">
            <summary>
            
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.Iterators.Support.ListIteratorBase`2.HashCode">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Iterators.Support.ListIteratorBase`2.PreDecrement">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Iterators.Support.ListIteratorBase`2.PreIncrement">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Iterators.Support.ListIteratorBase`2.Diff(NStl.Iterators.IRandomAccessIterator{`1})">
            <summary>
            
            </summary>
            <param name="rhs"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.Iterators.Support.ListIteratorBase`2.Less(NStl.Iterators.IRandomAccessIterator{`1})">
            <summary>
            
            </summary>
            <param name="rhs"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.Iterators.Support.ListIteratorBase`2.Add(System.Int32)">
            <summary>
            
            </summary>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="P:NStl.Iterators.Support.ListIteratorBase`2.Value">
            <summary>
            
            </summary>
        </member>
        <member name="M:NStl.Collections.Vector`1.Iterator.Clone">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Collections.Vector`1.Iterator.op_Subtraction(NStl.Collections.Vector{`0}.Iterator,System.Int32)">
            <summary>
            
            </summary>
            <param name="it"></param>
            <param name="rhs"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.Collections.Vector`1.Iterator.op_Addition(NStl.Collections.Vector{`0}.Iterator,System.Int32)">
            <summary>
            
            </summary>
            <param name="lhs"></param>
            <param name="rhs"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.Collections.Vector`1.Iterator.op_Increment(NStl.Collections.Vector{`0}.Iterator)">
            <summary>
            
            </summary>
            <param name="it"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.Collections.Vector`1.Iterator.op_Decrement(NStl.Collections.Vector{`0}.Iterator)">
            <summary>
            
            </summary>
            <param name="it"></param>
            <returns></returns>
        </member>
        <member name="T:NStl.Collections.MultiSet`1">
            <summary>
            multiset is a Sorted Associative Container that stores objects of type T. 
            multiset is a Simple Associative Container, meaning that its value type, as 
            well as its object type, is object. It is also a Multiple Associative Container, 
            meaning that two or more elements may be identical. UniqueSet and multiset are 
            particularly well suited to the set algorithms includes, Algorithm.SetUnion(..), 
            Algorithm.SetIntersection(..), Algorithm.SetDifference(..), 
            and Algorithm.SetSymmetricDifference(..). The reason for 
            this is twofold. First, the set algorithms require their arguments to be sorted 
            ranges, and, since UniqueSet and MultiSet are Sorted Associative Containers, their 
            elements are always sorted in ascending order. Second, the output range of 
            these algorithms is always sorted, and inserting a sorted range into a UniqueSet or MultiSet
            is a fast operation: the Unique Sorted Associative Container and 
            Multiple Sorted Associative Container requirements guarantee that inserting 
            a range takes only linear time if the range is already sorted. MultiSet has 
            the important property that inserting a new element into a MultiSet does not 
            invalidate iterators that point to existing elements. Erasing an element from 
            a multiset also does not invalidate any iterators, except, of course, for 
            iterators that actually point to the element that is being erased. 
            </summary>
        </member>
        <member name="T:NStl.Collections.ISortedRange`1">
            <summary>
            When implemented, it represents a sorted range.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:NStl.Collections.MultiSet`1.#ctor(NStl.IBinaryFunction{`0,`0,System.Boolean})">
            <summary>
            Constructs an empty set using the provided comparer functor
            </summary>
            <param name="comparison"></param>
        </member>
        <member name="M:NStl.Collections.MultiSet`1.#ctor(NStl.Collections.Private.RbTree{`0,`0})">
            <summary>
            Constructs a multiset with an external tree implementation
            </summary>
            <param name="tree"></param>
        </member>
        <member name="M:NStl.Collections.MultiSet`1.#ctor(NStl.IBinaryFunction{`0,`0,System.Boolean},NStl.Iterators.IInputIterator{`0},NStl.Iterators.IInputIterator{`0})">
            <summary>
            ctor, copies the passed in range into this set
            </summary>
            <param name="comparison">Comparison functor</param>
            <param name="first">The position of the first element to be copied to the set</param>
            <param name="last">The position just beyond the last element to be copied to the set</param>
        </member>
        <member name="M:NStl.Collections.MultiSet`1.#ctor(NStl.IBinaryFunction{`0,`0,System.Boolean},System.Collections.IEnumerable)">
            <summary>
            ctor, copies the passed in range into this set
            </summary>
            <param name="comparison">Comparison functor</param>
            <param name="list">The IList to be copied into this set</param>
        </member>
        <member name="M:NStl.Collections.MultiSet`1.#ctor(NStl.IBinaryFunction{`0,`0,System.Boolean},System.Collections.Generic.IEnumerable{`0})">
            <summary>
            ctor, copies the passed in range into this set
            </summary>
            <param name="comparison">Comparison functor</param>
            <param name="list">The IList to be copied into this set</param>
        </member>
        <member name="M:NStl.Collections.MultiSet`1.#ctor(NStl.IBinaryFunction{`0,`0,System.Boolean},`0[])">
            <summary>
            ctor, copies the passed in range into this set
            </summary>
            <param name="comparison"></param>
            <param name="list"></param>
        </member>
        <member name="M:NStl.Collections.MultiSet`1.Begin">
            <summary>
            Returns an iterator that addresses the first element in the set.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Collections.MultiSet`1.End">
            <summary>
            Returns an iterator pointing one past the last element of the set
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Collections.MultiSet`1.RBegin">
            <summary>
            Returns an iterator addressing the first element in a reversed set
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Collections.MultiSet`1.REnd">
            <summary>
            Returns an iterator pointing one past the last element of the reversed set
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Collections.MultiSet`1.Insert(`0)">
            <summary>
            Inserts an element into the multiset
            </summary>
            <param name="val">The object to be inserted</param>
            <returns>An iterator that points to the position where the new element was inserted</returns>
        </member>
        <member name="M:NStl.Collections.MultiSet`1.Insert(NStl.Collections.MultiSet{`0}.Iterator,`0)">
            <summary>
            Inserts an element into the multiset
            </summary>
            <param name="where">
            The place to start searching for the correct point of insertion. 
            (Insertion can occur in constant time, instead of logarithmic 
            time, if the insertion point immediately follows where.) 
            </param>
            <param name="val">
            The value of an element to be inserted into the set 
            </param>
            <returns>
            An iterator that points to the position where the new element was inserted
            </returns>
        </member>
        <member name="M:NStl.Collections.MultiSet`1.Insert(NStl.Iterators.IInputIterator{`0},NStl.Iterators.IInputIterator{`0})">
            <summary>
            Insert a range of elements into the uniqueset
            </summary>
            <param name="first">The position of the first element to be copied to the set</param>
            <param name="last">The position just beyond the last element to be copied to the set</param>
        </member>
        <member name="M:NStl.Collections.MultiSet`1.Clear">
            <summary>
            Erases all elements
            </summary>
        </member>
        <member name="M:NStl.Collections.MultiSet`1.CountOf(`0)">
            <summary>
            Returns the number of elements in the set using the internal comparison functor
            </summary>
            <param name="val">The object to be counted</param>
            <returns></returns>
        </member>
        <member name="M:NStl.Collections.MultiSet`1.EqualRange(`0)">
            <summary>
            Finds a range containing all elements whose key is key
            </summary>
            <param name="key">
            The argument key to be compared with the sort key of an element from the 
            set being searched
            </param>
            <returns>
            A pair of iterators where the first is the lower_bound of the key and 
            the second is the upper_bound of the key
            </returns>
        </member>
        <member name="M:NStl.Collections.MultiSet`1.Erase(NStl.Collections.MultiSet{`0}.Iterator)">
            <summary>
            Removes the element at the specified position
            </summary>
            <param name="where">Position of the element to be removed from the set</param>
        </member>
        <member name="M:NStl.Collections.MultiSet`1.Erase(NStl.Collections.MultiSet{`0}.Iterator,NStl.Collections.MultiSet{`0}.Iterator)">
            <summary>
            Removes a range of elements from the set
            </summary>
            <param name="first">Position of the first element removed from the set</param>
            <param name="last">Position just beyond the last element removed from the set</param>
            <remarks>
            The C++ STL set returns an valid iterator, however the SGI set does not. As I never quite
            saw the usefullness of the returned iterators, I stuck to the SGI implementation.
            If there is a strong wish from a lot of users, I will put the return value back in again.
            </remarks>
        </member>
        <member name="M:NStl.Collections.MultiSet`1.Erase(`0)">
            <summary>
            Erases a specific value from the set
            </summary>
            <param name="val">The key of the elements to be removed from the s</param>
            <returns>the count of the erased elements. This is either 1 or 0</returns>
        </member>
        <member name="M:NStl.Collections.MultiSet`1.Find(`0)">
            <summary>
            Finds the location of a specific element
            </summary>
            <param name="val">The element to be found using the internal comparison functor</param>
            <returns></returns>
        </member>
        <member name="M:NStl.Collections.MultiSet`1.LowerBound(`0)">
            <summary>
            Returns an iterator to the first element in a set with a key that is equal 
            to or less than a specified key
            </summary>
            <param name="val">The value to be found</param>
            <returns></returns>
            <remarks>Comparison is one by the internal comparison Predicate</remarks>
        </member>
        <member name="M:NStl.Collections.MultiSet`1.UpperBound(`0)">
            <summary>
            Returns an iterator one past the first element in a set with a key that is 
            equal to or greater than a specified key
            </summary>
            <param name="val">The value to be found</param>
            <returns></returns>
        </member>
        <member name="M:NStl.Collections.MultiSet`1.Swap(NStl.Collections.MultiSet{`0})">
            <summary>
            Swaps the content of this set with the other set
            </summary>
            <param name="rhs"></param>
            <remarks>Extreme fast operation, as this is a buffer swap</remarks>
        </member>
        <member name="M:NStl.Collections.MultiSet`1.ToArray">
            <summary>
            Copies the content of the container to an array.
            </summary>
        </member>
        <member name="M:NStl.Collections.MultiSet`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copies the content of the container to an array.
            </summary>
            <param name="array"></param>
            <param name="arrayIndex"></param>
        </member>
        <member name="M:NStl.Collections.MultiSet`1.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Deserialization contructor.
            </summary>
            <param name="info"></param>
            <param name="ctxt"></param>
        </member>
        <member name="M:NStl.Collections.MultiSet`1.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            See <see cref="M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)"/> for details.
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="P:NStl.Collections.MultiSet`1.Empty">
            <summary>
            Checks if the set is empty
            </summary>
            <returns></returns>
        </member>
        <member name="P:NStl.Collections.MultiSet`1.Count">
            <summary>
            Returns the number of elements in the set
            </summary>
            <returns></returns>
        </member>
        <member name="T:NStl.Collections.MultiSet`1.Iterator">
            <summary>
            
            </summary>
        </member>
        <member name="T:NStl.Iterators.Support.BidirectionalIterator2InputBidirectionalIteratorAdapter`1">
            <summary>
             Adapts a <see cref="T:NStl.Iterators.IBidirectionalIterator`1"/> to a <see cref="T:NStl.Iterators.IBidirectionalInputIterator`1"/>.
            </summary>
        </member>
        <member name="M:NStl.Iterators.Support.BidirectionalIterator2InputBidirectionalIteratorAdapter`1.#ctor(NStl.Iterators.IBidirectionalIterator{`0})">
            <summary>
            Ctor.
            </summary>
            <param name="inner"></param>
        </member>
        <member name="M:NStl.Iterators.Support.BidirectionalIterator2InputBidirectionalIteratorAdapter`1.PreDecrement">
            <summary>
            See <see cref="M:NStl.Iterators.IBidirectionalInputIterator`1.PreDecrement"/> for details.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Iterators.Support.BidirectionalIterator2InputBidirectionalIteratorAdapter`1.PreIncrement">
            <summary>
            See <see cref="M:NStl.Iterators.IInputIterator`1.PreIncrement"/> for details.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Iterators.Support.BidirectionalIterator2InputBidirectionalIteratorAdapter`1.Clone">
            <summary>
            See <see cref="M:NStl.Iterators.IIterator`1.Clone"/> for details.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Iterators.Support.BidirectionalIterator2InputBidirectionalIteratorAdapter`1.Equals(NStl.Iterators.Support.EquatableIterator{`0})">
            <summary>
            
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.Iterators.Support.BidirectionalIterator2InputBidirectionalIteratorAdapter`1.HashCode">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="P:NStl.Iterators.Support.BidirectionalIterator2InputBidirectionalIteratorAdapter`1.Value">
            <summary>
            See <see cref="P:NStl.Iterators.IInputIterator`1.Value"/> for details.
            </summary>
        </member>
        <member name="P:NStl.Iterators.Support.BidirectionalIterator2InputBidirectionalIteratorAdapter`1.Inner">
            <summary>
            The adapted iterator.
            </summary>
        </member>
        <member name="M:NStl.Collections.MultiSet`1.Iterator.op_Increment(NStl.Collections.MultiSet{`0}.Iterator)">
            <summary>
            
            </summary>
            <param name="it"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.Collections.MultiSet`1.Iterator.op_Decrement(NStl.Collections.MultiSet{`0}.Iterator)">
            <summary>
            
            </summary>
            <param name="it"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.Collections.MultiSet`1.Iterator.Clone">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="T:NStl.Collections.Map`2">
            <summary>
            Map is a Sorted Associative Container that associates objects of type Key with 
            objects of type Value. map is a Pair Associative Container, meaning that its 
            value type is pair[Key, Value]. It is also a Unique Associative Container, 
            meaning that no two elements have the same key. map has the important property 
            that inserting a new element into a map does not invalidate iterators that 
            point to existing elements. Erasing an element from a map also does not 
            invalidate any iterators, except, of course, for iterators that actually point 
            to the element that is being erased. 
            </summary>
            <remarks>
            Map is avery similar to <see cref="T:System.Collections.Generic.SortedDictionary`2"/> and <see cref="T:System.Collections.Generic.SortedList`2"/>.
            It is closer to SortedDictionary in performance and offers <see cref="T:NStl.Iterators.IBidirectionalIterator`1"/>
            implementations. If this is not of importance, the .NET collections sould be prefered.
            </remarks>
        </member>
        <member name="M:NStl.Collections.Map`2.#ctor(NStl.IBinaryFunction{`0,`0,System.Boolean})">
            <summary>
            Constructs an empty map using the provided comparer functor
            </summary>
            <param name="comparison"></param>
        </member>
        <member name="M:NStl.Collections.Map`2.#ctor(NStl.Collections.Private.RbTree{`0,System.Collections.Generic.KeyValuePair{`0,`1}})">
            <summary>
            Constructs a map with an external tree implementation
            </summary>
            <param name="tree"></param>
        </member>
        <member name="M:NStl.Collections.Map`2.#ctor(NStl.IBinaryFunction{`0,`0,System.Boolean},NStl.Iterators.IInputIterator{System.Collections.Generic.KeyValuePair{`0,`1}},NStl.Iterators.IInputIterator{System.Collections.Generic.KeyValuePair{`0,`1}})">
            <summary>
            ctor, copies the passed in range into this map
            </summary>
            <param name="comparison">Comparison functor</param>
            <param name="first">The position of the first element to be copied to the map</param>
            <param name="last">The position just beyond the last element to be copied to the map</param>
        </member>
        <member name="M:NStl.Collections.Map`2.#ctor(NStl.IBinaryFunction{`0,`0,System.Boolean},System.Collections.IEnumerable)">
            <summary>
            ctor, copies the passed in range into this map.
            </summary>
            <param name="comparison">Comparison functor</param>
            <param name="list">The IEnumerable to be copied into this map</param>
        </member>
        <member name="M:NStl.Collections.Map`2.#ctor(NStl.IBinaryFunction{`0,`0,System.Boolean},System.Collections.Generic.KeyValuePair{`0,`1}[])">
            <summary>
            ctor, copies the passed in range into this map.
            </summary>
            <param name="comparison">Comparison functor</param>
            <param name="list">The IEnumerable to be copied into this map</param>
        </member>
        <member name="M:NStl.Collections.Map`2.#ctor(NStl.IBinaryFunction{`0,`0,System.Boolean},System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}})">
            <summary>
            ctor, copies the passed in range into this map.
            </summary>
            <param name="comparison">Comparison functor</param>
            <param name="list">The IEnumerable to be copied into this map</param>
        </member>
        <member name="M:NStl.Collections.Map`2.Begin">
            <summary>
            Returns an iterator that addresses the first element in the map.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Collections.Map`2.End">
            <summary>
            Returns an iterator that addresses the location succeeding the last element in the map
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Collections.Map`2.RBegin">
            <summary>
            Returns an iterator addressing the first element in a reversed map
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Collections.Map`2.REnd">
            <summary>
            Returns an iterator that points to the position past the last element in a reversed map
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Collections.Map`2.Insert(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Insert an element into the map. 
            </summary>
            <param name="val">
            The [key, value] pair to be inserted into the map
            </param>
            <returns>A pair of [iterator, bool]. The bool value will be true, if the
            map didn't contain the inserted key and the iterator will point to the inserted pair. 
            Otherwise it will be false and the iterator will point to the end of the map</returns>
        </member>
        <member name="M:NStl.Collections.Map`2.Insert(`0,`1)">
            <summary>
            
            </summary>
            <param name="key"></param>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.Collections.Map`2.Insert(NStl.Collections.Map{`0,`1}.Iterator,System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Insert an element into the map
            </summary>
            <param name="where">
            The place to start searching for the correct point of insertion. 
            (Insertion can occur in amortized constant time, instead of logarithmic 
            time, if the insertion point immediately follows where.) 
            </param>
            <param name="val">
            The value of an element to be inserted into the map unless the map 
            already contains that element 
            </param>
            <returns>
            An iterator that points to the position where the new element was inserted or
            the end iterator in the case of a failure
            </returns>
        </member>
        <member name="M:NStl.Collections.Map`2.Insert(NStl.Iterators.IInputIterator{System.Collections.Generic.KeyValuePair{`0,`1}},NStl.Iterators.IInputIterator{System.Collections.Generic.KeyValuePair{`0,`1}})">
            <summary>
            Insert a range of elements into the map
            </summary>
            <param name="first">The position of the first element to be copied to the map</param>
            <param name="last">The position just beyond the last element to be copied to the map</param>
        </member>
        <member name="M:NStl.Collections.Map`2.Clear">
            <summary>
            CLears tha maps content
            </summary>
        </member>
        <member name="M:NStl.Collections.Map`2.CountOf(`0)">
            <summary>
            Returns the number of elements in a map whose key matches the parameter
            </summary>
            <param name="key">The key value of the elements to be matched from the map</param>
            <returns>1 if the map contains the key, 0 otherwise</returns>
        </member>
        <member name="M:NStl.Collections.Map`2.EqualRange(`0)">
            <summary>
            Returns two iterators that specify a sub range in the set where the values
            match the given key
            </summary>
            <param name="key">The argument key to be searched</param>
            <returns>A pair of iterators where the first is the lower_bound of the key and 
            the second is the upper_bound of the key</returns>
        </member>
        <member name="M:NStl.Collections.Map`2.Erase(NStl.Collections.Map{`0,`1}.Iterator)">
            <summary>
            Removes the element at the specified position
            </summary>
            <param name="where">Position of the element to be removed from the map</param>
            <remarks>
            The C++ STL set returns an valid iterator, however the SGI set does not. As I never quite
            saw the usefullness of the returned iterators, I stuck to the SGI implementation.
            If there is a strong wish from a lot of users, I will put the return value back in again.
            </remarks>
        </member>
        <member name="M:NStl.Collections.Map`2.Erase(NStl.Collections.Map{`0,`1}.Iterator,NStl.Collections.Map{`0,`1}.Iterator)">
            <summary>
            Erases a range of elements from the map
            </summary>
            <param name="first">Position of the first element removed from the map</param>
            <param name="last">Position just beyond the last element removed from the map</param>
            <remarks>
            The C++ STL set returns an valid iterator, however the SGI set does not. As I never quite
            saw the usefullness of the returned iterators, I stuck to the SGI implementation.
            If there is a strong wish from a lot of users, I will put the return value back in again.
            </remarks>
        </member>
        <member name="M:NStl.Collections.Map`2.EraseIf(NStl.Collections.Map{`0,`1}.Iterator,NStl.Collections.Map{`0,`1}.Iterator,NStl.IUnaryFunction{System.Collections.Generic.KeyValuePair{`0,`1},System.Boolean})">
            <summary>
            Erases a range of elements from the map if they satisfy a predicate
            </summary>
            <param name="first">Position of the first element removed from the map</param>
            <param name="last">Position just beyond the last element removed from the map</param>
            <param name="predicate">A unary predicate that needs to be satisfied</param>
            <remarks>
            This method is not part of the C++ STL. Unexperienced C++ Developers often stumble
            over the fact, that you can't use the remove-erase idiom that works for sequence
            containers for associative sorted containers like a map. So this method is provided to
            avoid this glitch in the .NET world
            </remarks>
        </member>
        <member name="M:NStl.Collections.Map`2.EraseIf(NStl.IUnaryFunction{System.Collections.Generic.KeyValuePair{`0,`1},System.Boolean})">
            <summary>
            Erases all elements from the map that satisfy a predicate
            </summary>
            <param name="predicate">A unary predicate that needs to be satisfied</param>
            <remarks>
            This method is not part of the C++ STL. Unexperienced C++ Developers often stumble
            over the fact, that you can't use the remove-erase idiom that works for sequence
            containers for associative sorted containers like a map. So this method is provided to
            avoid this glitch in the .NET world
            </remarks>
        </member>
        <member name="M:NStl.Collections.Map`2.Erase(`0)">
            <summary>
            Erases a specific value from the map
            </summary>
            <param name="val">The key of the elements to be removed from the map</param>
            <returns>the count of the erased elements. This is either 1 or 0</returns>
        </member>
        <member name="M:NStl.Collections.Map`2.Find(`0)">
            <summary>
            Finds the location of a specific element by its key
            </summary>
            <param name="key">The key to be found using the internal comparison functor</param>
            <returns>An iterator pointing to the found value or the end iterator if the value is
            not in the map</returns>
        </member>
        <member name="M:NStl.Collections.Map`2.LowerBound(`0)">
            <summary>
            Returns an iterator to the first element in a map with a key that is equal 
            to or less than a specified key
            </summary>
            <param name="key">The Key to be found</param>
            <returns></returns>
            <remarks>Comparison is one by the internal comparison Predicate</remarks>
        </member>
        <member name="M:NStl.Collections.Map`2.UpperBound(`0)">
            <summary>
            Returns an iterator one past the first element in a map with a key that is 
            equal to or greater than a specified key
            </summary>
            <param name="key">The Key to be found</param>
            <returns></returns>
        </member>
        <member name="M:NStl.Collections.Map`2.Swap(NStl.Collections.Map{`0,`1})">
            <summary>
            Swaps the content of this map with the other set
            </summary>
            <param name="rhs"></param>
            <remarks>Extreme fast operation, as this is a buffer swap</remarks>
        </member>
        <member name="M:NStl.Collections.Map`2.ToArray">
            <summary>
            Copies the content of this container into an array.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Collections.Map`2.CopyTo(System.Collections.Generic.KeyValuePair{`0,`1}[],System.Int32)">
            <summary>
            Copies the content of this container into the passed in array.
            </summary>
            <param name="array"></param>
            <param name="arrayIndex"></param>
        </member>
        <member name="M:NStl.Collections.Map`2.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Deserialization contructor.
            </summary>
            <param name="info"></param>
            <param name="ctxt"></param>
        </member>
        <member name="M:NStl.Collections.Map`2.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            See <see cref="M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)"/> for details.
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="P:NStl.Collections.Map`2.Count">
            <summary>
            The size of the map
            </summary>
            <returns></returns>
        </member>
        <member name="P:NStl.Collections.Map`2.Empty">
            <summary>
            Checks if the map is empty
            </summary>
            <returns></returns>
        </member>
        <member name="P:NStl.Collections.Map`2.Item(`0)">
            <summary>
            Finds a specific value by its key.
            </summary>
            <remarks>
            Will throw, if the Key is not part of the map, as null/nothing is
            a valid entry for a value. If you want to be on te safe side, use map.find instead
            </remarks>
        </member>
        <member name="T:NStl.Collections.Map`2.Iterator">
            <summary>
            
            </summary>
        </member>
        <member name="M:NStl.Collections.Map`2.Iterator.op_Increment(NStl.Collections.Map{`0,`1}.Iterator)">
            <summary>
            
            </summary>
            <param name="it"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.Collections.Map`2.Iterator.op_Decrement(NStl.Collections.Map{`0,`1}.Iterator)">
            <summary>
            
            </summary>
            <param name="it"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.Collections.Map`2.Iterator.Clone">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Collections.Private.HashContainerNode`1.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            See <see cref="M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)"/> for details.
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="M:NStl.Collections.Private.HashContainer`2.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            See <see cref="M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)"/> for details.
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="T:NStl.Arithmetic.Multiply">
            <summary>
            Represents the operation of multiplying two elements.
            </summary>
        </member>
        <member name="M:NStl.Arithmetic.Multiply.Decimal">
            <summary>
            Creates a functor that lets you multiply two <see cref="T:System.Decimal"/> types.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Arithmetic.Multiply.Int32">
            <summary>
            Creates a functor that lets you multiply two <see cref="T:System.Int32"/> types.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Arithmetic.Multiply.Int64">
            <summary>
            Creates a functor that lets you multiply two <see cref="T:System.Int64"/> types.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Arithmetic.Multiply.Int16">
            <summary>
            Creates a functor that lets you multiply two <see cref="T:System.Int16"/> types.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Arithmetic.Multiply.Float">
            <summary>
            Creates a functor that lets you multiply two <see cref="T:System.Single"/> types.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Arithmetic.Multiply.Double">
            <summary>
            Creates a functor that lets you multiply two <see cref="T:System.Double"/> types.
            </summary>
            <returns></returns>
        </member>
        <member name="T:NStl.IBinaryFunction`3">
            <summary>
            Represents a binary function, which is a method that takes two arguments.
            </summary>
            <typeparam name="Result"></typeparam>
            <typeparam name="Param1"></typeparam>
            <typeparam name="Param2"></typeparam>
        </member>
        <member name="M:NStl.IBinaryFunction`3.Execute(`0,`1)">
            <summary>
            This method gets called by the algorithms.
            </summary>
            <param name="lhs"></param>
            <param name="rhs"></param>
            <returns></returns>
        </member>
        <member name="T:NStl.Iterators.Support.ListTIterator`1">
            <summary>
            A random access iterator adapter implememtation for the <see cref="T:System.Collections.Generic.List`1"/>
            collection
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:NStl.Iterators.Support.ListTIterator`1.#ctor(System.Collections.Generic.List{`0},System.Int32)">
            <summary>
            
            </summary>
            <param name="list"></param>
            <param name="idx"></param>
        </member>
        <member name="M:NStl.Iterators.Support.ListTIterator`1.Clone">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Iterators.Support.ListTIterator`1.op_Subtraction(NStl.Iterators.Support.ListTIterator{`0},System.Int32)">
            <summary>
            
            </summary>
            <param name="it"></param>
            <param name="rhs"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.Iterators.Support.ListTIterator`1.op_Addition(NStl.Iterators.Support.ListTIterator{`0},System.Int32)">
            <summary>
            
            </summary>
            <param name="lhs"></param>
            <param name="rhs"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.Iterators.Support.ListTIterator`1.op_Increment(NStl.Iterators.Support.ListTIterator{`0})">
            <summary>
            
            </summary>
            <param name="it"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.Iterators.Support.ListTIterator`1.op_Decrement(NStl.Iterators.Support.ListTIterator{`0})">
            <summary>
            
            </summary>
            <param name="it"></param>
            <returns></returns>
        </member>
        <member name="T:NStl.IUnaryVoidFunction`1">
            <summary>
            When implemented it representa a unary void function.
            </summary>
            <typeparam name="Param"></typeparam>
        </member>
        <member name="T:NStl.Iterators.Support.ListIterator`1">
            <summary>
            A random access iterator adapter implememtation for the <see cref="T:System.Collections.IList"/>
            and <see cref="T:System.Collections.Generic.IList`1"/> interfaces.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:NStl.Iterators.Support.ListIterator`1.#ctor(System.Collections.Generic.IList{`0},System.Int32)">
            <summary>
            
            </summary>
            <param name="list"></param>
            <param name="idx"></param>
        </member>
        <member name="M:NStl.Iterators.Support.ListIterator`1.#ctor(System.Collections.IList,System.Int32)">
            <summary>
            
            </summary>
            <param name="list"></param>
            <param name="idx"></param>
        </member>
        <member name="M:NStl.Iterators.Support.ListIterator`1.Clone">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Iterators.Support.ListIterator`1.op_Subtraction(NStl.Iterators.Support.ListIterator{`0},System.Int32)">
            <summary>
            
            </summary>
            <param name="it"></param>
            <param name="rhs"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.Iterators.Support.ListIterator`1.op_Addition(NStl.Iterators.Support.ListIterator{`0},System.Int32)">
            <summary>
            
            </summary>
            <param name="lhs"></param>
            <param name="rhs"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.Iterators.Support.ListIterator`1.op_Increment(NStl.Iterators.Support.ListIterator{`0})">
            <summary>
            
            </summary>
            <param name="it"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.Iterators.Support.ListIterator`1.op_Decrement(NStl.Iterators.Support.ListIterator{`0})">
            <summary>
            
            </summary>
            <param name="it"></param>
            <returns></returns>
        </member>
        <member name="T:NStl.IEnumerator2IEnumeratorTAdapter`1">
            <summary>
            A simple adapter implementation, that uses the new yield syntax, but
            also allows the iterator to be reseted.
            </summary>
            <typeparam name="U"></typeparam>
        </member>
        <member name="T:NStl.Arithmetic.Modulo">
            <summary>
            Represents the operation of the modulo operation of two elements.
            </summary>
        </member>
        <member name="M:NStl.Arithmetic.Modulo.Decimal">
            <summary>
            Creates a functor that lets you calculate the modulo of two <see cref="T:System.Decimal"/> types.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Arithmetic.Modulo.Int32">
            <summary>
            Creates a functor that lets you calculate the modulo of two <see cref="T:System.Int32"/> types.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Arithmetic.Modulo.Int64">
            <summary>
            Creates a functor that lets you calculate the modulo of two <see cref="T:System.Int64"/> types.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Arithmetic.Modulo.Int16">
            <summary>
            Creates a functor that lets you calculate the modulo of two <see cref="T:System.Int16"/> types.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Arithmetic.Modulo.Float">
            <summary>
            Creates a functor that lets you calculate the modulo of two <see cref="T:System.Single"/> types.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Arithmetic.Modulo.Double">
            <summary>
            Creates a functor that lets you calculate the modulo of two <see cref="T:System.Double"/> types.
            </summary>
            <returns></returns>
        </member>
        <member name="T:NStl.SyntaxHelper.Compose">
            <summary>
            This syntax helper exposes all compose binders of the NSTL.
            </summary>
        </member>
        <member name="M:NStl.SyntaxHelper.Compose.FG``2(NStl.IUnaryFunction{``0,``1},NStl.INullaryFunction{``0})">
            <summary>
            This method returns a functor that binds a nullary into a unary function.
            It can be seen as F(G()).
            </summary>
            <param name="f">The outer functor.</param>
            <param name="g">The inner functor.</param>
            <returns></returns>
        </member>
        <member name="M:NStl.SyntaxHelper.Compose.FG``2(System.Func{``0,``1},System.Func{``0})">
            <summary>
            This method returns a delegate that binds a nullary into a unary delegate.
            It can be seen as F(G()).
            </summary>
            <param name="f">The outer delegate.</param>
            <param name="g">The inner delegate.</param>
            <returns></returns>
        </member>
        <member name="M:NStl.SyntaxHelper.Compose.FGx``3(NStl.IUnaryFunction{``1,``2},NStl.IUnaryFunction{``0,``1})">
            <summary>
            This method creates a binder, that binds the result of one unary function
            into a second one: F(G(x)).
            </summary>
            <param name="f">The outer functor representing F(X).</param>
            <param name="g">The inner functor representing G(X).</param>
            <returns></returns>
        </member>
        <member name="M:NStl.SyntaxHelper.Compose.FGx``3(System.Func{``1,``2},System.Func{``0,``1})">
            <summary>
            This method creates a binder, that binds the result of one unary delegate
            into a second one: F(G(x)).
            </summary>
            <param name="f">The outer functor representing F(X).</param>
            <param name="g">The inner functor representing G(X).</param>
            <returns></returns>
        </member>
        <member name="M:NStl.SyntaxHelper.Compose.FGxHx``4(NStl.IBinaryFunction{``1,``2,``3},NStl.IUnaryFunction{``0,``1},NStl.IUnaryFunction{``0,``2})">
            <summary>
            Returns an adapter that binds the result of two unary function
            called with the same parameter into a binary function: F(G(x), H(x)).
            </summary>
            <param name="f">The functor representing F(G, H).</param>
            <param name="g">The functor representing G(X).</param>
            <param name="h">The functor representing H(X).</param>
            <returns></returns>
        </member>
        <member name="M:NStl.SyntaxHelper.Compose.FGxHx``4(System.Func{``1,``2,``3},System.Func{``0,``1},System.Func{``0,``2})">
            <summary>
            Returns an adapter that binds the result of two unary delegates
            called with the same parameter into a binary delegate: F(G(x), H(x)).
            </summary>
            <param name="f">The delegate representing F(G, H).</param>
            <param name="g">The delegate representing G(X).</param>
            <param name="h">The delegate representing H(X).</param>
            <returns></returns>
        </member>
        <member name="M:NStl.SyntaxHelper.Compose.FGxy``4(NStl.IUnaryFunction{``2,``3},NStl.IBinaryFunction{``0,``1,``2})">
            <summary>
            Returns an adapter that binds the result of a binary function 
            into a unary function:  F(G(x, y)).
            </summary>
            <param name="f">The functor representing F().</param>
            <param name="g">The functor representing G(x, y).</param>
            <returns></returns>
        </member>
        <member name="M:NStl.SyntaxHelper.Compose.FGxy``4(System.Func{``2,``3},System.Func{``0,``1,``2})">
            <summary>
            Returns a delegate that binds the result of a binary delegate 
            into a unary delegate:  F(G(x, y)).
            </summary>
            <param name="f">The delegate representing F().</param>
            <param name="g">The delegate representing G(x, y).</param>
            <returns></returns>
        </member>
        <member name="M:NStl.SyntaxHelper.Compose.FGxHy``5(NStl.IBinaryFunction{``2,``3,``4},NStl.IUnaryFunction{``0,``2},NStl.IUnaryFunction{``1,``3})">
            <summary>
            Returns an adapter that binds the result of two unary functions 
            into a binary function:  F(G(x), H(y)).
            </summary>
            <param name="f">The functor representing F().</param>
            <param name="g">The functor representing G(x).</param>
            <param name="h">The functor representing H(y).</param>
            <returns></returns>
        </member>
        <member name="M:NStl.SyntaxHelper.Compose.FGxHy``5(System.Func{``2,``3,``4},System.Func{``0,``2},System.Func{``1,``3})">
            <summary>
            Returns an adapter that binds the result of two unary delegates
            into a binary delegate:  F(G(x), H(y)).
            </summary>
            <param name="f">The delegate representing F().</param>
            <param name="g">The delegate representing G(x).</param>
            <param name="h">The delegate representing H(y).</param>
            <returns></returns>
        </member>
        <member name="T:NStl.Collections.Range`2">
            <summary>
            A simple class that represents a range bounded by
            two iterators.
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="Iter"></typeparam>
        </member>
        <member name="M:NStl.Collections.Range`2.#ctor(`1,`1)">
            <summary>
            Constructs a range bounded by two iterators.
            </summary>
            <param name="first"></param>
            <param name="last"></param>
        </member>
        <member name="M:NStl.Collections.Range`2.Begin">
            <summary>
            An <see cref="T:NStl.Iterators.IInputIterator`1"/> implementation pointing 
            to the first element of the range.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Collections.Range`2.End">
            <summary>
            An <see cref="T:NStl.Iterators.IInputIterator`1"/> implementation pointing 
            one past the final element of the range.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Collections.Range`2.CopyTo(`0[],System.Int32)">
            <summary>
            
            </summary>
            <param name="array"></param>
            <param name="index"></param>
        </member>
        <member name="P:NStl.Collections.Range`2.Empty">
            <summary>
            Returns FALSE if the collection has any content.
            </summary>
        </member>
        <member name="T:NStl.Collections.HashMultiSet`1">
            <summary>
            <para>
            HashMultiSet is a Hashed Associative Container that stores objects of type T. 
            HashMultiSet is a Simple Associative Container, meaning that its value type, 
            as well as its key type, is T.
            </para>
            <para>
            HashMultiSet is useful in applications where it is important to be able to search 
            for an element quickly. If it is important for the elements to be in a 
            particular order, however, then <see cref="T:NStl.Collections.MultiSet`1"/> is more appropriate. 
            </para>
            </summary>
        </member>
        <member name="M:NStl.Collections.HashMultiSet`1.#ctor(System.Int32,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Construct an empty container with an initial buffer size and the provided 
            <see cref="T:System.Collections.Generic.IEqualityComparer`1"/>implemntation.
            </summary>
            <param name="initialBuffer"></param>
            <param name="hashStrategy"></param>
        </member>
        <member name="M:NStl.Collections.HashMultiSet`1.#ctor">
            <summary>
            Constructs an empty container.
            </summary>
        </member>
        <member name="M:NStl.Collections.HashMultiSet`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Constructs the container and copies the passed in range into it.
            </summary>
            <param name="src"></param>
        </member>
        <member name="M:NStl.Collections.HashMultiSet`1.#ctor(`0[])">
            <summary>
            Constructs the container and copies the passed in range into it.
            </summary>
            <param name="src"></param>
        </member>
        <member name="M:NStl.Collections.HashMultiSet`1.#ctor(System.Collections.IEnumerable)">
            <summary>
            Constructs the container and copies the passed in range into it.
            </summary>
            <param name="src"></param>
        </member>
        <member name="M:NStl.Collections.HashMultiSet`1.#ctor(NStl.Iterators.IInputIterator{`0},NStl.Iterators.IInputIterator{`0})">
            <summary>
            Constructs the container and copies the passed in range into it.
            </summary>
            <param name="first"></param>
            <param name="last"></param>
        </member>
        <member name="M:NStl.Collections.HashMultiSet`1.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Deserialization constructor.
            </summary>
            <param name="info"></param>
            <param name="ctxt"></param>
        </member>
        <member name="M:NStl.Collections.HashMultiSet`1.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            See <see cref="M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)"/> for details.
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="M:NStl.Collections.HashMultiSet`1.Begin">
            <summary>
            Returns an iterator that points to the first element of the range.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Collections.HashMultiSet`1.End">
            <summary>
            Returns an iterator that points one past the final element of the range.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Collections.HashMultiSet`1.Insert(`0)">
            <summary>
            Inserts the item into the container.
            </summary>
            <param name="item">The item to be inserted.</param>
            <returns>An iterator pointing to the inserted item.</returns>
        </member>
        <member name="M:NStl.Collections.HashMultiSet`1.Insert(NStl.Iterators.IInputIterator{`0},NStl.Iterators.IInputIterator{`0})">
            <summary>
            Inserts a range of items int this container.
            </summary>
            <param name="first">
            An <see cref="T:NStl.Iterators.IInputIterator`1"/> implementation pointing 
            to the first element to be inserted.
            </param>
            <param name="last">
            An <see cref="T:NStl.Iterators.IInputIterator`1"/> implementation pointing 
            one past final the element to be inserted.
            </param>
            <exception cref="T:System.ArgumentNullException">Thrown when the first or last is null.</exception>
        </member>
        <member name="M:NStl.Collections.HashMultiSet`1.Insert(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Inserts a range of items int this container.
            </summary>
            <param name="range">The range to be inserted.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when the range is null.</exception>
        </member>
        <member name="M:NStl.Collections.HashMultiSet`1.Find(`0)">
            <summary>
            Looks up the position of a given item.
            </summary>
            <param name="item"></param>
            <returns>
            An iterator pointing to the found value or the end iterator if the key
            is not present.
            </returns>
            <remarks>
            If you wish to find all values associated with the key, use
            <see cref="M:NStl.Collections.HashMultiSet`1.EqualRange(`0)"/> instead.
            </remarks>
        </member>
        <member name="M:NStl.Collections.HashMultiSet`1.Erase(`0)">
            <summary>
            Erases all values.
            </summary>
            <param name="item"></param>
            <returns>The amount of erased values.</returns>
        </member>
        <member name="M:NStl.Collections.HashMultiSet`1.Erase(NStl.Collections.HashMultiSet{`0}.Iterator)">
            <summary>
            Erases the value at the position the iterator points to.
            </summary>
            <param name="where">An iterator pointing at the element to be erased.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when the iterator is null.</exception>
            <exception cref="T:NStl.Exceptions.NotTheSameInstanceException">Thrown when the iterator points to another range.</exception>
            <exception cref="T:NStl.Exceptions.EndIteratorIsNotAValidInputException">Thrown when the iterator is the end iterator.</exception>
        </member>
        <member name="M:NStl.Collections.HashMultiSet`1.Erase(NStl.Collections.HashMultiSet{`0}.Iterator,NStl.Collections.HashMultiSet{`0}.Iterator)">
            <summary>
            Erases a range of elements from the container.
            </summary>
            <param name="first">An iterator pointing on the first element to be erased.</param>
            <param name="last">An iterator pointing one past the final element to be erased.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when one of the iterators is null.</exception>
        </member>
        <member name="M:NStl.Collections.HashMultiSet`1.CountOf(`0)">
            <summary>
            Counts the values.
            </summary>
            <param name="item">The key in question.</param>
            <returns>The amount of values.</returns>
            <remarks>This is a linear operation that depends on count of values.</remarks>
        </member>
        <member name="M:NStl.Collections.HashMultiSet`1.EqualRange(`0)">
            <summary>
            Finds a range containing all elements associated with a given key.
            </summary>
            <param name="item"></param>
            <returns>
            The returned object is a NSTL range and also implements 
            <see cref="T:System.Collections.Generic.IEnumerable`1"/>.
            </returns>
        </member>
        <member name="M:NStl.Collections.HashMultiSet`1.ToArray">
            <summary>
            Copies the content of this container into an array.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Collections.HashMultiSet`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copies the content of this container into a given array.
            </summary>
            <param name="array"></param>
            <param name="index"></param>
        </member>
        <member name="M:NStl.Collections.HashMultiSet`1.Clear">
            <summary>
            Clears the containers content.
            </summary>
        </member>
        <member name="M:NStl.Collections.HashMultiSet`1.Swap(NStl.Collections.HashMultiSet{`0})">
            <summary>
            Swaps this containers content with the others.
            </summary>
            <param name="rhs">The container to be swapped.</param>
            <remarks>This is a constant time operation!</remarks>
        </member>
        <member name="P:NStl.Collections.HashMultiSet`1.Count">
            <summary>
            The amount of entries in the container.
            </summary>
        </member>
        <member name="P:NStl.Collections.HashMultiSet`1.Empty">
            <summary>
            True, when the container is empty
            </summary>
        </member>
        <member name="T:NStl.Collections.HashMultiSet`1.Iterator">
            <summary>
            The iterator of the <see cref="T:NStl.Collections.HashMultiSet`1"/>.
            </summary>
        </member>
        <member name="M:NStl.Collections.HashMultiSet`1.Iterator.Add(System.Int32)">
            <summary>
            Returns a clone of this iterator moved dist ahead.
            </summary>
            <param name="dist"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.Collections.HashMultiSet`1.Iterator.PreIncrement">
            <summary>
            See <see cref="M:NStl.Iterators.IInputIterator`1.PreIncrement"/> for more information.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Collections.HashMultiSet`1.Iterator.Clone">
            <summary>
            See <see cref="M:NStl.Iterators.IIterator`1.Clone"/> for more information.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Collections.HashMultiSet`1.Iterator.Equals(NStl.Iterators.Support.EquatableIterator{`0})">
            <summary>
            See <see cref="M:NStl.Iterators.Support.EquatableIterator`1.Equals(NStl.Iterators.Support.EquatableIterator{`0})"/> for more information.
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.Collections.HashMultiSet`1.Iterator.HashCode">
            <summary>
            See <see cref="M:NStl.Iterators.Support.EquatableIterator`1.HashCode"/> for more information. 
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Collections.HashMultiSet`1.Iterator.op_Increment(NStl.Collections.HashMultiSet{`0}.Iterator)">
            <summary>
            
            </summary>
            <param name="it"></param>
            <returns></returns>
        </member>
        <member name="P:NStl.Collections.HashMultiSet`1.Iterator.Value">
            <summary>
            See <see cref="P:NStl.Iterators.IInputIterator`1.Value"/> for more information.
            </summary>
        </member>
        <member name="T:NStl.Collections.HashMap`2">
            <summary>
            <para>
            HashMap is a Hashed Associative Container that associates objects of type Key 
            with objects of type Data. HashMap is a Pair Associative Container, meaning 
            that its value type is KeyValuePair&lt;const Key, Data&gt;. It is also a Unique Associative 
            Container, meaning that no two elements have keys that compare equal using <see cref="T:System.Collections.Generic.IEqualityComparer`1"/>.
            </para>
            <para>
            Looking up an element in a HashMap by its key is efficient, so HashMap is useful 
            for "dictionaries" where the order of elements is irrelevant. If it is important 
            for the elements to be in a particular order, however, then <see cref="T:NStl.Collections.Map`2"/> 
            is more appropriate. 
            </para>
            </summary>
            <typeparam name="Key"></typeparam>
            <typeparam name="Data"></typeparam>
            <remarks>
            This class is very similar to <see cref="T:System.Collections.Generic.Dictionary`2"/> except that it allows the 
            modification if the values while iterating over the keys.
            </remarks>
        </member>
        <member name="M:NStl.Collections.HashMap`2.#ctor(System.Int32,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Constructs an empty HashMap with th specified minimal buffer size and hash provider.
            </summary>
            <param name="initialBuffer">The minimum initial allocated size of the hashtable.</param>
            <param name="hashStrategy">The hash and equality provider to be used.</param>
        </member>
        <member name="M:NStl.Collections.HashMap`2.#ctor(System.Int32)">
            <summary>
            Constructs an empty HashMap with th specified minimal buffer size.
            </summary>
            <param name="initialBuffer"></param>
        </member>
        <member name="M:NStl.Collections.HashMap`2.#ctor">
            <summary>
            Constructs an empty HashMap.
            </summary>
        </member>
        <member name="M:NStl.Collections.HashMap`2.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}})">
            <summary>
            Constructs a HashMap and copies given the range into it.
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:NStl.Collections.HashMap`2.#ctor(NStl.Iterators.IInputIterator{System.Collections.Generic.KeyValuePair{`0,`1}},NStl.Iterators.IInputIterator{System.Collections.Generic.KeyValuePair{`0,`1}})">
            <summary>
            Constructs a HashMap and copies given the range into it.
            </summary>
            <param name="first"></param>
            <param name="last"></param>
        </member>
        <member name="M:NStl.Collections.HashMap`2.#ctor(System.Collections.Generic.KeyValuePair{`0,`1}[])">
            <summary>
            Constructs a HashMap and copies given the range into it.
            </summary>
        </member>
        <member name="M:NStl.Collections.HashMap`2.#ctor(System.Collections.IEnumerable)">
            <summary>
            Constructs a HashMap and copies given the range into it.
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:NStl.Collections.HashMap`2.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Deserialization constructor.
            </summary>
            <param name="info"></param>
            <param name="ctxt"></param>
        </member>
        <member name="M:NStl.Collections.HashMap`2.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            See <see cref="M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)"/> for details.
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="M:NStl.Collections.HashMap`2.Insert(`0,`1)">
            <summary>
            Inserts a given key value pair into this container.
            </summary>
            <param name="key"></param>
            <param name="data"></param>
        </member>
        <member name="M:NStl.Collections.HashMap`2.Insert(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Inserts a key value pair into the container.
            </summary>
            <param name="pair">The pair to be inserted.</param>
            <returns>
            A KeyValuePair containg an iterator and a boll flag indication success.
            If the bool flag is TRUE, item was inserted and the iterator points
            to the inserted item. otherwise it is the end iterator.
            </returns>
        </member>
        <member name="M:NStl.Collections.HashMap`2.Insert(NStl.Iterators.IInputIterator{System.Collections.Generic.KeyValuePair{`0,`1}},NStl.Iterators.IInputIterator{System.Collections.Generic.KeyValuePair{`0,`1}})">
            <summary>
            Inserts a range of key value pairs into the container.
            </summary>
            <param name="first"></param>
            <param name="last"></param>
        </member>
        <member name="M:NStl.Collections.HashMap`2.Clear">
            <summary>
            Empties the container.
            </summary>
        </member>
        <member name="M:NStl.Collections.HashMap`2.CopyTo(System.Collections.Generic.KeyValuePair{`0,`1}[],System.Int32)">
            <summary>
            Copies the content of this container into the given array starting at the given index.
            </summary>
            <param name="array"></param>
            <param name="arrayIndex"></param>
        </member>
        <member name="M:NStl.Collections.HashMap`2.ToArray">
            <summary>
            Copies the content of this container into an array.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Collections.HashMap`2.Begin">
            <summary>
            Returns an iterator pointing to the first element of the container.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Collections.HashMap`2.End">
            <summary>
            Returns an iterator pointing one past the final element of the container.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Collections.HashMap`2.Erase(`0)">
            <summary>
            Erases the element at the given key.
            </summary>
            <param name="key"></param>
            <returns>True, if an element existed to be erased.</returns>
        </member>
        <member name="M:NStl.Collections.HashMap`2.Find(`0)">
            <summary>
            Searches for an element for the given key.
            </summary>
            <param name="key"></param>
            <returns>An iterator pointing to the found element, the end iterator if no item was found.</returns>
        </member>
        <member name="M:NStl.Collections.HashMap`2.Erase(NStl.Collections.HashMap{`0,`1}.Iterator)">
            <summary>
            Erases the element that the iterator points to.
            </summary>
            <param name="where"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.Collections.HashMap`2.Erase(NStl.Collections.HashMap{`0,`1}.Iterator,NStl.Collections.HashMap{`0,`1}.Iterator)">
            <summary>
            Erases a range of elements.
            </summary>
            <param name="first"></param>
            <param name="last"></param>
        </member>
        <member name="M:NStl.Collections.HashMap`2.Swap(NStl.Collections.HashMap{`0,`1})">
            <summary>
            Swaps this container with the other.
            </summary>
            <param name="rhs">The container to be swapped with this container.</param>
            <remarks>This is a constant time operation.</remarks>
        </member>
        <member name="P:NStl.Collections.HashMap`2.Count">
            <summary>
            The number of elements inside the container.
            </summary>
        </member>
        <member name="P:NStl.Collections.HashMap`2.Empty">
            <summary>
            True, if the container is empty.
            </summary>
        </member>
        <member name="P:NStl.Collections.HashMap`2.Item(`0)">
            <summary>
            Returns a value for a given key.
            </summary>
            <param name="key"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException">Thrown when key is null.</exception>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">Thrown when no value stored for the key.</exception>
        </member>
        <member name="T:NStl.Collections.HashMap`2.Iterator">
            <summary>
            The HashMap iterator
            </summary>
        </member>
        <member name="M:NStl.Collections.HashMap`2.Iterator.PreIncrement">
            <summary>
            See <see cref="M:NStl.Iterators.IInputIterator`1.PreIncrement"/> for more information.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Collections.HashMap`2.Iterator.Clone">
            <summary>
            See <see cref="M:NStl.Iterators.IIterator`1.Clone"/> for more information.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Collections.HashMap`2.Iterator.Equals(NStl.Iterators.Support.EquatableIterator{System.Collections.Generic.KeyValuePair{`0,`1}})">
            <summary>
            See <see cref="M:System.Object.Equals(System.Object)"/> for details.
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.Collections.HashMap`2.Iterator.HashCode">
            <summary>
            See <see cref="M:System.Object.GetHashCode"/> for details.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Collections.HashMap`2.Iterator.op_Increment(NStl.Collections.HashMap{`0,`1}.Iterator)">
            <summary>
            
            </summary>
            <param name="it"></param>
            <returns></returns>
        </member>
        <member name="P:NStl.Collections.HashMap`2.Iterator.Value">
            <summary>
            See <see cref="P:NStl.Iterators.IInputIterator`1.Value"/> for more information.
            </summary>
        </member>
        <member name="T:NStl.Collections.IReadOnlyList`1">
            <summary>
            When implement it represents a read only indexed base list.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:NStl.Collections.IReadOnlyCollection`1">
            <summary>
            When implemented, it represents a readonly collection, i.e. a
            collection that cannot be modified.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:NStl.Collections.IReadOnlyCollection`1.Contains(`0)">
            <summary>
            Determines whether the container contains a specific value.
            </summary>
            <param name="item">The object to locate</param>
            <returns>true if item is found in the container; otherwise, false.</returns>
        </member>
        <member name="M:NStl.Collections.IReadOnlyCollection`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copies the content of this container into a given array.
            </summary>
            <param name="array"></param>
            <param name="arrayIndex">The index in the array where the first element is to be inserted.</param>
        </member>
        <member name="M:NStl.Collections.IReadOnlyCollection`1.ToArray">
            <summary>
            Copies the content of this container into a newly allocated array.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Collections.IReadOnlyCollection`1.Front">
            <summary>
            returns the first element in the container;
            </summary>
            <returns></returns>
        </member>
        <member name="P:NStl.Collections.IReadOnlyCollection`1.Empty">
            <summary>
            return true, if the container is empty, false otherwise.
            </summary>
        </member>
        <member name="M:NStl.Collections.IReadOnlyList`1.IndexOf(`0)">
            <summary>
            Finds teh index of a given item
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.Collections.IReadOnlyList`1.Back">
            <summary>
            The last element of the list.
            </summary>
            <returns></returns>
        </member>
        <member name="P:NStl.Collections.IReadOnlyList`1.Item(System.Int32)">
            <summary>
            Index based random access
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="T:NStl.SyntaxHelper.Bind">
            <summary>
            Syntax helper that exposes all function binders.
            </summary>
        </member>
        <member name="M:NStl.SyntaxHelper.Bind.Zeroth``2(NStl.IUnaryFunction{``0,``1},``0)">
            <summary>
            A helper function that creates an adapter 
            to convert a unary function object into a nullary 
            function object by binding the argument of the 
            unary function to a specified value.
            </summary>
            <typeparam name="Param2Bind"></typeparam>
            <typeparam name="Result"></typeparam>
            <param name="func"></param>
            <param name="par"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.SyntaxHelper.Bind.Zeroth``2(System.Func{``0,``1},``0)">
            <summary>
            A helper function that creates a delegate 
            to convert a unary delegate into a nullary 
            delegate by binding the argument of the 
            unary delegate to a specified value.
            </summary>
            <typeparam name="Param2Bind"></typeparam>
            <typeparam name="Result"></typeparam>
            <param name="func"></param>
            <param name="par"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.SyntaxHelper.Bind.First``3(NStl.IBinaryFunction{``0,``1,``2},``0)">
            <summary>
            A helper function that creates an adapter 
            to convert a binary function object into a unary 
            function object by binding the first argument of the 
            binary function to a specified value.
            </summary>
            <param name="func">The binary function object that is adapted to a unary function by parameter binding</param>
            <param name="left">The parameter that is bound to the function.</param>
            <returns></returns>
        </member>
        <member name="M:NStl.SyntaxHelper.Bind.First``3(System.Func{``0,``1,``2},``0)">
            <summary>
            A helper function that creates a delegate 
            to convert a binary delegate object into a unary 
            delegate by binding the first argument of the 
            binary delegate to a specified value.
            </summary>
            <param name="func">The binary delegate object that is adapted to a unary function by parameter binding</param>
            <param name="left">The parameter that is bound to the delegate.</param>
            <returns></returns>
        </member>
        <member name="M:NStl.SyntaxHelper.Bind.First``2(NStl.IBinaryPredicate{``0,``1},``0)">
            <summary>
            A helper function that creates an adapter 
            to convert a binary function object into a unary 
            function object by binding the first argument of the 
            binary function to a specified value.
            </summary>
            <param name="func">
            The binary function object that is adapted to a unary function by parameter binding.
            </param>
            <param name="left">The parameter that is bound to the function.</param>
            <returns></returns>
        </member>
        <member name="M:NStl.SyntaxHelper.Bind.Second``3(NStl.IBinaryFunction{``0,``1,``2},``1)">
            <summary>
            Creates an adapter to convert a binary function object into a unary 
            function object by binding the second argument of the 
            binary function to a specified value.
            </summary>
            <param name="func">
            The binary function object that is adapted to a unary function by parameter binding.
            </param>
            <param name="right">The parameter that is bound to the function.</param>
            <returns></returns>
        </member>
        <member name="M:NStl.SyntaxHelper.Bind.Second``3(System.Func{``0,``1,``2},``1)">
            <summary>
            Creates an adapter to convert a binary delegate object into a unary 
            delegate by binding the second argument of the 
            binary delegate to a specified value.
            </summary>
            <param name="func">
            The binary delegate object that is adapted to a unary delegate by parameter binding.
            </param>
            <param name="right">The parameter that is bound to the function.</param>
            <returns></returns>
        </member>
        <member name="M:NStl.SyntaxHelper.Bind.Second``2(NStl.IBinaryPredicate{``0,``1},``1)">
            <summary>
            Creates an adapter to convert a binary function object into a unary 
            function object by binding the second argument of the 
            binary function to a specified value.
            </summary>
            <typeparam name="Param1"></typeparam>
            <typeparam name="Param2Bind"></typeparam>
            <param name="func"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="T:NStl.IFrontInsertable`1">
            <summary>
            When implemented, this range can have objects added to its front.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:NStl.IFrontInsertable`1.PushFront(`0)">
            <summary>
            Appends the new Object at the end of the range
            </summary>
            <param name="val">The object to be appended at the front</param>
        </member>
        <member name="T:NStl.Linq.IteratorExtension">
            <summary>
            Provides a set of static (Shared in Visual Basic) extension methods for iterators.
            </summary>
        </member>
        <member name="M:NStl.Linq.IteratorExtension.AsRange``1(NStl.Iterators.IInputIterator{``0},NStl.Iterators.IInputIterator{``0})">
            <summary>
            Adapts the input iterators to a range.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="first"></param>
            <param name="last"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.Linq.IteratorExtension.AsRange``1(NStl.Iterators.IForwardIterator{``0},NStl.Iterators.IForwardIterator{``0})">
            <summary>
            Adapts the input iterators to a range.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="first"></param>
            <param name="last"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.Linq.IteratorExtension.AsRange``1(NStl.Iterators.IBidirectionalIterator{``0},NStl.Iterators.IBidirectionalIterator{``0})">
            <summary>
            Adapts the input iterators to a range.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="first"></param>
            <param name="last"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.Linq.IteratorExtension.AsRange``1(NStl.Iterators.IBidirectionalInputIterator{``0},NStl.Iterators.IBidirectionalInputIterator{``0})">
            <summary>
            Adapts the input iterators to a range.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="first"></param>
            <param name="last"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.Linq.IteratorExtension.AsRange``1(NStl.Iterators.IRandomAccessIterator{``0},NStl.Iterators.IRandomAccessIterator{``0})">
            <summary>
            Adapts the input iterators to a range.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="first"></param>
            <param name="last"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.Linq.IteratorExtension.AsRange``1(NStl.Iterators.IRandomAccessInputIterator{``0},NStl.Iterators.IRandomAccessInputIterator{``0})">
            <summary>
            Adapts the input iterators to a range.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="first"></param>
            <param name="last"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.Linq.IteratorExtension.AsRange``2(``1,``1)">
            <summary>
            Adapts the input iterators to a range.
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="Iter"></typeparam>
            <param name="first"></param>
            <param name="last"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.Linq.IteratorExtension.AsCollection``1(NStl.Iterators.IInputIterator{``0},NStl.Iterators.IInputIterator{``0})">
            <summary>
            Adapts the input iterators to an <see cref="T:System.Collections.ICollection"/>.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="first"></param>
            <param name="last"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.Linq.IteratorExtension.AsEnumerable``1(NStl.Iterators.IInputIterator{``0},NStl.Iterators.IInputIterator{``0})">
            <summary>
            Adapts the input iterators to an <see cref="T:System.Collections.Generic.IEnumerable`1"/>.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="first"></param>
            <param name="last"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.Linq.IteratorExtension.Add``1(NStl.Iterators.IInputIterator{``0},System.Int32)">
            <summary>
            Clones the iterator and moves the clone by dist.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="it"></param>
            <param name="dist">The distance that this iterator will be moved.</param>
            <returns>A cloned iterator moved by the specified distance.</returns>
            <exception cref="T:System.ArgumentException">Thrown when dist is negative.</exception>
        </member>
        <member name="M:NStl.Linq.IteratorExtension.Add``1(NStl.Iterators.IForwardIterator{``0},System.Int32)">
            <summary>
            Clones the iterator and moves the clone by dist.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="it"></param>
            <param name="dist">The distance that this iterator will be moved.</param>
            <returns>A cloned iterator moved by the specified distance.</returns>
            <exception cref="T:System.ArgumentException">Thrown when dist is negative.</exception>
        </member>
        <member name="M:NStl.Linq.IteratorExtension.Add``1(NStl.Iterators.IBidirectionalIterator{``0},System.Int32)">
            <summary>
            Clones the iterator and moves the clone by dist.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="it"></param>
            <param name="dist">The distance that this iterator will be moved.</param>
            <returns>A cloned iterator moved by the specified distance.</returns>
        </member>
        <member name="M:NStl.Linq.IteratorExtension.DistanceTo``1(NStl.Iterators.IInputIterator{``0},NStl.Iterators.IInputIterator{``0})">
            <summary>
             Determines the number of increments between the positions if this iterator and another.
            </summary>
            <param name="first"></param>
            <param name="last"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:NStl.Linq.IteratorExtension.DistanceTo``1(NStl.Iterators.IRandomAccessIterator{``0},NStl.Iterators.IRandomAccessIterator{``0})">
            <summary>
             Determines the number of increments between the positions if this iterator and another.
            </summary>
            <param name="first"></param>
            <param name="last"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:NStl.Linq.IteratorExtension.AddFirstInserter``1(NStl.IFrontInsertable{``0})">
            <summary>
            Returns an <see cref="T:NStl.Iterators.IOutputIterator`1"/> implementation that adds
            values to the start of the sequence.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <returns></returns>
        </member>
        <member name="T:NStl.Functional">
            <summary>
            This class contains all diverse functional related things.
            </summary>
        </member>
        <member name="M:NStl.Functional.Cloner``1">
            <summary>
            Returns a unction object that will clone and return the passed in parameter.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Functional.IsNull``1">
            <summary>
            Returns a functor that can be used to check if the passed in argument is null/Nothing.
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:NStl.Functional.IsDefault``1">
            <summary>
            Returns a functor that can be used to check if the passed in argument the default value.
            The default value for refernce types is null/Nothing. For value types refer to their documentation.
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
            <remarks>
            For example, a System.Int32 defaults to 0, bool to fale and so on.
            </remarks>
        </member>
        <member name="M:NStl.Functional.IsKindOf">
            <summary>
            Returns a functor that compares if the <see cref="T:System.Type"/> in the first parameter
            derives or implements the <see cref="T:System.Type"/> in the second parameter.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Functional.PtrFun``3(System.Func{``0,``1,``2})">
            <summary>
            Helper that converts any function with two arguments into a BinaryFunction.
            The returned functor will pass the arguments that are passed into 
            BinaryFunction.Execute(..) as arguments into the stored delegate.
            </summary>
            <typeparam name="Arg1">The type of the first argument.</typeparam>
            <typeparam name="Arg2">The type of the second argument.</typeparam>
            <typeparam name="Result">The type of the result.</typeparam>
            <param name="del">The function to adapt to a binary function object.</param>
            <returns>A binary function object.</returns>
        </member>
        <member name="M:NStl.Functional.PtrFun``2(System.Action{``0,``1})">
            <summary>
            Helper that converts any void function with two arguments into a BinaryFunction.
            The returned functor will pass the arguments that are passed into 
            BinaryFunction.Execute(..) as arguments into the stored delegate.
            </summary>
            <typeparam name="Arg1">The type of the first argument.</typeparam>
            <typeparam name="Arg2">The type of the second argument.</typeparam>
            <param name="del">The function to adapt to a binary function object.</param>
            <returns>A binary function object.</returns>
        </member>
        <member name="M:NStl.Functional.PtrFun``2(System.Func{``0,``1})">
            <summary>
            Helper that converts any function with one argument into a UnaryFunction.
            The returned functor will pass the argument that is passed into 
            UnaryFunction.Execute(..) as an argument into the stored delegate.
            </summary>
            <typeparam name="Arg">The type of the argument.</typeparam>
            <typeparam name="Result">The type of the return value.</typeparam>
            <param name="del">The function to adapt.</param>
            <returns></returns>
        </member>
        <member name="M:NStl.Functional.PtrFun``1(System.Action{``0})">
            <summary>
            Helper that converts any void function with one argument into a UnaryFunction.
            The returned functor will pass the argument that is passed into 
            UnaryFunction.Execute(..) as an argument into the stored delegate.
            </summary>
            <typeparam name="Arg">The type of the argument.</typeparam>
            <param name="del"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.Functional.PtrFun``1(System.Func{``0})">
            <summary>
            Helper that converts any void function with zero arguments into a NullaryFunction.
            </summary>
            <typeparam name="Result"></typeparam>
            <param name="del"></param>
            <returns></returns>
        </member>
        <member name="T:NStl.IBinaryPredicate`2">
            <summary>
            When implemented, it represents a binray predicate.
            </summary>
            <typeparam name="Param1"></typeparam>
            <typeparam name="Param2"></typeparam>
        </member>
        <member name="T:NStl.Collections.MultiMap`2">
            <summary>
            MultiMap is a Sorted Associative Container that associates objects of type Key 
            with objects of type Value. multimap is a Pair Associative Container, meaning 
            that its value type is a <see cref="T:System.Collections.Generic.KeyValuePair`2"/>. It is also a Multiple Associative 
            Container, meaning that there is no limit on the number of elements with the 
            same key. MultiMap has the important property that inserting a new element 
            into a MultiMap does not invalidate iterators that point to existing elements. 
            Erasing an element from a MultiMap also does not invalidate any iterators, 
            except, of course, for iterators that actually point to the element that is 
            being erased. 
            </summary>
        </member>
        <member name="M:NStl.Collections.MultiMap`2.#ctor(NStl.IBinaryFunction{`0,`0,System.Boolean})">
            <summary>
            Constructs an empty map using the provided comparer functor
            </summary>
            <param name="comparison"></param>
        </member>
        <member name="M:NStl.Collections.MultiMap`2.#ctor(NStl.Collections.Private.RbTree{`0,System.Collections.Generic.KeyValuePair{`0,`1}})">
            <summary>
            Constructs a map with an external tree implementation
            </summary>
            <param name="tree"></param>
        </member>
        <member name="M:NStl.Collections.MultiMap`2.#ctor(NStl.IBinaryFunction{`0,`0,System.Boolean},NStl.Iterators.IInputIterator{System.Collections.Generic.KeyValuePair{`0,`1}},NStl.Iterators.IInputIterator{System.Collections.Generic.KeyValuePair{`0,`1}})">
            <summary>
            ctor, copies the passed in range into this map
            </summary>
            <param name="comparison">Comparison functor</param>
            <param name="first">The position of the first element to be copied to the map</param>
            <param name="last">The position just beyond the last element to be copied to the map</param>
        </member>
        <member name="M:NStl.Collections.MultiMap`2.#ctor(NStl.IBinaryFunction{`0,`0,System.Boolean},System.Collections.IEnumerable)">
            <summary>
            ctor, copies the passed in range into this map.
            </summary>
            <param name="comparison">Comparison functor</param>
            <param name="list">The IList to be copied into this map</param>
        </member>
        <member name="M:NStl.Collections.MultiMap`2.#ctor(NStl.IBinaryFunction{`0,`0,System.Boolean},System.Collections.Generic.KeyValuePair{`0,`1}[])">
            <summary>
            Constructs the container and copies the parameters into it.
            </summary>
            <param name="comparison"></param>
            <param name="list"></param>
        </member>
        <member name="M:NStl.Collections.MultiMap`2.#ctor(NStl.IBinaryFunction{`0,`0,System.Boolean},System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}})">
            <summary>
            ctor, copies the passed in range into this map.
            </summary>
            <param name="comparison">Comparison functor</param>
            <param name="list">The IList to be copied into this map</param>
        </member>
        <member name="M:NStl.Collections.MultiMap`2.Begin">
            <summary>
            Returns an iterator that addresses the first element in the set.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Collections.MultiMap`2.End">
            <summary>
            Returns an iterator pointing one past the last element of the set
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Collections.MultiMap`2.RBegin">
            <summary>
            Returns an iterator addressing the first element in a reversed set
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Collections.MultiMap`2.REnd">
            <summary>
            Returns an iterator pointing one past the last element of the reversed set
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Collections.MultiMap`2.Insert(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Inserts a key value pair into the multimap
            </summary>
            <param name="val">The key value pair to be inserted</param>
            <returns>
            An iterator that points to the position where the new element was inserted
            </returns>
        </member>
        <member name="M:NStl.Collections.MultiMap`2.Insert(`0,`1)">
            <summary>
            Inserts a key value pair into the multimap
            </summary>
            <param name="key"></param>
            <param name="item"></param>
            <returns>
            An iterator that points to the position where the new element was inserted
            </returns>
        </member>
        <member name="M:NStl.Collections.MultiMap`2.Insert(NStl.Collections.MultiMap{`0,`1}.Iterator,System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Inserts an element into the multimap
            </summary>
            <param name="where">
            The place to start searching for the correct point of insertion. 
            (Insertion can occur in constant time, instead of logarithmic 
            time, if the insertion point immediately follows where.) 
            </param>
            <param name="val">
            The value of an element to be inserted into the set 
            </param>
            <returns>
            An iterator that points to the position where the new element was inserted
            </returns>
        </member>
        <member name="M:NStl.Collections.MultiMap`2.Insert(NStl.Iterators.IInputIterator{System.Collections.Generic.KeyValuePair{`0,`1}},NStl.Iterators.IInputIterator{System.Collections.Generic.KeyValuePair{`0,`1}})">
            <summary>
            Insert a range of elements into the uniqueset
            </summary>
            <param name="first">The position of the first element to be copied to the set</param>
            <param name="last">The position just beyond the last element to be copied to the set</param>
        </member>
        <member name="M:NStl.Collections.MultiMap`2.Clear">
            <summary>
            Erases all elements
            </summary>
        </member>
        <member name="M:NStl.Collections.MultiMap`2.CountOf(`0)">
            <summary>
            Returns the number of elements in the set using the internal comparison functor
            </summary>
            <param name="key">The object to be counted</param>
            <returns></returns>
        </member>
        <member name="M:NStl.Collections.MultiMap`2.EqualRange(`0)">
            <summary>
            Finds a range containing all elements whose key is Key
            </summary>
            <param name="key">
            The argument key to be compared with the sort key of an element from the 
            set being searched
            </param>
            <returns>
            A pair of iterators where the first is the lower_bound of the key and 
            the second is the upper_bound of the key
            </returns>
        </member>
        <member name="M:NStl.Collections.MultiMap`2.Erase(NStl.Collections.MultiMap{`0,`1}.Iterator)">
            <summary>
            Removes the element at the specified position
            </summary>
            <param name="where">Position of the element to be removed from the set</param>
        </member>
        <member name="M:NStl.Collections.MultiMap`2.Erase(NStl.Collections.MultiMap{`0,`1}.Iterator,NStl.Collections.MultiMap{`0,`1}.Iterator)">
            <summary>
            Removes a range of elements from the set
            </summary>
            <param name="first">Position of the first element removed from the set</param>
            <param name="last">Position just beyond the last element removed from the set</param>
        </member>
        <member name="M:NStl.Collections.MultiMap`2.Erase(`0)">
            <summary>
            Erases a specific value from the set
            </summary>
            <param name="key">The key of the elements to be removed from the s</param>
            <returns>the count of the erased elements. This is either 1 or 0</returns>
        </member>
        <member name="M:NStl.Collections.MultiMap`2.Find(`0)">
            <summary>
            Finds the location of a specific element
            </summary>
            <param name="key">The key to be found using the internal comparison functor</param>
            <returns></returns>
        </member>
        <member name="M:NStl.Collections.MultiMap`2.LowerBound(`0)">
            <summary>
            Returns an iterator to the first element in a set with a key that is equal 
            to or less than a specified key
            </summary>
            <param name="key">The value to be found</param>
            <returns></returns>
            <remarks>Comparison is one by the internal comparison Predicate</remarks>
        </member>
        <member name="M:NStl.Collections.MultiMap`2.UpperBound(`0)">
            <summary>
            Returns an iterator one past the first element in a set with a key that is 
            equal to or greater than a specified key
            </summary>
            <param name="key">The value to be found</param>
            <returns></returns>
        </member>
        <member name="M:NStl.Collections.MultiMap`2.Swap(NStl.Collections.MultiMap{`0,`1})">
            <summary>
            Swaps the content of this set with the other set
            </summary>
            <param name="rhs"></param>
            <remarks>Extreme fast operation, as this is a buffer swap</remarks>
        </member>
        <member name="M:NStl.Collections.MultiMap`2.ToArray">
            <summary>
            Copies the content of this container into an array.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Collections.MultiMap`2.CopyTo(System.Collections.Generic.KeyValuePair{`0,`1}[],System.Int32)">
            <summary>
            Copies the content of this container into the passed in array.
            </summary>
            <param name="array"></param>
            <param name="arrayIndex"></param>
        </member>
        <member name="M:NStl.Collections.MultiMap`2.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Deserialization contructor.
            </summary>
            <param name="info"></param>
            <param name="ctxt"></param>
        </member>
        <member name="M:NStl.Collections.MultiMap`2.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            See <see cref="M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)"/> for details.
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="P:NStl.Collections.MultiMap`2.Empty">
            <summary>
            Checks if the set is empty
            </summary>
            <returns></returns>
        </member>
        <member name="P:NStl.Collections.MultiMap`2.Count">
            <summary>
            Returns the number of elements in the set
            </summary>
            <returns></returns>
        </member>
        <member name="T:NStl.Collections.MultiMap`2.Iterator">
            <summary>
            
            </summary>
        </member>
        <member name="M:NStl.Collections.MultiMap`2.Iterator.op_Increment(NStl.Collections.MultiMap{`0,`1}.Iterator)">
            <summary>
            
            </summary>
            <param name="it"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.Collections.MultiMap`2.Iterator.op_Decrement(NStl.Collections.MultiMap{`0,`1}.Iterator)">
            <summary>
            
            </summary>
            <param name="it"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.Collections.MultiMap`2.Iterator.Clone">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="T:NStl.Debugging.CollectionDebuggerProxy">
            <summary>
            Simplifies the debug view for a collection
            </summary>
        </member>
        <member name="T:NStl.Linq.ListExtension">
            <summary>
            Provides a set of static (Shared in Visual Basic) methods 
            for querying objects that implement <see cref="T:System.Collections.Generic.IList`1"/>.
            </summary>
        </member>
        <member name="M:NStl.Linq.ListExtension.Cast``1(System.Collections.IList)">
            <summary>
            Converts the elements of an <see cref="T:System.Collections.IList"/> to the specified type.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <returns></returns>
            <remarks>
            This method returns an adapter object, so calling this methond is very efficient.
            </remarks>
        </member>
        <member name="M:NStl.Linq.ListExtension.Begin``1(System.Collections.Generic.IList{``0})">
            <summary>
            Creates an iterator that points to the first element of the list.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.Linq.ListExtension.End``1(System.Collections.Generic.IList{``0})">
            <summary>
            Creates an iterator that points one past the final element of the list.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.Linq.ListExtension.Last``1(System.Collections.Generic.IList{``0})">
            <summary>
            Returns the last element of an <see cref="T:System.Collections.Generic.IList`1"/>.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.Linq.ListExtension.Resize``1(System.Collections.Generic.IList{``0},System.Int32,``0)">
            <summary>
            Resizes the list to contain count members. It shortens the list if 
            count is less than <see cref="P:System.Collections.Generic.ICollection`1.Count"/> or adds value if
            it is greater.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="count">The new size of the list.</param>
            <param name="value">The value to be added if the list has to grow.</param>
        </member>
        <member name="M:NStl.Linq.ListExtension.Resize``1(System.Collections.Generic.IList{``0},System.Int32)">
            <summary>
            Resizes the list to contain count members. It shortens the list if 
            count is less than <see cref="P:System.Collections.Generic.ICollection`1.Count"/> or adds default(T) if
            it is greater.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="count">The new size of the list.</param>
        </member>
        <member name="M:NStl.Linq.ListExtension.PopLast``1(System.Collections.Generic.IList{``0})">
            <summary>
            Removes the last elememt of the list.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <exception cref="T:System.InvalidOperationException">Thrown when the list is empty.</exception>
        </member>
        <member name="M:NStl.Linq.ListExtension.Insert``1(System.Collections.Generic.IList{``0},NStl.Iterators.Support.ListIterator{``0},``0)">
            <summary>
            Inserts the passed in value at the given position.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="where">An iterator pointin to the position of the insertion.</param>
            <param name="value">The value to be inserted.</param>
            <returns>An interator pointing to the newly inserted element.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when the iterator is null.</exception>
        </member>
        <member name="M:NStl.Linq.ListExtension.Insert``1(System.Collections.Generic.IList{``0},NStl.Iterators.Support.ListIterator{``0},System.Int32,``0)">
            <summary>
            Inserts the passed in value n times at the given position.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="where">An iterator pointin to the position of the insertion.</param>
            <param name="count">The amount of times that the value will be inserted.</param>
            <param name="value">The value to be inserted.</param>
            <returns>An interator pointing to the newly inserted element.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when the iterator is null.</exception>
        </member>
        <member name="M:NStl.Linq.ListExtension.InsertIterator``1(System.Collections.Generic.IList{``0},NStl.Iterators.Support.ListIterator{``0})">
            <summary>
            Creates an <see cref="T:NStl.Iterators.IOutputIterator`1"/> implementation
            that lets you insert values at the specified position.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="where">The position of the insertion.</param>
            <returns></returns>
        </member>
        <member name="M:NStl.Linq.ListExtension.Remove``1(System.Collections.Generic.IList{``0},NStl.Iterators.Support.ListIterator{``0})">
            <summary>
            Erases the element at the specified position.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="where">
            An <see cref="T:NStl.Iterators.Support.ListTIterator`1"/> pointing to the element to be deleted.
            </param>
            <returns>
            An <see cref="T:NStl.Iterators.Support.ListTIterator`1"/> pointing the first element remaining 
            beyond any elements removed.
            </returns>
        </member>
        <member name="M:NStl.Linq.ListExtension.Remove``1(System.Collections.Generic.IList{``0},NStl.Iterators.Support.ListIterator{``0},NStl.Iterators.Support.ListIterator{``0})">
            <summary>
            Erases the elements of the specified sub range.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="first"></param>
            <param name="last"></param>
            <returns>
            An <see cref="T:NStl.Iterators.Support.ListTIterator`1"/> pointing the first element remaining 
            beyond any elements removed.
            </returns>
        </member>
        <member name="M:NStl.Linq.ListExtension.RBegin``1(System.Collections.Generic.IList{``0})">
            <summary>
            Creates an iterator that points one before the first element of the list
            and will iterate backwards.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.Linq.ListExtension.REnd``1(System.Collections.Generic.IList{``0})">
            <summary>
            Creates an iterator that points on the final element of the list
            and iterates backwards.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.Linq.ListExtension.Weak``1(System.Collections.Generic.IList{``0})">
            <summary>
            Creates an adapter that allows to use a generic collectiona as its non generic counterpart.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="collection"></param>
            <returns></returns>
            <remarks>
            This is a dangerous tool only suited to satisfy compatibility issues
            with older APIs.
            </remarks>
        </member>
        <member name="M:NStl.Linq.ListExtension.AddLastInserter``1(System.Collections.Generic.IList{``0})">
            <summary>
            Returns an <see cref="T:NStl.Iterators.IOutputIterator`1"/> implementation that adds
            values to the end of the sequence.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <returns></returns>
        </member>
        <member name="T:NStl.Iterators.Support.LinkedListIterator`1">
            <summary>
            A <see cref="T:NStl.Iterators.IBidirectionalIterator`1"/> implementation for a <see cref="T:System.Collections.Generic.LinkedList`1"/> container;
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:NStl.Iterators.Support.LinkedListIterator`1.PreDecrement">
            <summary>
            See base class.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Iterators.Support.LinkedListIterator`1.PreIncrement">
            <summary>
            See base class.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Iterators.Support.LinkedListIterator`1.Clone">
            <summary>
            See base class.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Iterators.Support.LinkedListIterator`1.Equals(NStl.Iterators.Support.EquatableIterator{`0})">
            <summary>
            
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.Iterators.Support.LinkedListIterator`1.HashCode">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Iterators.Support.LinkedListIterator`1.op_Increment(NStl.Iterators.Support.LinkedListIterator{`0})">
            <summary>
            
            </summary>
            <param name="it"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.Iterators.Support.LinkedListIterator`1.op_Decrement(NStl.Iterators.Support.LinkedListIterator{`0})">
            <summary>
            
            </summary>
            <param name="it"></param>
            <returns></returns>
        </member>
        <member name="P:NStl.Iterators.Support.LinkedListIterator`1.Value">
            <summary>
            See base class.
            </summary>
        </member>
        <member name="P:NStl.Iterators.Support.LinkedListIterator`1.Node">
            <summary> 
            </summary>
        </member>
        <member name="T:NStl.Collections.PriorityQueue`1">
            <summary>
            <para>
            A PriorityQueue is a container that provides a restricted subset of 
            container functionality: it provides insertion of elements, and inspection 
            and removal of the top element. It is guaranteed that the top element is 
            the largest element in the PriorityQueue, where the function object 
            comp is used for comparisons. 
            </para>
            <para>
            As the PriorityQueue is internally organized as a heap, it does only 
            allow readonly iteration through its elements to avoid disturbance of the heap structure.
            </para>
            </summary>
            <typeparam name="T"></typeparam>
            <remarks>
            A heap is a particular way of ordering the elements in a range of <see cref="T:NStl.Iterators.IRandomAccessIterator`1"/>s [f, l). 
            The reason heaps are useful (especially for sorting, or as priority queues) is that they satisfy 
            two important properties. First, the value of f is the largest element in the heap. Second, 
            it is possible to add an element to a heap, 
            or to remove the first value, in logarithmic time. Internally, a heap is a tree represented as 
            a sequential range. The tree is constructed so that that each node is less than or equal to its parent node.
            </remarks>
        </member>
        <member name="M:NStl.Collections.PriorityQueue`1.#ctor(NStl.IBinaryFunction{`0,`0,System.Boolean})">
            <summary>
            Constructs an empty PriorityQueue.
            </summary>
            <param name="comp">
            <see cref="T:NStl.IBinaryFunction`3"/> that is used to maintain the heap structure.
            </param>
        </member>
        <member name="M:NStl.Collections.PriorityQueue`1.#ctor(System.Collections.Generic.IComparer{`0})">
            <summary>
            Constructs an empty PriorityQueue.
            </summary>
            <param name="comp">
            <see cref="T:System.Collections.Generic.IComparer`1"/> implementation that is used to maintain the heap structure.
            </param>
        </member>
        <member name="M:NStl.Collections.PriorityQueue`1.#ctor(System.Collections.IComparer)">
            <summary>
            Constructs an empty PriorityQueue.
            </summary>
            <param name="comp">
            <see cref="T:System.Collections.IComparer"/> implementation that is used to maintain the heap structure.
            </param>
        </member>
        <member name="M:NStl.Collections.PriorityQueue`1.#ctor(NStl.IBinaryFunction{`0,`0,System.Boolean},`0[])">
            <summary>
            Constructs a PriorityQueue containing the content of the passed in range. 
            The values are copied, the complexity is linear, at most 3*items.Length comparisons.
            </summary>
            <param name="comp">
            The <see cref="T:NStl.IBinaryFunction`3"/> that is used to maintain the heap structure.
            </param>
            <param name="items">The content to be copied into the PriorityQueue.</param>
        </member>
        <member name="M:NStl.Collections.PriorityQueue`1.#ctor(NStl.IBinaryFunction{`0,`0,System.Boolean},System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Constructs a PriorityQueue containing the content of the passed in range. 
            The values are copied, the complexity is linear, at most 3*CountOf(items) comparisons.
            </summary>
            <param name="comp">
            The <see cref="T:NStl.IBinaryFunction`3"/> that is used to maintain the heap structure.
            </param>
            <param name="items">The content to be copied into the PriorityQueue.</param>
        </member>
        <member name="M:NStl.Collections.PriorityQueue`1.#ctor(System.Collections.Generic.IComparer{`0},System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Constructs a PriorityQueue containing the content of the passed in range. 
            The values are copied, the complexity is linear, at most 3*ContOf(items) comparisons.
            </summary>
            <param name="comp">
            A <see cref="T:System.Collections.Generic.IComparer`1"/> implementation that is used to maintain the heap structure.
            </param>
            <param name="items">The content to be copied into the PriorityQueue.</param>
        </member>
        <member name="M:NStl.Collections.PriorityQueue`1.#ctor(System.Collections.IComparer,System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Constructs a PriorityQueue containing the content of the passed in range. 
            The values are copied, the complexity is linear, at most 3*CountOf(items) comparisons.
            </summary>
            <param name="comp">
            A <see cref="T:System.Collections.IComparer"/> implementation that is used to maintain the heap structure.
            </param>
            <param name="items">The content to be copied into the PriorityQueue.</param>
        </member>
        <member name="M:NStl.Collections.PriorityQueue`1.Enqueue(`0)">
            <summary>
            Inserts an item into the PriorityQueue. The complexity is logarithmic.
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:NStl.Collections.PriorityQueue`1.End">
            <summary>
            Returns a read only iterator pointing one past the final element of the PriorityQueue.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Collections.PriorityQueue`1.Begin">
            <summary>
            Returns a read only iterator pointing on the first element of the PriorityQueue.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Collections.PriorityQueue`1.Dequeue">
            <summary>
            Dequeues the element with the highest priority of the PriorityQueue. The complexity is logarithmic.
            </summary>
            <returns>The element with the highest priority.</returns>
            <exception cref="T:System.InvalidOperationException">
            Thrown when the PriorityQueue is empty, that is when IsEmpty return true.
            </exception>
        </member>
        <member name="M:NStl.Collections.PriorityQueue`1.Clear">
            <summary>
            Clears the content of the PriorityQueue.
            </summary>
        </member>
        <member name="M:NStl.Collections.PriorityQueue`1.Contains(`0)">
            <summary>
            Returns true, if the elemet is contained in the PriorityQueue. The performance is linear.
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.Collections.PriorityQueue`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copies the content of the PriorityQueue into the passed in array starting at the given index.
            </summary>
            <param name="array"></param>
            <param name="index"></param>
        </member>
        <member name="M:NStl.Collections.PriorityQueue`1.ToArray">
            <summary>
            Returns an array containing the content of this PriorityQueue.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Collections.PriorityQueue`1.Remove(`0)">
            <summary>
            Removes an element form the PriorityQueue.
            </summary>
            <param name="item"></param>
            <returns>True, if a value was removed, false if no value was found.</returns>
            <remarks>
            Removing an element destroys the internal heap structure and forces the heap to be rebuilded.
            Therefore the complexity is a combination of the linear search for the remove operation and the
            rebuild of the heap: c = (last-first) + 3 * (last-first).
            </remarks>
        </member>
        <member name="M:NStl.Collections.PriorityQueue`1.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Deserialization constructor.
            </summary>
            <param name="info"></param>
            <param name="ctxt"></param>
        </member>
        <member name="M:NStl.Collections.PriorityQueue`1.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            See <see cref="M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)"/> for details.
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="P:NStl.Collections.PriorityQueue`1.Peek">
            <summary>
            Returns a the element at the top of the PriorityQueue. The element at the top 
            is guaranteed to be the largest element in the priority queue, as determined 
            by the comparison function. That is, for every other element x in the PriorityQueue, 
            comp.Execute(q.Peek, x) is false.
            </summary>
            <exception cref="T:System.InvalidOperationException">
            Thrown when the PriorityQueue is empty, that is when IsEmpty returns true.
            </exception>
        </member>
        <member name="P:NStl.Collections.PriorityQueue`1.Empty">
            <summary>
            Returns true, when the PriorityQueue is empty.
            </summary>
        </member>
        <member name="P:NStl.Collections.PriorityQueue`1.Count">
            <summary>
            Thec length of the PriorityQueue.
            </summary>
        </member>
        <member name="P:NStl.Collections.PriorityQueue`1.IsSynchronized">
            <summary>
            Returns if the PriorityQueue is syncronized.
            </summary>
        </member>
        <member name="P:NStl.Collections.PriorityQueue`1.SyncRoot">
            <summary>
            Returns an object the can be used o syncronize external access to the PriorityQueue.
            </summary>
        </member>
        <member name="T:NStl.Arithmetic.Divide">
            <summary>
            Represents the operation of dividing two elements.
            </summary>
        </member>
        <member name="M:NStl.Arithmetic.Divide.Decimal">
            <summary>
            Creates a functor that lets you divide two <see cref="T:System.Decimal"/> types.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Arithmetic.Divide.Int32">
            <summary>
            Creates a functor that lets you divide two <see cref="T:System.Int32"/> types.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Arithmetic.Divide.Int64">
            <summary>
            Creates a functor that lets you divide two <see cref="T:System.Int64"/> types.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Arithmetic.Divide.Int16">
            <summary>
            Creates a functor that lets you divide two <see cref="T:System.Int16"/> types.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Arithmetic.Divide.Float">
            <summary>
            Creates a functor that lets you divide two <see cref="T:System.Single"/> types.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Arithmetic.Divide.Double">
            <summary>
            Creates a functor that lets you divide two <see cref="T:System.Double"/> types.
            </summary>
            <returns></returns>
        </member>
        <member name="T:NStl.IUnaryPredicate`1">
            <summary>
            When implemented, it represents a unary predicate.
            </summary>
            <typeparam name="Param"></typeparam>
        </member>
        <member name="T:NStl.Linq.DictionaryExtension">
            <summary>
            Provides a set of static (Shared in Visual Basic) methods 
            for querying objects that implement <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </summary>
        </member>
        <member name="M:NStl.Linq.DictionaryExtension.Cast``2(System.Collections.IDictionary)">
            <summary>
            Converts the elements of an <see cref="T:System.Collections.IDictionary"/> to the specified type.
            </summary>
            <typeparam name="Key"></typeparam>
            <typeparam name="Value"></typeparam>
            <param name="dictionary"></param>
            <returns></returns>
            <remarks>
            This method returns an adapter object, so calling this methond is very efficient.
            </remarks>
        </member>
        <member name="M:NStl.Linq.DictionaryExtension.AddInserter(System.Collections.IDictionary)">
            <summary>
            returns an <see cref="T:NStl.Iterators.IOutputIterator`1"/> implementation.
            </summary>
            <param name="dictionary"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.Linq.DictionaryExtension.Begin``2(System.Collections.Generic.IDictionary{``0,``1})">
            <summary>
            Returns an <see cref="T:NStl.Iterators.Support.DictionaryIterator`2"/> pointing to 
            the first element of the range.
            </summary>
            <param name="e">The range.</param>
            <returns></returns>
        </member>
        <member name="M:NStl.Linq.DictionaryExtension.End``2(System.Collections.Generic.IDictionary{``0,``1})">
            <summary>
            Returns an <see cref="T:NStl.Iterators.Support.DictionaryIterator`2"/> pointing 
            one past the final element of the range.
            </summary>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="T:NStl.Linq.AlgorithmExtension.AlgorithmExtension">
            <summary>
             Provides the NSTL algorithms as a set of static 
             (Shared in Visual Basic) extension methods for standard .NET and
             NSTL containers.
            </summary>
        </member>
        <member name="M:NStl.Linq.AlgorithmExtension.AlgorithmExtension.Accumulate``1(System.Collections.Generic.IEnumerable{``0},``0,NStl.IBinaryFunction{``0,``0,``0})">
            <summary>
            <para>
            Accumulate is a generalization of summation: 
            it computes the sum (or some other binary operation)
            of init and all of the elements in the input range. 
            </para>
            <para>
            The complexity is linear. Exactly range.Count() 
            invocations of the binary operation.
            </para>
            </summary>
            <typeparam name="T"></typeparam>
            <param name="range">The input range.</param>
            <param name="init">The initial value that every element is added to.</param>
            <param name="binaryFunction">
            A functor that combines two elements to one output.
            </param>
            <returns>
            The sum of all items in the range.
            </returns>
            <remarks>
            There are several reasons why it is important that accumulate 
            starts with the value init. One of the most basic is that this 
            allows Accumulate to have a well-defined result even 
            if [first, last) is an empty range: if it is empty, the 
            return value is init. If you want to find the sum of all 
            of the elements in [first, last), you can just pass 0 as init.
            </remarks>
        </member>
        <member name="M:NStl.Linq.AlgorithmExtension.AlgorithmExtension.Accumulate``1(System.Collections.Generic.IEnumerable{``0},``0,System.Func{``0,``0,``0})">
            <summary>
            <para>
            Accumulate is a generalization of summation: 
            it computes the sum (or some other binary operation)
            of init and all of the elements in the input range. 
            </para>
            <para>
            The complexity is linear. Exactly range.Count() 
            invocations of the binary operation.
            </para>
            </summary>
            <typeparam name="T"></typeparam>
            <param name="range">The input range.</param>
            <param name="init">The initial value that every element is added to.</param>
            <param name="binaryFunction">
            A functor that combines two elements to one output.
            </param>
            <returns>
            The sum of all items in the range.
            </returns>
            <remarks>
            There are several reasons why it is important that accumulate 
            starts with the value init. One of the most basic is that this 
            allows Accumulate to have a well-defined result even 
            if [first, last) is an empty range: if it is empty, the 
            return value is init. If you want to find the sum of all 
            of the elements in [first, last), you can just pass 0 as init.
            </remarks>
        </member>
        <member name="T:NStl.IBinaryVoidFunction`2">
            <summary>
            When implemented, it represents a binary void function.
            </summary>
            <typeparam name="Param1"></typeparam>
            <typeparam name="Param2"></typeparam>
        </member>
        <member name="T:NStl.Collections.Private.RbTreeNode`1">
            <summary>
            The node of the RBtree. This is a straight port from the SGI tree class.
            No reorganisation, no nicer interfaces. As this is the workhorse for four
            containers and I'm definitively not a tree specialist, I wanted to stay as
            close to the original as possible :-),so that I'm able to debug the C++
            and the .NET implementation parallel
            </summary>
        </member>
        <member name="M:NStl.Collections.Private.RbTreeNode`1.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            See <see cref="M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)"/> for details.
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="T:NStl.Collections.Private.RbTreeIterator`1">
            <summary>
            The tree iterator
            </summary>
        </member>
        <member name="T:NStl.Collections.Private.RbTree`2">
            <summary>
            The Tree! 
            </summary>
        </member>
        <member name="M:NStl.Collections.Private.RbTree`2.#ctor(NStl.IBinaryFunction{`0,`0,System.Boolean},NStl.IUnaryFunction{`1,`0})">
            <summary>
            
            </summary>
            <param name="__comp"></param>
            <param name="__keyof"></param>
        </member>
        <member name="M:NStl.Collections.Private.RbTree`2.__black_count(NStl.Collections.Private.RbTreeNode{`1},NStl.Collections.Private.RbTreeNode{`1})">
            <summary>
            default ctor, initialzes an empty tree using func.less as
            the comparison functor
            </summary>
        </member>
        <member name="M:NStl.Collections.Private.RbTree`2.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            See <see cref="M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)"/> for details.
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="T:NStl.Collection2ReadOnlyCollectionTAdapter`1">
            <summary>
            Weak readonly collection adaptor.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:NStl.Collections.Private.FixedSizeInt32.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            See <see cref="M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)"/> for details.
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="T:NStl.Collections.HashMultiMap`2">
            <summary>
            HashMultiMap is a Hashed Associative Container that associates objects of 
            type Key with objects of type Data. HashMultiMap is a Pair Associative 
            Container, meaning that its value type is <see cref="T:System.Collections.Generic.KeyValuePair`2"/>. 
            It is also a Multiple Associative Container, meaning that there is no limit  
            on the number of elements with the same key.
            </summary>
            <typeparam name="Key"></typeparam>
            <typeparam name="Value"></typeparam>
        </member>
        <member name="M:NStl.Collections.HashMultiMap`2.#ctor(System.Int32,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Construct an empty container with an initial bugffer size and the provided 
            <see cref="T:System.Collections.Generic.IEqualityComparer`1"/>implemntation.
            </summary>
            <param name="initialBuffer"></param>
            <param name="hashStrategy"></param>
        </member>
        <member name="M:NStl.Collections.HashMultiMap`2.#ctor">
            <summary>
            Constructs an empty container.
            </summary>
        </member>
        <member name="M:NStl.Collections.HashMultiMap`2.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}})">
            <summary>
            Constructs the container and copies the passed in range into it.
            </summary>
            <param name="src"></param>
        </member>
        <member name="M:NStl.Collections.HashMultiMap`2.#ctor(System.Collections.Generic.KeyValuePair{`0,`1}[])">
            <summary>
            Constructs the container and copies the passed in range into it.
            </summary>
            <param name="src"></param>
        </member>
        <member name="M:NStl.Collections.HashMultiMap`2.#ctor(System.Collections.IEnumerable)">
            <summary>
            Constructs the container and copies the passed in range into it.
            </summary>
            <param name="src"></param>
        </member>
        <member name="M:NStl.Collections.HashMultiMap`2.#ctor(NStl.Iterators.IInputIterator{System.Collections.Generic.KeyValuePair{`0,`1}},NStl.Iterators.IInputIterator{System.Collections.Generic.KeyValuePair{`0,`1}})">
            <summary>
            Constructs the container and copies the passed in range into it.
            </summary>
            <param name="first"></param>
            <param name="last"></param>
        </member>
        <member name="M:NStl.Collections.HashMultiMap`2.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Deserialization constructor.
            </summary>
            <param name="info"></param>
            <param name="ctxt"></param>
        </member>
        <member name="M:NStl.Collections.HashMultiMap`2.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            See <see cref="M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)"/> for details.
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="M:NStl.Collections.HashMultiMap`2.Begin">
            <summary>
            Returns an iterator that points to the first element of the range.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Collections.HashMultiMap`2.End">
            <summary>
            Returns an iterator that points to one past the final element of the range.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Collections.HashMultiMap`2.Insert(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Inserts the item into the container.
            </summary>
            <param name="item">The item to be inserted.</param>
            <returns>An iterator pointing to the inserted item.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when item.Key is null.</exception>
        </member>
        <member name="M:NStl.Collections.HashMultiMap`2.Insert(`0,`1)">
            <summary>
            Inserts the item into the container.
            </summary>
            <param name="key">The key to be inserted.</param>
            <param name="value">The value to be associated with the key.</param>
            <returns>An iterator pointing to the inserted item.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when the key is null.</exception>
        </member>
        <member name="M:NStl.Collections.HashMultiMap`2.Insert(NStl.Iterators.IInputIterator{System.Collections.Generic.KeyValuePair{`0,`1}},NStl.Iterators.IInputIterator{System.Collections.Generic.KeyValuePair{`0,`1}})">
            <summary>
            Inserts a range of items int this container.
            </summary>
            <param name="first">
            An <see cref="T:NStl.Iterators.IInputIterator`1"/> implementation pointing 
            to the first element to be inserted.
            </param>
            <param name="last">
            An <see cref="T:NStl.Iterators.IInputIterator`1"/> implementation pointing 
            one past the element to be inserted.
            </param>
            <exception cref="T:System.ArgumentNullException">Thrown when the first or last is null.</exception>
        </member>
        <member name="M:NStl.Collections.HashMultiMap`2.Insert(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}})">
            <summary>
            Inserts a range of items int this container.
            </summary>
            <param name="range">The range to be inserted.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when the range is null.</exception>
        </member>
        <member name="M:NStl.Collections.HashMultiMap`2.Find(`0)">
            <summary>
            Looks up the value for a given key.
            </summary>
            <param name="key"></param>
            <returns>
            An iterator pointing to the found value or the end iterator if the key
            is not present.
            </returns>
            <remarks>
            If you wish to find all values associated with the key, use
            <see cref="M:NStl.Collections.HashMultiMap`2.EqualRange(`0)"/> instead.
            </remarks>
            <exception cref="T:System.ArgumentNullException">Thrown when key is null.</exception>
        </member>
        <member name="M:NStl.Collections.HashMultiMap`2.Erase(`0)">
            <summary>
            Erases all values associated with a given key.
            </summary>
            <param name="key"></param>
            <returns>The amount of erased values.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when key is null.</exception>
        </member>
        <member name="M:NStl.Collections.HashMultiMap`2.Erase(NStl.Collections.HashMultiMap{`0,`1}.Iterator)">
            <summary>
            Erases the value at the position the iterator points to.
            </summary>
            <param name="where">An iterator pointing at the element to be erased.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when the iterator is null.</exception>
            <exception cref="T:NStl.Exceptions.NotTheSameInstanceException">Thrown when the iterator points to another range.</exception>
            <exception cref="T:NStl.Exceptions.EndIteratorIsNotAValidInputException">Thrown when the iterator is the end iterator.</exception>
        </member>
        <member name="M:NStl.Collections.HashMultiMap`2.Erase(NStl.Collections.HashMultiMap{`0,`1}.Iterator,NStl.Collections.HashMultiMap{`0,`1}.Iterator)">
            <summary>
            Erases a range of elements from the container.
            </summary>
            <param name="first">An iterator pointing on the first element to be erased.</param>
            <param name="last">An iterator pointing one past the final element to be erased.</param>
            <exception cref="T:System.ArgumentNullException">Thrown when one of the iterators is null.</exception>
        </member>
        <member name="M:NStl.Collections.HashMultiMap`2.CountOf(`0)">
            <summary>
            Counts the values associated with a key.
            </summary>
            <param name="key">The key in question.</param>
            <returns>The amount of values associated with the key.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when key is null.</exception>
            <remarks>This is a linear operation that depends on count of values associated with the key.</remarks>
        </member>
        <member name="M:NStl.Collections.HashMultiMap`2.EqualRange(`0)">
            <summary>
            Finds a range containing all elements associated with a given key.
            </summary>
            <param name="key"></param>
            <returns>
            The returned object is a NSTL range and also implements 
            <see cref="T:System.Collections.Generic.IEnumerable`1"/>.
            </returns>
        </member>
        <member name="M:NStl.Collections.HashMultiMap`2.ToArray">
            <summary>
            Copies the content of this container into an array.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Collections.HashMultiMap`2.CopyTo(System.Collections.Generic.KeyValuePair{`0,`1}[],System.Int32)">
            <summary>
            Copies the content of this container into a given array.
            </summary>
            <param name="array"></param>
            <param name="index"></param>
        </member>
        <member name="M:NStl.Collections.HashMultiMap`2.Clear">
            <summary>
            Clears the containers content.
            </summary>
        </member>
        <member name="P:NStl.Collections.HashMultiMap`2.Count">
            <summary>
            The amount of entries in the container.
            </summary>
        </member>
        <member name="P:NStl.Collections.HashMultiMap`2.Empty">
            <summary>
            True, when the container is empty
            </summary>
        </member>
        <member name="P:NStl.Collections.HashMultiMap`2.Item(`0)">
            <summary>
            Accesses the values by a given key
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="T:NStl.Collections.HashMultiMap`2.Iterator">
            <summary>
            The iterator of the <see cref="T:NStl.Collections.HashMultiMap`2"/>.
            </summary>
        </member>
        <member name="M:NStl.Collections.HashMultiMap`2.Iterator.PreIncrement">
            <summary>
            See <see cref="M:NStl.Iterators.IInputIterator`1.PreIncrement"/> for more information.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Collections.HashMultiMap`2.Iterator.Clone">
            <summary>
            See <see cref="M:NStl.Iterators.IIterator`1.Clone"/> for more information.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Collections.HashMultiMap`2.Iterator.Equals(NStl.Iterators.Support.EquatableIterator{System.Collections.Generic.KeyValuePair{`0,`1}})">
            <summary>
            See <see cref="M:System.Object.Equals(System.Object)"/> for details.
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.Collections.HashMultiMap`2.Iterator.HashCode">
            <summary>
            See <see cref="M:System.Object.GetHashCode"/> for details.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Collections.HashMultiMap`2.Iterator.op_Increment(NStl.Collections.HashMultiMap{`0,`1}.Iterator)">
            <summary>
            
            </summary>
            <param name="it"></param>
            <returns></returns>
        </member>
        <member name="P:NStl.Collections.HashMultiMap`2.Iterator.Value">
            <summary>
            See <see cref="P:NStl.Iterators.IInputIterator`1.Value"/> for more information.
            </summary>
        </member>
        <member name="T:NStl.Iterators.Support.DictionaryIterator`2">
            <summary>
            An Iterator for <see cref="T:System.Collections.Generic.IDictionary`2"/> implementations.
            </summary>
            <typeparam name="K"></typeparam>
            <typeparam name="V"></typeparam>
        </member>
        <member name="T:NStl.Iterators.Support.EnumerableIterator`1">
            <summary>
            Iterator wrapper for the .NET <see cref="T:System.Collections.Generic.IEnumerable`1"/> interface. 
            </summary>
            <remarks>
            This is a very thin wrapper and should be used with care and for single pass algorithms only.
            </remarks>
        </member>
        <member name="M:NStl.Iterators.Support.EnumerableIterator`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary></summary>
        </member>
        <member name="M:NStl.Iterators.Support.EnumerableIterator`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Boolean)">
            <summary>Creates an end iterator!</summary>
        </member>
        <member name="M:NStl.Iterators.Support.EnumerableIterator`1.PreIncrement">
            <summary>
            See <see cref="M:NStl.Iterators.IInputIterator`1.PreIncrement"/> for details.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Iterators.Support.EnumerableIterator`1.Clone">
            <summary>
            See <see cref="M:NStl.Iterators.IIterator`1.Clone"/> for details.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Iterators.Support.EnumerableIterator`1.Equals(NStl.Iterators.Support.EquatableIterator{`0})">
            <summary>
            
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.Iterators.Support.EnumerableIterator`1.HashCode">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="P:NStl.Iterators.Support.EnumerableIterator`1.Value">
            <summary>
            See <see cref="P:NStl.Iterators.IInputIterator`1.Value"/> for details.
            </summary>
        </member>
        <member name="P:NStl.Iterators.Support.DictionaryIterator`2.Key">
            <summary>
            
            </summary>
        </member>
        <member name="P:NStl.Iterators.Support.DictionaryIterator`2.Data">
            <summary>
            
            </summary>
        </member>
        <member name="T:NStl.NullType">
            <summary>
            This class is meant to be used as a placeholder/dummy type on generic
            declarations, e.g. when no return type is needed.
            </summary>
        </member>
        <member name="M:NStl.BinaryNegate`2.#ctor(NStl.IBinaryFunction{`0,`1,System.Boolean})">
            <summary>
            ctor
            </summary>
            <param name="predicate">The binary function to be negated</param>
        </member>
        <member name="M:NStl.IsNull`1.NStl#IUnaryFunction{T@System#Boolean}#Execute(`0)">
            <summary>
            Implementation of the BinaryFunction interface. Returns TRUE, if  Arg
            is null/Nothing
            </summary>
            <param name="Arg"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.IsDefault`1.NStl#IUnaryFunction{T@System#Boolean}#Execute(`0)">
            <summary>
            Implementation of the BinaryFunction interface. Returns TRUE, if  Arg
            is null/Nothing
            </summary>
            <param name="Arg"></param>
            <returns></returns>
        </member>
        <member name="T:NStl.Collections.UniqueSet`1">
            <summary>
            UniqueSet is a Sorted Associative Container that stores objects of type T. 
            UniqueSet is a Simple Associative Container, meaning that its value type, as well as its key
            type, is T. It is also a Unique Associative Container, meaning that no two 
            elements are the same. uniqueset and multiset are particularly well suited to the set 
            algorithms Includes, SetUnion, SetIntersection, SetDifference, and 
            SetSymmetricDifference of the <see cref="T:NStl.Algorithm"/> class. The reason for this is twofold. 
            First, the uniqueset algorithms require their arguments to be sorted ranges, and, since 
            UniqueSet and MultiSet are Sorted Associative Containers, their elements are always sorted 
            in ascending order. Second, the output range of these algorithms is always 
            sorted, and inserting a sorted range into a uniqueset or multiset is a fast operation: 
            the Unique Sorted Associative Container and Multiple Sorted Associative Container 
            requirements guarantee that inserting a range takes only linear time if the range 
            is already sorted. UniqueSet has the important property that inserting a new element 
            into a UniqueSet does not invalidate iterators that point to existing elements. 
            Erasing an element from a set also does not invalidate any iterators, except, 
            of course, for iterators that actually point to the element that is being erased. 
            </summary>
            <remarks>
            This class represents the C++ std::set class. It has a slightly different
            name, because "set" is a keyword in C#.
            Default comparison expect that the values stored in the set implement ICompareable
            </remarks>
        </member>
        <member name="M:NStl.Collections.UniqueSet`1.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Deserialization contructor.
            </summary>
            <param name="info"></param>
            <param name="ctxt"></param>
        </member>
        <member name="M:NStl.Collections.UniqueSet`1.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            See <see cref="M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)"/> for details.
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="M:NStl.Collections.UniqueSet`1.#ctor(NStl.IBinaryFunction{`0,`0,System.Boolean})">
            <summary>
            Constructs an empty uniqueset using the provided comparison functor.
            </summary>
            <param name="comparison"></param>
        </member>
        <member name="M:NStl.Collections.UniqueSet`1.#ctor(NStl.IBinaryFunction{`0,`0,System.Boolean},NStl.Iterators.IInputIterator{`0},NStl.Iterators.IInputIterator{`0})">
            <summary>
            ctor, copies the passed in range into this set
            </summary>
            <param name="comparison">Comparison functor</param>
            <param name="first">The position of the first element to be copied to the set</param>
            <param name="last">The position just beyond the last element to be copied to the set</param>
        </member>
        <member name="M:NStl.Collections.UniqueSet`1.#ctor(NStl.IBinaryFunction{`0,`0,System.Boolean},System.Collections.Generic.IEnumerable{`0})">
            <summary>
            ctor, copies the passed in range into this set
            </summary>
            <param name="comparison">Comparison functor</param>
            <param name="list">The IEnumerable to be copied into this set</param>
        </member>
        <member name="M:NStl.Collections.UniqueSet`1.#ctor(NStl.IBinaryFunction{`0,`0,System.Boolean},System.Collections.IEnumerable)">
            <summary>
            ctor, copies the passed in range into this set
            </summary>
            <param name="comparison">Comparison functor</param>
            <param name="list">The IEnumerable to be copied into this set</param>
        </member>
        <member name="M:NStl.Collections.UniqueSet`1.#ctor(NStl.IBinaryFunction{`0,`0,System.Boolean},`0[])">
            <summary>
            ctor, copies the passed in range into this set
            </summary>
            <param name="comparison">Comparison functor</param>
            <param name="list">The parmeters to be copied into this set</param>
        </member>
        <member name="M:NStl.Collections.UniqueSet`1.Begin">
            <summary>
            Returns an iterator that addresses the first element in the set.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Collections.UniqueSet`1.End">
            <summary>
            Returns an iterator that addresses the location succeeding the last element in a set
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Collections.UniqueSet`1.RBegin">
            <summary>
            Returns an iterator addressing the first element in a reversed set
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Collections.UniqueSet`1.REnd">
            <summary>
            Returns an iterator that points to the position past the last element in a reversed set
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Collections.UniqueSet`1.Insert(`0)">
            <summary>
            Insert an element into the uniqueset. 
            </summary>
            <param name="val">
            The value of an element to be inserted into the set
            </param>
            <returns>A pair of [iterator, bool]. The bool value will be true, if the
            set didn't contain the inserted value and the iterator will point to it. 
            Otherwise it will be false and the iterator will point to the end of the set</returns>
        </member>
        <member name="M:NStl.Collections.UniqueSet`1.Insert(NStl.Collections.UniqueSet{`0}.Iterator,`0)">
            <summary>
            Insert an element into the set
            </summary>
            <param name="where">
            The place to start searching for the correct point of insertion. 
            (Insertion can occur in amortized constant time, instead of logarithmic 
            time, if the insertion point immediately follows where.) 
            </param>
            <param name="val">
            The value of an element to be inserted into the set unless the set 
            already contains that element 
            </param>
            <returns>
            An iterator that points to the position where the new element was inserted or
            the end iterator in the case of a failure
            </returns>
        </member>
        <member name="M:NStl.Collections.UniqueSet`1.Insert(NStl.Iterators.IInputIterator{`0},NStl.Iterators.IInputIterator{`0})">
            <summary>
            Insert a range of elements into the uniqueset
            </summary>
            <param name="first">The position of the first element to be copied to the set</param>
            <param name="last">The position just beyond the last element to be copied to the set</param>
        </member>
        <member name="M:NStl.Collections.UniqueSet`1.Clear">
            <summary>
            Clears the set
            </summary>
        </member>
        <member name="M:NStl.Collections.UniqueSet`1.CountOf(`0)">
            <summary>
            Returns the number of values in a set
            </summary>
            <param name="key">The key of the elements to be matched 
            from the set.</param>
            <returns>
            1 if the set contains an element whose sort key matches the parameter key. 
            0 if the set does not contain an element with a matching key
            </returns>
        </member>
        <member name="M:NStl.Collections.UniqueSet`1.EqualRange(`0)">
            <summary>
            Returns two iterators that specify a sub range in the set where the values
            match the given key.
            </summary>
            <param name="key">
            The argument key to be searched.
            </param>
            <returns>
            A pair of iterators where the first is the lower_bound of the key and 
            the second is the UpperBound of the key.
            </returns>
        </member>
        <member name="M:NStl.Collections.UniqueSet`1.Erase(NStl.Collections.UniqueSet{`0}.Iterator)">
            <summary>
            Removes the element at the specified position
            </summary>
            <param name="where">Position of the element to be removed from the set</param>
            <remarks>
            The C++ STL set returns an valid iterator, however the SGI set does not. As I never quite
            saw the usefullness of the returned iterators, I stuck to the SGI implementation.
            If there is a strong wish from a lot of users, I will put the return value back in again.
            </remarks>
        </member>
        <member name="M:NStl.Collections.UniqueSet`1.Erase(NStl.Collections.UniqueSet{`0}.Iterator,NStl.Collections.UniqueSet{`0}.Iterator)">
            <summary>
            Removes a range of elements from the set
            </summary>
            <param name="first">Position of the first element removed from the set</param>
            <param name="last">Position just beyond the last element removed from the set</param>
            <remarks>
            The C++ STL set returns an valid iterator, however the SGI set does not. As I never quite
            saw the usefullness of the returned iterators, I stuck to the SGI implementation.
            If there is a strong wish from a lot of users, I will put the return value back in again.
            </remarks>
        </member>
        <member name="M:NStl.Collections.UniqueSet`1.Erase(`0)">
            <summary>
            Erases a specific value from the set
            </summary>
            <param name="val">The key of the elements to be removed from the set</param>
            <returns>The count of the erased elements. This is either 1 or 0</returns>
        </member>
        <member name="M:NStl.Collections.UniqueSet`1.EraseIf(NStl.Collections.UniqueSet{`0}.Iterator,NStl.Collections.UniqueSet{`0}.Iterator,NStl.IUnaryFunction{`0,System.Boolean})">
            <summary>
            Erases a range of elements from the uniqueset if they satisfy a predicate
            </summary>
            <param name="first">Position of the first element removed from the uniqueset</param>
            <param name="last">Position just beyond the last element removed from the uniqueset</param>
            <param name="predicate">A unary predicate that needs to be satisfied</param>
            <remarks>
            This method is not part of the C++ STL. Unexperienced C++ Developers often stumble
            over the fact, that you can't use the remove-erase idiom that works for sequence
            containers for associative sorted containers like a uniqueset. So this method is provided to
            avoid this glitch in the .NET world
            </remarks>
        </member>
        <member name="M:NStl.Collections.UniqueSet`1.EraseIf(NStl.IUnaryFunction{`0,System.Boolean})">
            <summary>
            Erases all elements from the uniqueset that satisfy a predicate
            </summary>
            <param name="predicate">A unary predicate that needs to be satisfied</param>
            <remarks>
            This method is not part of the C++ STL. Unexperienced C++ Developers often stumble
            over the fact, that you can't use the remove-erase idiom that works for sequence
            containers for associative sorted containers like a uniqueset. So this method is provided to
            avoid this glitch in the .NET world
            </remarks>
        </member>
        <member name="M:NStl.Collections.UniqueSet`1.Find(`0)">
            <summary>
            Finds the location of a specific element
            </summary>
            <param name="val">The element to be found using the internal comparison functor</param>
            <returns>An iterator pointing to the found value or the ned iterator if the value is
            not in the set</returns>
        </member>
        <member name="M:NStl.Collections.UniqueSet`1.LowerBound(`0)">
            <summary>
            Returns an iterator to the first element in a set with a key that is equal 
            to or less than a specified key
            </summary>
            <param name="val">The value to be found</param>
            <returns></returns>
            <remarks>Comparison is one by the internal comparison Predicate</remarks>
        </member>
        <member name="M:NStl.Collections.UniqueSet`1.UpperBound(`0)">
            <summary>
            Returns an iterator one past the first element in a set with a key that is 
            equal to or greater than a specified key
            </summary>
            <param name="val">The value to be found</param>
            <returns></returns>
        </member>
        <member name="M:NStl.Collections.UniqueSet`1.Swap(NStl.Collections.UniqueSet{`0})">
            <summary>
            Swaps the content of this set with the other set
            </summary>
            <param name="rhs"></param>
            <remarks>Extreme fast operation, as this is a buffer swap</remarks>
        </member>
        <member name="M:NStl.Collections.UniqueSet`1.ToArray">
            <summary>
            Copies the content of the container to an array.
            </summary>
        </member>
        <member name="M:NStl.Collections.UniqueSet`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copies the content of the container to an array.
            </summary>
            <param name="array"></param>
            <param name="arrayIndex"></param>
        </member>
        <member name="P:NStl.Collections.UniqueSet`1.Empty">
            <summary>
            Tests if a set is empty.
            </summary>
            <returns>true if the set is empty; false if the set is nonempty</returns>
        </member>
        <member name="P:NStl.Collections.UniqueSet`1.Count">
            <summary>
            Returns the number of elements in the set
            </summary>
            <returns></returns>
        </member>
        <member name="T:NStl.Collections.UniqueSet`1.Iterator">
            <summary>
            
            </summary>
        </member>
        <member name="M:NStl.Collections.UniqueSet`1.Iterator.op_Increment(NStl.Collections.UniqueSet{`0}.Iterator)">
            <summary>
            
            </summary>
            <param name="it"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.Collections.UniqueSet`1.Iterator.op_Decrement(NStl.Collections.UniqueSet{`0}.Iterator)">
            <summary>
            
            </summary>
            <param name="it"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.Collections.UniqueSet`1.Iterator.Clone">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="T:NStl.Arithmetic.Plus">
            <summary>
            Represents the operation of adding two elements.
            </summary>
        </member>
        <member name="M:NStl.Arithmetic.Plus.Decimal">
            <summary>
            Creates a functor that lets you add two <see cref="T:System.Decimal"/> types.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Arithmetic.Plus.Int32">
            <summary>
            Creates a functor that lets you add two <see cref="T:System.Int32"/> types.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Arithmetic.Plus.Int64">
            <summary>
            Creates a functor that lets you add two <see cref="T:System.Int64"/> types.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Arithmetic.Plus.Int16">
            <summary>
            Creates a functor that lets you add two <see cref="T:System.Int16"/> types.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Arithmetic.Plus.Float">
            <summary>
            Creates a functor that lets you add two <see cref="T:System.Single"/> types.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Arithmetic.Plus.Double">
            <summary>
            Creates a functor that lets you add two <see cref="T:System.Double"/> types.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Arithmetic.Plus.String">
            <summary>
            Creates a functor that lets you add two <see cref="T:System.String"/> types.
            </summary>
            <returns></returns>
        </member>
        <member name="T:NStl.SyntaxHelper.Project">
            <summary>
            A syntax helper that offers all projection functors of the NSTL.
            </summary>
        </member>
        <member name="M:NStl.SyntaxHelper.Project.FirstOfKeyValuePair``2">
            <summary>
            Returns a functor that will clone the first element for a KeyValuePair object.
            </summary>
            <typeparam name="Key"></typeparam>
            <typeparam name="Value"></typeparam>
            <returns></returns>
        </member>
        <member name="M:NStl.SyntaxHelper.Project.FirstOfDictionaryEntry``1">
            <summary>
            Returns a funcor that will clone the first value of a <see cref="T:System.Collections.DictionaryEntry"/>.
            </summary>
            <typeparam name="Key"></typeparam>
            <returns></returns>
        </member>
        <member name="M:NStl.SyntaxHelper.Project.SecondOfKeyValuePair``2">
            <summary>
            Returns a functor that will clone the second element for a KeyValuePair object.
            </summary>
            <typeparam name="Key"></typeparam>
            <typeparam name="Value"></typeparam>
            <returns></returns>
        </member>
        <member name="M:NStl.SyntaxHelper.Project.SecondOfDictionaryEntry``1">
            <summary>
            Returns a funcor that willclone the second element of a <see cref="T:System.Collections.DictionaryEntry"/>.
            </summary>
            <typeparam name="Value"></typeparam>
            <returns></returns>
        </member>
        <member name="M:NStl.SyntaxHelper.Project.Identity``1">
            <summary>
            Returns a unary function object that will simply return its argument.
            </summary>
            <returns></returns>
            <remarks>The identity functor is typically used as placeholder.</remarks>
        </member>
        <member name="T:NStl.SyntaxHelper.Logical">
            <summary>
            Syntax helper that offers all logical functors of the NSTL.
            </summary>
        </member>
        <member name="M:NStl.SyntaxHelper.Logical.Not2``2(NStl.IBinaryFunction{``0,``1,System.Boolean})">
            <summary>
            Returns the complement of a binary predicate.
            </summary>
            <param name="predicate">The binary predicate to be negated.</param>
            <returns>
            A binary predicate that is the negation of the binary predicate modified.
            </returns>
        </member>
        <member name="M:NStl.SyntaxHelper.Logical.Not1``1(NStl.IUnaryFunction{``0,System.Boolean})">
            <summary>
            Returns the complement of a unary predicate.
            </summary>
            <param name="predicate">The unary predicate to be negated.</param>
            <returns>A binary predicate that is the negation of the unary predicate modified.</returns>
        </member>
        <member name="M:NStl.SyntaxHelper.Logical.And">
            <summary>
            Creates a functor that will perform lhs AND rhs with the input parameters.
            </summary>
            <returns></returns>
            <remarks>
            Returns lhs AND rhs. If you want to use this functor to combine the output 
            from two other functors, have a look at <see cref="T:NStl.SyntaxHelper.Compose"/>.
            </remarks>
        </member>
        <member name="M:NStl.SyntaxHelper.Logical.Not">
            <summary>
            Creates a functor that will perform the negation of the passed in parameter.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.SyntaxHelper.Logical.Or">
            <summary>
            Creates a functor that will perform lhs || rhs of the passed in arguments.
            </summary>
            <returns></returns>
        </member>
        <member name="T:NStl.CompareAction">
            <summary>
            This enum is used to adapt a .NET <see cref="T:System.Collections.IComparer"/>/<see cref="T:System.Collections.Generic.IComparer`1"/> implementation
            to a comparison functor. It specifies how the comparer will 
            interpret the return value of the IComparer interface
            </summary>
        </member>
        <member name="F:NStl.CompareAction.Less">
            <summary>
            IComparer.Compare(lhs, rhs) &lt;  0
            </summary>
        </member>
        <member name="F:NStl.CompareAction.LessEqual">
            <summary>
            IComparer.Compare(lhs, rhs) &lt;=  0
            </summary>
        </member>
        <member name="F:NStl.CompareAction.Equal">
            <summary>
            IComparer.Compare(lhs, rhs) == 0
            </summary>
        </member>
        <member name="F:NStl.CompareAction.NotEqual">
            <summary>
            IComparer.Compare(lhs, rhs) !=  0
            </summary>
        </member>
        <member name="F:NStl.CompareAction.GreaterEqual">
            <summary>
            IComparer.Compare(lhs, rhs) &gt;= 0
            </summary>
        </member>
        <member name="F:NStl.CompareAction.Greater">
            <summary>
            IComparer.Compare(lhs, rhs) &gt; 0
            </summary>
        </member>
        <member name="T:NStl.Query.Sequence">
            <summary>
            Sequence contains all algorithms that will finally be replaced by or
            extend LINQ queries
            </summary>
        </member>
        <member name="M:NStl.Query.Sequence.Filter``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>
            Filters a given <see cref="T:System.Collections.Generic.IEnumerable`1"/> using a given predicate
            </summary>
            <typeparam name="T"></typeparam>
            <param name="source"></param>
            <param name="predicate"></param>
            <returns></returns>
            <remarks>Will be replaced by LINQ.</remarks>
        </member>
        <member name="T:NStl.Collections.DList`1">
            <summary>
            A DList is a doubly linked list. That is, it is a Sequence that supports both 
            forward and backward traversal, and (amortized) constant time insertion and 
            removal of elements at the beginning or the end, or in the middle. lists have 
            the important property that insertion and splicing do not invalidate iterators 
            to list elements, and that even removal invalidates only the iterators that 
            point to the elements that are removed. The ordering of iterators may be changed 
            (that is, bidirectional_iteratormight have a different predecessor or successor 
            after a list operation than it did before), but the iterators themselves will 
            not be invalidated or made to point to different elements unless that 
            invalidation or mutation is explicit. Note that singly linked lists, 
            which only support forward traversal, are also sometimes useful. If you do not 
            need backward traversal, then slist may be more efficient than list. 
            </summary>
            <remarks>
            <para>
            .NET 2.0 ships with a <see cref="T:System.Collections.Generic.LinkedList`1"/> that has the same functionality 
            as this class. However, as the <see cref="T:System.Collections.Generic.LinkedList`1"/> has to be used with the
            <see cref="T:NStl.NStlUtil"/> adapter functions, this class was left inside the NSTL, as 
            it provides integrated <see cref="T:NStl.Iterators.IBidirectionalIterator`1"/> implementation and
            is more "handy" to use with NSTL algorithms.
            </para>
            <para>
            As soon as extension methods will be available in C# and VB and allow to add the Begin() and End() 
            methods to existing classes, this collection will be obsolete.
            </para>
            </remarks>
        </member>
        <member name="T:NStl.IBackInsertableCollection`1">
            <summary>
            When implemented, this range can have objects added to its end and
            satisfies the <see cref="T:System.Collections.Generic.ICollection`1"/> interface.
            You can obtain an <see cref="T:NStl.Iterators.IOutputIterator`1"/>
            via <see cref="M:NStl.NStlUtil.BackInserter``1(NStl.IBackInsertableCollection{``0})"/>.
            </summary>
            <typeparam name="T"></typeparam>
            <remarks>
            Implement this class if you want to provide back inserting 
            capabilities via <see cref="M:NStl.NStlUtil.BackInserter``1(NStl.IBackInsertableCollection{``0})"/>
            and also implementb the <see cref="T:System.Collections.Generic.ICollection`1"/> interface.
            </remarks>
        </member>
        <member name="M:NStl.Collections.DList`1.#ctor">
            <summary>
            Constructs an empty container.
            </summary>
        </member>
        <member name="M:NStl.Collections.DList`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Construct the container and copies the content of the <see cref="T:System.Collections.Generic.IEnumerable`1"/>
            into it.
            </summary>
            <param name="list"></param>
        </member>
        <member name="M:NStl.Collections.DList`1.#ctor(System.Collections.IEnumerable)">
            <summary>
            Construct the container and copies the content of the <see cref="T:System.Collections.IEnumerable"/>
            into it.
            </summary>
            <param name="list"></param>
        </member>
        <member name="M:NStl.Collections.DList`1.#ctor(`0[])">
            <summary>
            Constructs the container and  copies the given parameters into it.
            </summary>
        </member>
        <member name="M:NStl.Collections.DList`1.#ctor(NStl.Iterators.IInputIterator{`0},NStl.Iterators.IInputIterator{`0})">
            <summary>
            Constructs the container and  copies the given range into it.
            </summary>
            <param name="first"></param>
            <param name="last"></param>
        </member>
        <member name="M:NStl.Collections.DList`1.#ctor(System.Int32)">
            <summary>
            Creates thec container with the given length.
            </summary>
            <param name="count"></param>
        </member>
        <member name="M:NStl.Collections.DList`1.#ctor(System.Int32,`0)">
            <summary>
            Creates the container of the given length, filling it with the passed in object
            </summary>
            <param name="count"></param>
            <param name="val"></param>
        </member>
        <member name="M:NStl.Collections.DList`1.Begin">
            <summary>
            Returns an iterator addressing the first element in a list
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Collections.DList`1.End">
            <summary>
            Returns an iterator that addresses the location succeeding the last element in a list
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Collections.DList`1.RBegin">
            <summary>
            Returns an iterator addressing the first element in a reversed list
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Collections.DList`1.REnd">
            <summary>
            Returns an iterator that addresses the location succeeding the last element in a reversed list
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Collections.DList`1.Insert(NStl.Collections.DList{`0}.Iterator,`0)">
            <summary>
            Inserts an element into the list at a specified position.
            </summary>
            <param name="where">
            The position in the target list where the first element is inserted.
            </param>
            <param name="val">The value of the element being inserted into the list.</param>
            <returns>
            The function returns an iterator that points to the position 
            where the new element was inserted into the list.
            </returns>
        </member>
        <member name="M:NStl.Collections.DList`1.Resize(System.Int32,`0)">
            <summary>
            Specifies a new size for a list
            </summary>
            <param name="newSize">The new size of the list</param>
            <param name="val">
            The value of the new elements to be added to the list if the new size is 
            larger that the original size
            </param>
        </member>
        <member name="M:NStl.Collections.DList`1.Resize(System.Int32)">
            <summary>
            Specifies a new size for a list
            </summary>
            <param name="newSize">The new size of the list</param>
        </member>
        <member name="M:NStl.Collections.DList`1.Insert(NStl.Collections.DList{`0}.Iterator,NStl.Iterators.IInputIterator{`0},NStl.Iterators.IInputIterator{`0})">
            <summary>
            Inserts a range of element into the list at a specified position
            </summary>
            <param name="where">
            The position in the target list where the first element is inserted
            </param>
            <param name="first">
            The position of the first element in the range of elements in the argument 
            list to be copied
            </param>
            <param name="last">
            The position of the first element beyond the range of elements in the 
            argument list to be copied
            </param>
        </member>
        <member name="M:NStl.Collections.DList`1.Insert(NStl.Collections.DList{`0}.Iterator,System.Int32,`0)">
            <summary>
            Inserts an n element into the list at a specified position
            </summary>
            <param name="where">
            The position in the target list where the first element is inserted
            </param>
            <param name="count">
            The number of elements being inserted into the list.
            </param>
            <param name="val">The value of the element being inserted into the list</param>
            <returns>
            The function returns an iterator that points to the position 
            where the new element was inserted into the list
            </returns>
            <remarks>Insert only works for forward iterators.</remarks>
        </member>
        <member name="M:NStl.Collections.DList`1.Assign(NStl.Iterators.IInputIterator{`0},NStl.Iterators.IInputIterator{`0})">
            <summary>
            Erases elements from a list and copies a new set of elements to a target list
            </summary>
            <param name="first">
            Position of the first element in the range of elements to be copied from 
            the argument range
            </param>
            <param name="last">
            Position of the first element just beyond the range of elements to be copied 
            from the argument range
            </param>
        </member>
        <member name="M:NStl.Collections.DList`1.Assign(System.Int32,`0)">
            <summary>
            Erases elements from a list and copies a new set of elements to a target list
            </summary>
            <param name="count">The number of copies of an element being inserted into the list</param>
            <param name="val">The value of the element being inserted into the list.</param>
        </member>
        <member name="M:NStl.Collections.DList`1.PushBack(`0)">
            <summary>
            Adds an element to the end of a list
            </summary>
            <param name="val">The element added to the end of the list</param>
        </member>
        <member name="M:NStl.Collections.DList`1.PushFront(`0)">
            <summary>
            Adds an element to the beginning of a list
            </summary>
            <param name="val">The element added to the beginning of the list</param>
        </member>
        <member name="M:NStl.Collections.DList`1.Back">
            <summary>
            Returns a reference to the last element of a list
            </summary>
            <returns>The last element of the list. If the list is empty, the 
            return value is undefined</returns>
        </member>
        <member name="M:NStl.Collections.DList`1.Front">
            <summary>
            Returns a reference to the first element of a list
            </summary>
            <returns>The first element of the list. If the list is empty, the 
            return value is undefined</returns>
        </member>
        <member name="M:NStl.Collections.DList`1.Clear">
            <summary>
            Erases all the elements of a list
            </summary>
        </member>
        <member name="M:NStl.Collections.DList`1.Erase(NStl.Collections.DList{`0}.Iterator,NStl.Collections.DList{`0}.Iterator)">
            <summary>
            Removes a range of elements in a list from specified positions
            </summary>
            <param name="first">Position of the first element removed from the list</param>
            <param name="last">Position just beyond the last element removed from the list</param>
            <returns>
            A bidirectional iterator that designates the first element remaining beyond any 
            elements removed, or a pointer to the end of the list if no such element exists
            </returns>
        </member>
        <member name="M:NStl.Collections.DList`1.Erase(NStl.Collections.DList{`0}.Iterator)">
            <summary>
            Removes an element in a list from specified positions
            </summary>
            <param name="where">Position of the element to be removed from the list</param>
            <returns>
            A bidirectional iterator that designates the first element remaining beyond any 
            elements removed, or a pointer to the end of the list if no such element exists
            </returns>
            <exception cref="T:NStl.Exceptions.ContainerEmptyException">Thrown when the DList is empty.</exception>
        </member>
        <member name="M:NStl.Collections.DList`1.PopFront">
            <summary>
            Deletes the element at the front of a list.
            </summary>
        </member>
        <member name="M:NStl.Collections.DList`1.PopBack">
            <summary>
            Deletes the element at the end of a list.
            </summary>
        </member>
        <member name="M:NStl.Collections.DList`1.Splice(NStl.Collections.DList{`0}.Iterator,NStl.Collections.DList{`0},NStl.Collections.DList{`0}.Iterator,NStl.Collections.DList{`0}.Iterator)">
            <summary>
            Removes elements from the argument list and inserts them into the target list.
            </summary>
            <param name="position">
            The position in the target list before which the elements of the argument list are to be inserted.
            </param>
            <param name="srcList">
            The argument list that is to be inserted into the target list
            </param>
            <param name="first">
            The first element in the range to be inserted from the argument list.
            </param>
            <param name="last">
            The first element beyond the range to be inserted from the argument list
            </param>
        </member>
        <member name="M:NStl.Collections.DList`1.Splice(NStl.Collections.DList{`0}.Iterator,NStl.Collections.DList{`0})">
            <summary>
            Removes elements from the argument list and inserts them into the target list.
            </summary>
            <param name="position">
            The position in the target list before which the elements of the argument list are to be inserted.
            </param>
            <param name="srcList">
            The argument list that is to be inserted into the target list
            </param>
        </member>
        <member name="M:NStl.Collections.DList`1.Splice(NStl.Collections.DList{`0}.Iterator,NStl.Collections.DList{`0},NStl.Collections.DList{`0}.Iterator)">
            <summary>
            Removes the element from the argument list and inserts it into the target list.
            </summary>
            <param name="position">
            The position in the target list before which the elements of the argument list are to be inserted.
            </param>
            <param name="srcList">
            The argument list that is to be inserted into the target list
            </param>
            <param name="from">
            The element in the range to be inserted from the argument list.
            </param>
        </member>
        <member name="M:NStl.Collections.DList`1.Swap(NStl.Collections.DList{`0})">
            <summary>
            Exchanges the elements of two lists.
            </summary>
            <param name="rhs"></param>
        </member>
        <member name="M:NStl.Collections.DList`1.ToArray">
            <summary>
            The content of this list copied to a native array.
            </summary>
        </member>
        <member name="M:NStl.Collections.DList`1.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Desirialization constuctor
            </summary>
            <param name="info"></param>
            <param name="ctxt"></param>
        </member>
        <member name="M:NStl.Collections.DList`1.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            See <see cref="M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)"/> for details.
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="P:NStl.Collections.DList`1.Count">
            <summary>
            The size of the list
            </summary>
            <returns></returns>
            <remarks>As this function will run through the whole list and count all elements,
            this can be a performance intensive operation for a large list. So if you
            just want to know whether the list is empty, use the list.empty member function
            which has a constant time performace</remarks>
        </member>
        <member name="P:NStl.Collections.DList`1.Empty">
            <summary>
            Test if the list is empty.
            </summary>
            <returns>TRUE, if the list is empty.</returns>
        </member>
        <member name="M:NStl.Collections.DList`1.ListNode.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            See <see cref="M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)"/> for details.
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="T:NStl.Collections.DList`1.Iterator">
            <summary>
            The itertor of the list
            </summary>
        </member>
        <member name="M:NStl.Collections.DList`1.Iterator.PreDecrement">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Collections.DList`1.Iterator.PreIncrement">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Collections.DList`1.Iterator.Clone">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Collections.DList`1.Iterator.Equals(NStl.Iterators.Support.EquatableIterator{`0})">
            <summary>
            
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.Collections.DList`1.Iterator.HashCode">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Collections.DList`1.Iterator.op_Increment(NStl.Collections.DList{`0}.Iterator)">
            <summary>
            
            </summary>
            <param name="it"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.Collections.DList`1.Iterator.op_Decrement(NStl.Collections.DList{`0}.Iterator)">
            <summary>
            
            </summary>
            <param name="it"></param>
            <returns></returns>
        </member>
        <member name="P:NStl.Collections.DList`1.Iterator.Value">
            <summary>
            
            </summary>
        </member>
        <member name="T:NStl.Linq.LinkedListExtension">
            <summary>
            Provides a set of static (Shared in Visual Basic) methods 
            for querying objects of type <see cref="T:System.Collections.Generic.LinkedList`1"/>.
            </summary>
        </member>
        <member name="M:NStl.Linq.LinkedListExtension.Begin``1(System.Collections.Generic.LinkedList{``0})">
            <summary>
            Creates a <see cref="T:NStl.Iterators.Support.LinkedListIterator`1"/> pointing to 
            the first element of the <see cref="T:System.Collections.Generic.LinkedList`1"/>.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.Linq.LinkedListExtension.End``1(System.Collections.Generic.LinkedList{``0})">
            <summary>
            Creates a <see cref="T:NStl.Iterators.Support.LinkedListIterator`1"/> pointing 
            one past the last element of the <see cref="T:System.Collections.Generic.LinkedList`1"/>.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.Linq.LinkedListExtension.RBegin``1(System.Collections.Generic.LinkedList{``0})">
            <summary>
            Returns an iterator addressing the first element in a reversed list.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.Linq.LinkedListExtension.REnd``1(System.Collections.Generic.LinkedList{``0})">
            <summary>
            Returns an iterator that addresses the location succeeding the last element in a reversed list.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.Linq.LinkedListExtension.Resize``1(System.Collections.Generic.LinkedList{``0},System.Int32,``0)">
            <summary>
            This method lets you specify the new size of the list. If the
            list is longer, it will be trimmed. If it is shorter, it will be filled with val.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="newSize">The new size of the list.</param>
            <param name="val">The value that is used to fill the lis if needed.</param>
        </member>
        <member name="M:NStl.Linq.LinkedListExtension.Resize``1(System.Collections.Generic.LinkedList{``0},System.Int32)">
            <summary>
            This method lets you specify the new size of the list. If the
            list is longer, it will be trimmed. If it is shorter, it will be filled with default(T).
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="newSize">The new size of the list.</param>
        </member>
        <member name="M:NStl.Linq.LinkedListExtension.Remove``1(System.Collections.Generic.LinkedList{``0},NStl.Iterators.Support.LinkedListIterator{``0},NStl.Iterators.Support.LinkedListIterator{``0})">
            <summary>
            Removes a range of elements in a list from specified positions.
            </summary>
            <param name="list"></param>
            <param name="first">Position of the first element removed from the list.</param>
            <param name="last">Position just beyond the last element removed from the list.</param>
            <returns>
            A bidirectional iterator that designates the first element remaining beyond any 
            elements removed, or a pointer to the end of the list if no such element exists.
            </returns>
        </member>
        <member name="M:NStl.Linq.LinkedListExtension.Insert``1(System.Collections.Generic.LinkedList{``0},NStl.Iterators.Support.LinkedListIterator{``0},NStl.Iterators.IInputIterator{``0},NStl.Iterators.IInputIterator{``0})">
            <summary>
            Inserts a range of element into the list at a specified position.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="where">
            The position in the target list where the first element is inserted.
            </param>
            <param name="first">
            The position of the first element in the range of elements in the argument 
            list to be copied
            </param>
            <param name="last">
            The position of the first element beyond the range of elements in the 
            argument list to be copied
            </param>
        </member>
        <member name="M:NStl.Linq.LinkedListExtension.Insert``1(System.Collections.Generic.LinkedList{``0},NStl.Iterators.Support.LinkedListIterator{``0},``0)">
            <summary>
            Inserts an element into the list at a specified position.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="where">
            The position in the target list where the first element is inserted.
            </param>
            <param name="val">The value of the element being inserted into the list.</param>
            <returns>
            The function returns an iterator that points to the position 
            where the new element was inserted into the list.
            </returns>
        </member>
        <member name="M:NStl.Linq.LinkedListExtension.Insert``1(System.Collections.Generic.LinkedList{``0},NStl.Iterators.Support.LinkedListIterator{``0},System.Int32,``0)">
            <summary>
            Inserts an n element into the list at a specified position.
            </summary>
            <param name="list"></param>
            <param name="where">
            The position in the target list where the first element is inserted
            </param>
            <param name="count">
            The number of elements being inserted into the list.
            </param>
            <param name="val">The value of the element being inserted into the list</param>
            <returns>
            The function returns an iterator that points to the position 
            where the new element was inserted into the list
            </returns>
            <remarks>Insert only works for forward iterators.</remarks>
        </member>
        <member name="M:NStl.Linq.LinkedListExtension.Remove``1(System.Collections.Generic.LinkedList{``0},NStl.Iterators.Support.LinkedListIterator{``0})">
            <summary>
            Removes an element in a list from specified positions.
            </summary>
            <param name="list"></param>
            <param name="where">Position of the element to be removed from the list.</param>
            <returns>
            A bidirectional iterator that designates the first element remaining beyond any 
            elements removed, or a pointer to the end of the list if no such element exists.
            </returns>
            <exception cref="T:NStl.Exceptions.ContainerEmptyException">Thrown when the DList is empty.</exception>
        </member>
        <member name="M:NStl.Linq.LinkedListExtension.InsertIterator``1(System.Collections.Generic.LinkedList{``0},NStl.Iterators.Support.LinkedListIterator{``0})">
            <summary>
            Creates an <see cref="T:NStl.Iterators.IOutputIterator`1"/> implementation
            that lets you insert values at the specified position.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="insertable"></param>
            <param name="where"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.Linq.LinkedListExtension.PopFirst``1(System.Collections.Generic.LinkedList{``0})">
            <summary>
            Deletes the element at the front of a list.
            </summary>
        </member>
        <member name="M:NStl.Linq.LinkedListExtension.PopLast``1(System.Collections.Generic.LinkedList{``0})">
            <summary>
            Deletes the element at the end of a list.
            </summary>
        </member>
        <member name="M:NStl.Linq.LinkedListExtension.AddLastInserter``1(System.Collections.Generic.LinkedList{``0})">
            <summary>
            Returns an <see cref="T:NStl.Iterators.IOutputIterator`1"/> implementation that adds
            values to the end of the sequence.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.Linq.LinkedListExtension.AddFirstInserter``1(System.Collections.Generic.LinkedList{``0})">
            <summary>
            Returns an <see cref="T:NStl.Iterators.IOutputIterator`1"/> implementation that adds
            values to the start of the sequence.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <returns></returns>
        </member>
        <member name="T:NStl.Linq.EnumerableExtension">
            <summary>
            Provides a set of static (Shared in Visual Basic) methods 
            for querying objects that implement <see cref="T:System.Collections.Generic.IEnumerable`1"/>.
            </summary>
        </member>
        <member name="M:NStl.Linq.EnumerableExtension.IsEmpty(System.Collections.IEnumerable)">
            <summary>
            Returns true, if the enumerable is empty, false otherwise.
            </summary>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.Linq.EnumerableExtension.Begin``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Returns an <see cref="T:NStl.Iterators.Support.EnumerableIterator`1"/> pointing to 
            the first element of the range.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="e">The range.</param>
            <returns></returns>
        </member>
        <member name="M:NStl.Linq.EnumerableExtension.End``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Returns an <see cref="T:NStl.Iterators.Support.EnumerableIterator`1"/> pointing 
            one past the final element of the range.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.Linq.EnumerableExtension.Begin``1(System.Collections.IEnumerable)">
            <summary>
            Returns an <see cref="T:NStl.Iterators.Support.EnumerableIterator`1"/> pointing to 
            the first element of the range.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="e">The range.</param>
            <returns></returns>
        </member>
        <member name="M:NStl.Linq.EnumerableExtension.End``1(System.Collections.IEnumerable)">
            <summary>
            Returns an <see cref="T:NStl.Iterators.Support.EnumerableIterator`1"/> pointing 
            one past the final element of the range.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.Linq.EnumerableExtension.Copy``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            This method simply creates a copy of the enumerable.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="src">The input range to be copied.</param>
            <returns>A copy of the input range.</returns>
        </member>
        <member name="M:NStl.Linq.EnumerableExtension.AsCollection(System.Collections.IEnumerable)">
            <summary>
            Returns an <see cref="T:System.Collections.ICollection"/> adapter for the enumerable.
            </summary>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="T:NStl.Linq.CollectionTExtension">
            <summary>
            Provides a set of static (Shared in Visual Basic) methods 
            for extending objects of type <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </summary>
        </member>
        <member name="M:NStl.Linq.CollectionTExtension.AddRange``1(System.Collections.Generic.ICollection{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Adds the elements of the specified enumerable to the collection.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="collection"></param>
            <param name="toAdd">The collection to be added.</param>
        </member>
        <member name="M:NStl.Linq.CollectionTExtension.AddRange``1(System.Collections.Generic.ICollection{``0},``0[])">
            <summary>
            Adds the elements  to the collection.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="collection"></param>
            <param name="toAdd">The collection to be added.</param>
        </member>
        <member name="M:NStl.Linq.CollectionTExtension.AddInserter``1(System.Collections.Generic.ICollection{``0})">
            <summary>
            Returns an iterator adapter that can be used as an output
            iterator. It simply adds items to the collection by calling <see cref="M:System.Collections.Generic.ICollection`1.Add(`0)"/>.
            </summary>
            <param name="l"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.Linq.CollectionTExtension.Weak``1(System.Collections.Generic.ICollection{``0})">
            <summary>
            Creates an adapter that allows to use a generic collectiona as its non generic counterpart.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <returns></returns>
            <remarks>
            This is a dangerous tool only suited to satisfy compatibility issues
            with older APIs.
            </remarks>
        </member>
        <member name="T:NStl.Iterators.Support.BidirectionalIteratorProxy`1">
            <summary>
            A proxy implementation for bidirectional iterators. It is intended to be used
            as an implementation base or for testing purposes.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:NStl.Iterators.Support.BidirectionalIteratorProxy`1.#ctor(NStl.Iterators.IBidirectionalIterator{`0})">
            <summary>
            
            </summary>
            <param name="innerIt"></param>
        </member>
        <member name="F:NStl.Iterators.Support.BidirectionalIteratorProxy`1.innerIt">
            <summary>
            
            </summary>
        </member>
        <member name="M:NStl.Iterators.Support.BidirectionalIteratorProxy`1.PreDecrement">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Iterators.Support.BidirectionalIteratorProxy`1.PreIncrement">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Iterators.Support.BidirectionalIteratorProxy`1.Clone">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Iterators.Support.BidirectionalIteratorProxy`1.Equals(NStl.Iterators.Support.EquatableIterator{`0})">
            <summary>
            
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.Iterators.Support.BidirectionalIteratorProxy`1.HashCode">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="P:NStl.Iterators.Support.BidirectionalIteratorProxy`1.Value">
            <summary>
            
            </summary>
        </member>
        <member name="P:NStl.Iterators.Support.BidirectionalIteratorProxy`1.InnerIt">
            <summary>
            
            </summary>
        </member>
        <member name="T:NStl.Iterators.Support.ForwardIteratorProxy`1">
            <summary>
            A proxy implementation for forward iterators. It is intended to be used
            as an implementation base or for testing purposes.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:NStl.Iterators.Support.ForwardIteratorProxy`1.#ctor(NStl.Iterators.IForwardIterator{`0})">
            <summary>
            
            </summary>
            <param name="innerIt"></param>
        </member>
        <member name="F:NStl.Iterators.Support.ForwardIteratorProxy`1.innerIt">
            <summary>
            
            </summary>
        </member>
        <member name="M:NStl.Iterators.Support.ForwardIteratorProxy`1.PreIncrement">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Iterators.Support.ForwardIteratorProxy`1.Clone">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Iterators.Support.ForwardIteratorProxy`1.Equals(NStl.Iterators.Support.EquatableIterator{`0})">
            <summary>
            
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.Iterators.Support.ForwardIteratorProxy`1.HashCode">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="P:NStl.Iterators.Support.ForwardIteratorProxy`1.Value">
            <summary>
            
            </summary>
        </member>
        <member name="P:NStl.Iterators.Support.ForwardIteratorProxy`1.InnerIt">
            <summary>
            
            </summary>
        </member>
        <member name="T:NStl.Iterators.Support.BidirectionalInputIteratorProxy`1">
            <summary>
            A proxy implementation for <see cref="T:NStl.Iterators.IBidirectionalInputIterator`1"/>. It is intended to be used
            as an implementation base or for testing purposes.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:NStl.Iterators.Support.BidirectionalInputIteratorProxy`1.Equals(NStl.Iterators.Support.EquatableIterator{`0})">
            <summary>
            
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.Iterators.Support.BidirectionalInputIteratorProxy`1.HashCode">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="T:NStl.Collections.HashSet`1">
            <summary>
            <para>
            HashSet is a Hashed Associative Container that stores objects of type Key. 
            HashSet is a Simple Associative Container, meaning that its value type, 
            as well as its key type, is Key. It is also a Unique Associative Container, 
            meaning that no two elements compare equal using a <see cref="T:System.Collections.Generic.IEqualityComparer`1"/>
            implementation.
            </para>
            <para>
            HashSet is useful in applications where it is important to be able to search 
            for an element quickly. If it is important for the elements to be in a 
            particular order, however, then <see cref="T:NStl.Collections.UniqueSet`1"/> is more appropriate. 
            </para>
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:NStl.Collections.HashSet`1.#ctor">
            <summary>
            Construct and empty container.
            </summary>
        </member>
        <member name="M:NStl.Collections.HashSet`1.#ctor(System.Int32,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Construct an empty container with the provided initial buffer size. The
            provided <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> is used for hashing and comparing.
            </summary>
            <param name="initalBuffer">The initial buffer size.</param>
            <param name="hashStrategy">The comparer to be used for hashing.</param>
        </member>
        <member name="M:NStl.Collections.HashSet`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Constructs the container and copies the provided range into it.
            </summary>
            <param name="src">The range to be copied.</param>
        </member>
        <member name="M:NStl.Collections.HashSet`1.#ctor(System.Collections.IEnumerable)">
            <summary>
            Constructs the container and copies the provided range into it.
            </summary>
            <param name="src">The rangeto be copied.</param>
        </member>
        <member name="M:NStl.Collections.HashSet`1.#ctor(NStl.Iterators.IInputIterator{`0},NStl.Iterators.IInputIterator{`0})">
            <summary>
            Constructs the container and copies the provided range into it.
            </summary>
            <param name="first">An iterator pointing to the first element of the range to be copied.</param>
            <param name="last">An iterator pointing one past the final element of the range to be copied.</param>
        </member>
        <member name="M:NStl.Collections.HashSet`1.#ctor(`0[])">
            <summary>
            Constructs the container and copies the provided items into it.
            </summary>
            <param name="items">The items to be copied</param>
        </member>
        <member name="M:NStl.Collections.HashSet`1.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Desirialization constuctor
            </summary>
            <param name="info"></param>
            <param name="ctxt"></param>
        </member>
        <member name="M:NStl.Collections.HashSet`1.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            See <see cref="M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)"/> for details.
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="M:NStl.Collections.HashSet`1.End">
            <summary>
            Returns an iterator pointing one past the final element of the range.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Collections.HashSet`1.Begin">
            <summary>
            Returns an iterator pointing to the first element of the range.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Collections.HashSet`1.Insert(`0)">
            <summary>
            Inserts the item into the container.
            </summary>
            <param name="item">The item to be inserted.</param>
            <returns>
            A <see cref="T:System.Collections.Generic.KeyValuePair`2"/> containing an iterator pointing
            to the inserted element and true if the element was not present
            in the container, false otherwise.
            </returns>
        </member>
        <member name="M:NStl.Collections.HashSet`1.Insert(NStl.Iterators.IInputIterator{`0},NStl.Iterators.IInputIterator{`0})">
            <summary>
            Inserts the given range into the container.
            </summary>
            <param name="first">
            An iterator pointing to the first element of the range to be inserted.
            </param>
            <param name="last">
            An iterator pointing one past teh final element of the range to be inserted.
            </param>
        </member>
        <member name="M:NStl.Collections.HashSet`1.Erase(`0)">
            <summary>
            Erases the iben item
            </summary>
            <param name="item">The item to be erased</param>
            <returns>True, if the item was in the container.</returns>
        </member>
        <member name="M:NStl.Collections.HashSet`1.Erase(NStl.Collections.HashSet{`0}.Iterator)">
            <summary>
            Erases the item at the specified position.
            </summary>
            <param name="where">An iterator pointing to the item to be erased.</param>
        </member>
        <member name="M:NStl.Collections.HashSet`1.Erase(NStl.Collections.HashSet{`0}.Iterator,NStl.Collections.HashSet{`0}.Iterator)">
            <summary>
            Erases a range of elements.
            </summary>
            <param name="first">
            An iterator pointing to the first element of the range to be erased.
            </param>
            <param name="last">
            An iterator pointing one past teh final element of the range to be erased.
            </param>
        </member>
        <member name="M:NStl.Collections.HashSet`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copies the content of this container into the passed in array.
            </summary>
            <param name="array">The copy target</param>
            <param name="index">The index of the target at which copying will start.</param>
        </member>
        <member name="M:NStl.Collections.HashSet`1.ToArray">
            <summary>
            Copies the content of this container into a newly created array.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Collections.HashSet`1.Find(`0)">
            <summary>
            Searches the given element.
            </summary>
            <param name="item">The element to be searched for.</param>
            <returns>An iterator pointing to the found element, or the end 
            iterator if the element is not inside the container.</returns>
        </member>
        <member name="M:NStl.Collections.HashSet`1.Clear">
            <summary>
            CLears the container.
            </summary>
        </member>
        <member name="M:NStl.Collections.HashSet`1.Swap(NStl.Collections.HashSet{`0})">
            <summary>
            Swaps ththis ontainers content with the others.
            </summary>
            <param name="rhs">The container to be swapped.</param>
            <remarks>This is a constant time operation!</remarks>
        </member>
        <member name="P:NStl.Collections.HashSet`1.Count">
            <summary>
            The amount of items in the container.
            </summary>
        </member>
        <member name="P:NStl.Collections.HashSet`1.Empty">
            <summary>
            True, if the container contains no elements.
            </summary>
        </member>
        <member name="T:NStl.Collections.HashSet`1.Iterator">
            <summary>
            The HashSet iterator
            </summary>
        </member>
        <member name="M:NStl.Collections.HashSet`1.Iterator.PreIncrement">
            <summary>
            See <see cref="M:NStl.Iterators.IInputIterator`1.PreIncrement"/> for more information.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Collections.HashSet`1.Iterator.Clone">
            <summary>
            See <see cref="M:NStl.Iterators.IIterator`1.Clone"/> for more information.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Collections.HashSet`1.Iterator.Equals(NStl.Iterators.Support.EquatableIterator{`0})">
            <summary>
            See <see cref="M:System.Object.Equals(System.Object)"/> for details.
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.Collections.HashSet`1.Iterator.HashCode">
            <summary>
            See <see cref="M:System.Object.GetHashCode"/> for details.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Collections.HashSet`1.Iterator.op_Increment(NStl.Collections.HashSet{`0}.Iterator)">
            <summary>
            Increments the iterator one step.
            </summary>
            <param name="it"></param>
            <returns></returns>
        </member>
        <member name="P:NStl.Collections.HashSet`1.Iterator.Value">
            <summary>
            See <see cref="P:NStl.Iterators.IInputIterator`1.Value"/> for more information.
            </summary>
        </member>
        <member name="T:NStl.Iterators.Private.RandomAccessReverseIterator`1">
            <summary>
            This class is an adaptor, that takes a random access iterator and 
            reverses its actions,: when incremented, the original iterator will be
            decremented and vice versa.
            </summary>
        </member>
        <member name="M:NStl.Iterators.Private.RandomAccessReverseIterator`1.#ctor(NStl.Iterators.IRandomAccessIterator{`0})">
            <summary>
            ctor, wraps another bidirectional iterator
            </summary>
            <param name="it"></param>
        </member>
        <member name="M:NStl.Iterators.Private.RandomAccessReverseIterator`1.Clone">
            <summary>
            clone implementtaion. returns a clomne of this iterator and the internal iterator
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Iterators.Private.RandomAccessReverseIterator`1.InnerIterator">
            <summary>
            The wrapped iterator
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Iterators.Private.RandomAccessReverseIterator`1.ExtractInnerIterator(NStl.Iterators.IIterator{`0})">
            <summary>
            Comparison
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.Iterators.Private.RandomAccessReverseIterator`1.Equals(NStl.Iterators.Support.EquatableIterator{`0})">
            <summary>
            
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.Iterators.Private.RandomAccessReverseIterator`1.Add(System.Int32)">
            <summary>
            
            </summary>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.Iterators.Private.RandomAccessReverseIterator`1.Diff(NStl.Iterators.IRandomAccessIterator{`0})">
            <summary>
            
            </summary>
            <param name="rhs"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.Iterators.Private.RandomAccessReverseIterator`1.Less(NStl.Iterators.IRandomAccessIterator{`0})">
            <summary>
            
            </summary>
            <param name="rhs"></param>
            <returns></returns>
        </member>
        <member name="P:NStl.Iterators.Private.RandomAccessReverseIterator`1.Value">
            <summary>
            Value access
            </summary>
        </member>
        <member name="T:NStl.Iterators.Private.ConsoleOutputIterator`1">
            <summary>
            Output iterator that prints the assigned values separated by the seperator
            using Console.Write(). Use the util.console_output function to obtain a correct
            initialized iterator
            </summary>
        </member>
        <member name="M:NStl.Iterators.Private.BidirectionalReverseIterator`1.InnerIterator">
            <summary>
            The wrapped iterator
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Iterators.Private.BidirectionalReverseIterator`1.Equals(NStl.Iterators.Support.EquatableIterator{`0})">
            <summary>
            
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="T:NStl.EqualTo`2">
            <summary>
            Compares two objects. It is expected that the objects 
            implement the IComparable interface.
            </summary>
        </member>
        <member name="M:NStl.EqualTo`2.NStl#IBinaryFunction{T@U@System#Boolean}#Execute(`0,`1)">
            <summary>
            Compares two objects using the IComparable interface
            </summary>
            <param name="lhs"></param>
            <param name="rhs"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.NotEqualTo`1.NStl#IBinaryFunction{T@T@System#Boolean}#Execute(`0,`0)">
            <summary>
            Compares two objects using the IComparable interface
            </summary>
            <param name="lhs"></param>
            <param name="rhs"></param>
            <returns></returns>
        </member>
        <member name="T:NStl.Less`1">
            <summary>
            Compares two objects. It is expected that the objects 
            implement the IComparable interface.
            </summary>
        </member>
        <member name="M:NStl.Less`1.NStl#IBinaryFunction{T@T@System#Boolean}#Execute(`0,`0)">
            <summary>
            Compares two objects using the IComparable interface
            </summary>
            <param name="lhs"></param>
            <param name="rhs"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.LessEqual`1.NStl#IBinaryFunction{T@T@System#Boolean}#Execute(`0,`0)">
            <summary>
            Compares two objects using the IComparable interface
            </summary>
            <param name="lhs"></param>
            <param name="rhs"></param>
            <returns></returns>
        </member>
        <member name="T:NStl.Greater`1">
            <summary>
            Compares two objects. It is expected that the objects 
            implement the IComparable interface.
            </summary>
        </member>
        <member name="M:NStl.Greater`1.NStl#IBinaryFunction{T@T@System#Boolean}#Execute(`0,`0)">
            <summary>
            Compares two objects using the IComparable interface
            </summary>
            <param name="lhs"></param>
            <param name="rhs"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.GreaterEqual`1.NStl#IBinaryFunction{T@T@System#Boolean}#Execute(`0,`0)">
            <summary>
            Compares two objects using the IComparable interface
            </summary>
            <param name="lhs"></param>
            <param name="rhs"></param>
            <returns></returns>
        </member>
        <member name="T:NStl.DefaultComparerT`1">
            <summary>
            
            </summary>
            <typeparam name="T"></typeparam>
            <remarks>Might look duplicate to DefaultComparer, but is not. IComparer
            can compare two types of objects!!</remarks>
        </member>
        <member name="M:NStl.DefaultComparerT`1.#ctor(NStl.CompareAction,System.Collections.Generic.IComparer{`0})">
            <summary>
            ctor, takes a IComparer and a enum saying how to interpret the IComparer
            </summary>
            <param name="obj">Specifies what to do, e.g. compare as "less"</param>
            <param name="comparison">An IComparer implementation</param>
        </member>
        <member name="T:NStl.DefaultComparer`2">
            <summary>
            This object provides the possibility to use custom IComparer
            implementations in stl.net algorithms instead of the provided
            comparing functors that need IComparable to be implemented by all passed
            in objects. It is also intended to serve as an adaptor to "old" code and
            ICompare implementations.
            </summary>
            <remarks>This is not a original STL functor, but a useful extension for the .NET world</remarks>
        </member>
        <member name="M:NStl.DefaultComparer`2.#ctor(NStl.CompareAction,System.Collections.IComparer)">
            <summary>
            ctor, takes a IComparer and a enum saying how to interpret the IComparer
            </summary>
            <param name="obj">Specifies what to do, e.g. compare as "less"</param>
            <param name="comparison">An IComparer implementation</param>
        </member>
        <member name="T:NStl.Arithmetic.Minus">
            <summary>
            Represents the operation of subtracting two elements.
            </summary>
        </member>
        <member name="M:NStl.Arithmetic.Minus.Decimal">
            <summary>
            Creates a functor that lets you subtract two <see cref="T:System.Decimal"/> types.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Arithmetic.Minus.Int32">
            <summary>
            Creates a functor that lets you subtract two <see cref="T:System.Int32"/> types.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Arithmetic.Minus.Int64">
            <summary>
            Creates a functor that lets you subtract two <see cref="T:System.Int64"/> types.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Arithmetic.Minus.Int16">
            <summary>
            Creates a functor that lets you subtract two <see cref="T:System.Int16"/> types.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Arithmetic.Minus.Float">
            <summary>
            Creates a functor that lets you subtract two <see cref="T:System.Single"/> types.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Arithmetic.Minus.Double">
            <summary>
            Creates a functor that lets you subtract two <see cref="T:System.Double"/> types.
            </summary>
            <returns></returns>
        </member>
        <member name="T:NStl.Collections.Deque`1">
            <summary>
            <para>
            A deque is very much like a <see cref="T:NStl.Collections.Vector`1"/> or <see cref="T:System.Collections.Generic.List`1"/>: 
            like vector, it is a sequence that supports random access to elements, 
            constant time insertion and removal of elements at the end of the sequence, 
            and linear time insertion and removal of elements in the middle.
            </para>
            <para>
            The main way in which deque differs from vector is that deque also supports 
            constant time insertion and removal of elements at the beginning of the sequence. 
            Additionally, deque does not have any member functions analogous to vector's Capacity() 
            and Reserve(), and does not provide any of the guarantees on iterator validity that are 
            associated with those member functions. 
            </para>
            </summary>
            <typeparam name="T"></typeparam>
            <remarks>
            The name Deque is pronounced "deck", and stands for "double-ended queue." Knuth (section 2.6) 
            reports that the name was coined by E. J. Schweppe. See section 2.2.1 of Knuth for more 
            information about deques. (D. E. Knuth, The Art of Computer Programming. Volume 1: Fundamental 
            Algorithms, second edition. Addison-Wesley, 1973.)
            </remarks>
        </member>
        <member name="M:NStl.Collections.Deque`1.#ctor">
            <summary>
            Construct an empty deque.
            </summary>
        </member>
        <member name="M:NStl.Collections.Deque`1.#ctor(NStl.Iterators.IInputIterator{`0},NStl.Iterators.IInputIterator{`0})">
            <summary>
            Construct a deque andy copies the input range into this deque.
            </summary>
            <param name="first"></param>
            <param name="last"></param>
        </member>
        <member name="M:NStl.Collections.Deque`1.#ctor(System.Collections.IEnumerable)">
            <summary>
            Construct a deque andy copies the input range into this deque.
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:NStl.Collections.Deque`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Construct a deque andy copies the input range into this deque.
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:NStl.Collections.Deque`1.#ctor(`0[])">
            <summary>
            Construct a deque andy copies the input range into this deque.
            </summary>
            <param name="paramaters"></param>
        </member>
        <member name="M:NStl.Collections.Deque`1.#ctor(System.Int32,`0)">
            <summary>
            Construct a deque andy copies value "count" times into this deque.
            </summary>
            <param name="count"></param>
            <param name="value"></param>
        </member>
        <member name="M:NStl.Collections.Deque`1.#ctor(System.Int32)">
            <summary>
             Construct a deque andy copies default(T) "count" times into this deque.
            </summary>
            <param name="count"></param>
        </member>
        <member name="M:NStl.Collections.Deque`1.Resize(System.Int32,`0)">
            <summary>
            Resizes the deque to contain count members.
            </summary>
            <param name="count"></param>
            <param name="value"></param>
        </member>
        <member name="M:NStl.Collections.Deque`1.Resize(System.Int32)">
            <summary>
            Resizes the deque to contain count members.
            </summary>
            <param name="count"></param>
        </member>
        <member name="M:NStl.Collections.Deque`1.Begin">
            <summary>
            Returns and <see cref="T:NStl.Collections.Deque`1.Iterator"/> pointing to the first element of the deque.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Collections.Deque`1.End">
            <summary>
            Returns and <see cref="T:NStl.Collections.Deque`1.Iterator"/> pointing one past the final element of the deque.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Collections.Deque`1.PushBack(`0)">
            <summary>
            Adds the given item to the end of the deque in constant time.
            </summary>
            <param name="item">The item to be added.</param>
        </member>
        <member name="M:NStl.Collections.Deque`1.PushFront(`0)">
            <summary>
            Adds the given item at the front of the deque in constant time.
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:NStl.Collections.Deque`1.Clear">
            <summary>
            Clears the  content of the deque in constant time. The internal allocated memory 
            is not released.
            </summary>
        </member>
        <member name="M:NStl.Collections.Deque`1.Insert(NStl.Collections.Deque{`0}.Iterator,`0)">
            <summary>
            Inserts T at the given position.
            </summary>
            <param name="where">The position where the insertion should occur.</param>
            <param name="item">The item to be inserted.</param>
            <returns>An iterator pointing to the position where the insertion occured.</returns>
        </member>
        <member name="M:NStl.Collections.Deque`1.Insert(NStl.Collections.Deque{`0}.Iterator,NStl.Iterators.IInputIterator{`0},NStl.Iterators.IInputIterator{`0})">
            <summary>
            Inserts a range at the given position.
            </summary>
            <param name="where">The position where the insertion should occur.</param>
            <param name="first">
            An <see cref="T:NStl.Iterators.IInputIterator`1"/> pointing to the first element of the range to be inserted.
            </param>
            <param name="last">
            An <see cref="T:NStl.Iterators.IInputIterator`1"/> pointing one past the final element of the range to be inserted.
            </param>
            <returns>An iterator pointing to the position where the insertion occured.</returns>
        </member>
        <member name="M:NStl.Collections.Deque`1.Insert(NStl.Collections.Deque{`0}.Iterator,System.Int32,`0)">
            <summary>
            Inserts value count times at the given position.
            </summary>
            <param name="where"></param>
            <param name="count"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.Collections.Deque`1.Erase(NStl.Collections.Deque{`0}.Iterator)">
            <summary>
            Erases the element at the given position.
            </summary>
            <param name="pos"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.Collections.Deque`1.Erase(NStl.Collections.Deque{`0}.Iterator,NStl.Collections.Deque{`0}.Iterator)">
            <summary>
            Erases a range of elements from teh deque.
            </summary>
            <param name="first"></param>
            <param name="last"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.Collections.Deque`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copies the content of the deque into the given array starting at arrayIndex.
            </summary>
            <param name="array">The target array</param>
            <param name="arrayIndex">The index in the target array at which copying starts.</param>
        </member>
        <member name="M:NStl.Collections.Deque`1.ToArray">
            <summary>
            Returns an array containing the content of this range.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Collections.Deque`1.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            See <see cref="M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)"/> for details.
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="M:NStl.Collections.Deque`1.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Deserialization constructor.
            </summary>
            <param name="info"></param>
            <param name="ctxt"></param>
        </member>
        <member name="M:NStl.Collections.Deque`1.RBegin">
            <summary>
            Returns and reverse iterator pointing to the last element of the deque.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Collections.Deque`1.REnd">
            <summary>
            Returns and reverse iterator pointing one before the first element of the deque.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Collections.Deque`1.Front">
            <summary>
            The first element of the deque.
            </summary>
            <returns></returns>
            <exception cref="T:NStl.Exceptions.ContainerEmptyException">Thrown when the deque is empty.</exception>
        </member>
        <member name="M:NStl.Collections.Deque`1.Back">
            <summary>
            The last element of the deque.
            </summary>
            <returns></returns>
            <exception cref="T:NStl.Exceptions.ContainerEmptyException">Thrown when the deque is empty.</exception>
        </member>
        <member name="M:NStl.Collections.Deque`1.PopBack">
            <summary>
            Removes the last element of the deque.
            </summary>
            <exception cref="T:NStl.Exceptions.ContainerEmptyException">Thrown when the deque is empty.</exception>
        </member>
        <member name="M:NStl.Collections.Deque`1.PopFront">
            <summary>
            Removes the first element of the deque.
            </summary>
            <exception cref="T:NStl.Exceptions.ContainerEmptyException">Thrown when the deque is empty.</exception>
        </member>
        <member name="M:NStl.Collections.Deque`1.Swap(NStl.Collections.Deque{`0})">
            <summary>
            Swaps the the content of to deques in constant time.
            </summary>
            <param name="rhs"></param>
        </member>
        <member name="P:NStl.Collections.Deque`1.Item(System.Int32)">
            <summary>
            Random indexed access.
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="P:NStl.Collections.Deque`1.Count">
            <summary>
            The amount of elements inside of the deque.
            </summary>
        </member>
        <member name="P:NStl.Collections.Deque`1.Empty">
            <summary>
            TRUE, when the deque is empty. This is a constant time operation.
            </summary>
        </member>
        <member name="P:NStl.Collections.Deque`1.Buffer">
            <summary>
            Gets a linear copy of the
            </summary>
            <returns></returns>
        </member>
        <member name="T:NStl.Collections.Deque`1.Iterator">
            <summary>
            The iterator of a Deque{T}
            </summary>
        </member>
        <member name="M:NStl.Collections.Deque`1.Iterator.Equals(NStl.Iterators.Support.EquatableIterator{`0})">
            <summary>
            
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.Collections.Deque`1.Iterator.HashCode">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Collections.Deque`1.Iterator.Add(System.Int32)">
            <summary>
            See base class for details.
            </summary>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.Collections.Deque`1.Iterator.op_Addition(NStl.Collections.Deque{`0}.Iterator,System.Int32)">
            <summary>
            
            </summary>
            <param name="it"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.Collections.Deque`1.Iterator.op_Subtraction(NStl.Collections.Deque{`0}.Iterator,System.Int32)">
            <summary>
            
            </summary>
            <param name="it"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.Collections.Deque`1.Iterator.Subtract(NStl.Collections.Deque{`0}.Iterator,System.Int32)">
            <summary>
            
            </summary>
            <param name="it"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.Collections.Deque`1.Iterator.Diff(NStl.Iterators.IRandomAccessIterator{`0})">
            <summary>
            
            </summary>
            <param name="rhs"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.Collections.Deque`1.Iterator.Less(NStl.Iterators.IRandomAccessIterator{`0})">
            <summary>
            
            </summary>
            <param name="rhs"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.Collections.Deque`1.Iterator.PreDecrement">
            <summary>
            See base class for details.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Collections.Deque`1.Iterator.PreIncrement">
            <summary>
            See base class for details.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NStl.Collections.Deque`1.Iterator.Clone">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="P:NStl.Collections.Deque`1.Iterator.Value">
            <summary>
            See base class for details.
            </summary>
        </member>
        <member name="T:NStl.Resource">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:NStl.Resource.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:NStl.Resource.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:NStl.Resource.ArgMustBeGraterThanZero">
            <summary>
              Looks up a localized string similar to Argument must be greater than 0!.
            </summary>
        </member>
        <member name="P:NStl.Resource.ContainerIsEmpty">
            <summary>
              Looks up a localized string similar to &quot;The container is empty&quot;.
            </summary>
        </member>
        <member name="P:NStl.Resource.EndIteratorIsNotAValidinput">
            <summary>
              Looks up a localized string similar to The end iterator is not a valid input for this operation!.
            </summary>
        </member>
        <member name="P:NStl.Resource.EnumerableIsEmpty">
            <summary>
              Looks up a localized string similar to The IEnumerable is empty!.
            </summary>
        </member>
        <member name="P:NStl.Resource.GraphHasAtLeastOneCycle">
            <summary>
              Looks up a localized string similar to The Graph has at least one cycle!.
            </summary>
        </member>
        <member name="P:NStl.Resource.IteratorPointsToOtherRange">
            <summary>
              Looks up a localized string similar to The iterator points to another range!.
            </summary>
        </member>
        <member name="P:NStl.Resource.KeyAlreadyExists">
            <summary>
              Looks up a localized string similar to An element with the same key already exists!.
            </summary>
        </member>
        <member name="P:NStl.Resource.MethodNotFound">
            <summary>
              Looks up a localized string similar to The Method {0} was not found on the type {1}.
            </summary>
        </member>
        <member name="P:NStl.Resource.MustNotDerefEndIterator">
            <summary>
              Looks up a localized string similar to You must not dereference an end iterator!.
            </summary>
        </member>
        <member name="P:NStl.Resource.PropertyNotFound">
            <summary>
              Looks up a localized string similar to &quot;The Property {0} was not found on the type {1}&quot;.
            </summary>
        </member>
        <member name="P:NStl.Resource.VersionDiffer">
            <summary>
              Looks up a localized string similar to The Version {0} differ from the expected version: {1}.
            </summary>
        </member>
        <member name="T:NStl.Linq.ListTExtension">
            <summary>
            Provides a set of static (Shared in Visual Basic) methods 
            for querying objects of type <see cref="T:System.Collections.Generic.List`1"/>.
            </summary>
        </member>
        <member name="M:NStl.Linq.ListTExtension.Begin``1(System.Collections.Generic.List{``0})">
            <summary>
            Creates an iterator that points to the first element of the list.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.Linq.ListTExtension.End``1(System.Collections.Generic.List{``0})">
            <summary>
            Creates an iterator that points one past the final element of the list.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.Linq.ListTExtension.Remove``1(System.Collections.Generic.List{``0},NStl.Iterators.Support.ListTIterator{``0})">
            <summary>
            Erases the element at the specified position.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="where">
            An <see cref="T:NStl.Iterators.Support.ListTIterator`1"/> pointing to the element to be deleted.
            </param>
            <returns>
            An <see cref="T:NStl.Iterators.Support.ListTIterator`1"/> pointing the first element remaining 
            beyond any elements removed.
            </returns>
        </member>
        <member name="M:NStl.Linq.ListTExtension.Remove``1(System.Collections.Generic.List{``0},NStl.Iterators.Support.ListTIterator{``0},NStl.Iterators.Support.ListTIterator{``0})">
            <summary>
            Erases the elements of the specified sub range.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="first"></param>
            <param name="last"></param>
            <returns>
            An <see cref="T:NStl.Iterators.Support.ListTIterator`1"/> pointing the first element remaining 
            beyond any elements removed.
            </returns>
        </member>
        <member name="M:NStl.Linq.ListTExtension.Insert``1(System.Collections.Generic.List{``0},NStl.Iterators.Support.ListTIterator{``0},``0)">
            <summary>
            Inserts value at the position specified by the iterator.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="where">An iterator pointing to the position of the insertion.</param>
            <param name="value">The value to be inserted.</param>
            <returns>An iterator pointing to the inserted element.</returns>
        </member>
        <member name="M:NStl.Linq.ListTExtension.Insert``1(System.Collections.Generic.List{``0},NStl.Iterators.Support.ListTIterator{``0},System.Int32,``0)">
            <summary>
            Inserts value at the position specified by the iterator n times.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="where">An iterator pointing to the position of the insertion.</param>
            <param name="count">The amount of insertions.</param>
            <param name="value">The value to be inserted.</param>
            <returns>An iterator pointing to the inserted element.</returns>
        </member>
        <member name="M:NStl.Linq.ListTExtension.InsertIterator``1(System.Collections.Generic.List{``0},NStl.Iterators.Support.ListTIterator{``0})">
            <summary>
            Creates an output iterator that allows insertion at the specified iterator.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="where"></param>
            <returns></returns>
        </member>
        <member name="M:NStl.Linq.ListTExtension.Resize``1(System.Collections.Generic.List{``0})">
            <summary>
            Resizes the list to countain as many members as its capacity. It 
            adds default(T) if it is greater tan the actual count.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
        </member>
        <member name="T:NStl.Linq.InsertableExtension">
            <summary>
            Provides a set of static (Shared in Visual Basic) extension methods for
            <see cref="T:NStl.IInsertable`2"/> implementations.
            </summary>
        </member>
        <member name="M:NStl.Linq.InsertableExtension.InsertIterator``2(NStl.IInsertable{``0,``1},``1)">
            <summary>
            Creates an <see cref="T:NStl.Iterators.IOutputIterator`1"/> implementation
            that lets you insert values at the specified position.
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="InIt"></typeparam>
            <param name="insertable"></param>
            <param name="where"></param>
            <returns></returns>
        </member>
        <member name="T:NStl.Exceptions.ContainerEmptyException">
            <summary>
            This exception is thrown when you try to access a range that is empty.
            </summary>
        </member>
        <member name="T:NStl.Exceptions.DereferenceEndIteratorException">
            <summary>
            This exception is thrown when you have tried to dereference an iterator that is at or past the end of a sequence.
            </summary>
        </member>
        <member name="T:NStl.Exceptions.NoMatchingMethodFoundException">
            <summary>
            This exception is thrown when a requested method couldn't be found for a specific Type.
            This might happen whe the method name was mispelled, the argument types did not match or
            the method was not public.
            </summary>
        </member>
        <member name="T:NStl.Exceptions.NoMatchingPropertyFoundException">
            <summary>
            This exception is thrown when a requested property couldn't be found for a specific Type.
            This might happen whe the property name was mispelled, the argument types did not match or
            the property was not public.
            </summary>
        </member>
        <member name="T:NStl.Exceptions.NotTheSameInstanceException">
            <summary>
            This exception is thrown when two instance were expected to be the same and were not.
            </summary>
        </member>
        <member name="T:NStl.Exceptions.EndIteratorIsNotAValidInputException">
            <summary>
            Thrown when an iterator of a different container was used as input to
            a container method.
            </summary>
        </member>
        <member name="T:NStl.Exceptions.IncompatibleVersionException">
            <summary>
            Thrown on desirialization when an object differs in version from the serialized data.
            </summary>
        </member>
    </members>
</doc>
