- Add queryable "snap-to" locations for objects (snap-to types Face, Edge, Point)
	pr::v4 point = LdrObject::FindNearestSnapToPoint(ESnapTo::Face|ESnapTo::Edge|ESnapTo::Point);

- Single mouse click detection

- The auto refresh feature should notify the plugins to save them having to implement a 'FileWatch'. Feature should use "pr/filesys/filewatch.h"

- Support loading lua script files. The reason for this is so that the script can do calculations, have functions, etc.
  Create and example.lua file for demo purposes
  Lua usage:
    Add object modifiers:
    *OnLoad
    {
		*Lua { <lua code> }
    }
    *Step
    {
		*Period time_in_seconds
		*Lua { <lua code> }
    }
	All step objects are linked into a priority pr::chain (ordered by next to step).
	The LineDrawer UI has an 'execute script' option that processes the step objects
	Maybe add an execute_on_load option to the user settings also a file scope keyword *ExecuteOnLoad
	Lua code could control object transforms, colours, etc or the camera if at file scope

- An idea: If the line drawer commands were sent via windows messages then external apps could interact with a running line drawer instance using postmessage/sendmessage
  Several apps could have objects in one linedrawer instance. This would break the current plugin with stepping pattern and custom objects callback... ?

- Renders should only be initiated by the GUI objects

- Generalise stereo view
	Allow users to drag an area on the screen and create a viewport from it
		Rendering ->
			Viewports ->
				Create
				Delete
				Move
				sep
				label0
				label1
				...
		Rendering menu -> Viewports -> Create -> area select with left mouse (all selecting based on root viewport) -> popup dialog "Label viewport"
		picture in picture style

- MenuList export needs to sanitise strings on export/import

- Add a symbol resolver function stack to ldr_object_manager to provide symbols for #def{sizex}, #def{name}, #def{colour}, #def{pos}, etc

- Preserve state across reloads:
	build a map: [hash(objecttype, name, address), state_data(wireframe, visible, colour if != base colour)]
	address is the hash of position within the child of an objects parent, all the way up to the root
	e.g.
		obj1
		obj2
			obj21
				obj211
				obj212
				obj213 <- address is 3,1,2
			obj22
		obj3
		
- Add progress bar with cancel option for loading large source files
