<!doctype html>
<html>
<head>
	<title>Learning WebGL ï¿½ lesson 1</title>
	<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">
	<script src="..\..\lib\rylogic.min.js" type="text/javascript"></script>
	<script src="forward.vs.glsl"></script>
	<script src="forward.ps.glsl"></script>
	<script type="text/javascript">
		var EGeom = Object.freeze({
			"None":0,
			"Vert":1 << 0,
			"Colr":1 << 1,
			"Norm":1 << 2,
			"Tex0":1 << 3,
		});
		class Light
		{
		 	constructor(lighting_type, pos, dir, ambient, diffuse, specular, specpwr)
		 	{
		 		this.lighting_type = lighting_type;
		 		this.position = pos;
		 		this.direction = maths.Normalise(dir);
				this.ambient = ambient || [0,0,0];
				this.diffuse = diffuse || [0.5,0.5,0.5];
				this.specular = specular || [0,0,0];
				this.specpwr = specpwr || 0;
		 	}

			static get AMBIENT() { return 0; }
		 	static get DIRECTIONAL() { return 1; }
		 	static get RADIAL() { return 2; }
		 	static get SPOT() { return 3; }
		};
		class Camera
		{
			constructor()
			{
				this.o2w = m4x4.create();
			}
			get pos()
			{
				return m4x4.GetW(this.o2w);
			}
			get fwd()
			{
				return v4.Neg(m4x4.GetZ(this.o2w));
			}
		}

		// Entry point
		function WebGLStart()
		{
			try
			{
				let canvas = document.getElementById("canvas");

				// Set up WebGL
				let gl = InitWebGL(canvas);

				// Create the instances
				let instances = InitInstances(gl);

				// Set up the keyboard input handler
				let keys = InitKeyStateHandler();
				keys.KeyUp.push(function(ks)
				{
				});

				// Set up mouse input handling
				let mouse = InitMouseHandler(canvas);

				// Set up the camera
				let camera = new Camera();

				// Create a global light
				let global_light = new Light(Light.DIRECTIONAL, [0,0,0], [-0.5,-0.5,-1.0], [0,0,0], [0.2,0.8,0.1], [0.5,0.5,0.5], 10);

				// Main loop
				let last_ms = null;
				requestAnimationFrame(function run(clock_ms)
				{
					requestAnimationFrame(run);
					if (last_ms != null) 
					{
						let elapsed_ms = clock_ms - last_ms;

						// Rotate objects
						for (inst of instances)
						{
							m4x4.Rotate(inst.o2w, maths.Tau * elapsed_ms / 4000, [1, 1, 1], inst.o2w);
						}
			
						// Render the scene
						DrawScene(gl, instances, camera, global_light);
					}
					last_ms = clock_ms;
				});
			}
			catch (ex)
			{
				alert("Failed to initialise WebGL: " + ex.message);
			}
		}

		// Initialise WebGL
		function InitWebGL(canvas)
		{
			let gl = canvas.getContext("experimental-webgl");
			if (!gl)
				throw new Error("webgl not available");

			gl.ViewportWidth = canvas.width;
			gl.ViewportHeight = canvas.height;
			return gl;
		}

		// Initialise handling keyboard input
		function InitKeyStateHandler()
		{
			let keystates = {}
			let key = function(key_code)
			{
				return keystates[key_code] || (keystates[key_code] =
				{
					down: false,
					down_at: 0
				});
			};

			document.onkeydown = function(ev)
			{
				let ks = key(ev.keyCode);
				ks.down = true;
				ks.down_at = ks.down_at || Date.now();
				
				for (cb of key.KeyDown)
					cb(ks);
			};
			document.onkeyup = function(ev)
			{
				let ks = key(ev.keyCode);
				ks.down = false;
				ks.down_at = null;

				for (cb of key.KeyUp)
					cb(ks);
			};

			// Arrays for callbacks
			key.KeyDown = [];
			key.KeyUp = [];
			return key;
		}

		// Initialise handling mouse input
		function InitMouseHandler(canvas)
		{
			let mouse = function(point, btns, nav_op, nav_beg_or_end)
			{
			};
			
			document.onmousedown = function(ev)
			{
				if (ev.srcElement === canvas)
				{
					console.log("Mouse down on canvas");
				}
			};
			document.onmouseup = function(ev)
			{
				if (ev.srcElement === canvas)
				{
					console.log(ev);
				}
			};
			document.onmousemove = function(ev)
			{

			};

			return mouse;
		}

		// Create the model buffers
		function InitInstances(gl)
		{
			let instances = []

			// Create a shader for rendering simple geometry
			let shader = CreateShader(gl);

			{ // Pyramid
				let model = CreateModel(gl,
				[// verts
					{ pos: [+0.0, +1.0, +0.0], col: [1, 0, 0, 1], uv: [0.50, 1] },
					{ pos: [-1.0, -1.0, -1.0], col: [0, 1, 0, 1], uv: [0.00, 0] },
					{ pos: [+1.0, -1.0, -1.0], col: [0, 0, 1, 1], uv: [0.25, 0] },
					{ pos: [+1.0, -1.0, +1.0], col: [1, 1, 0, 1], uv: [0.50, 0] },
					{ pos: [-1.0, -1.0, +1.0], col: [0, 1, 1, 1], uv: [0.75, 0] },
				],
				[// indices
					0, 1, 2,
					0, 2, 3,
					0, 3, 4,
					0, 4, 1,
					4, 3, 2,
					2, 1, 4,
				],
				[// nuggets
					{ topo: gl.TRIANGLES, shader: shader, tex_diffuse: CreateTexture(gl, ".\\logo.png") }	
				]);

				let o2w = m4x4.Translation([-1.5, 0, -7.0]);
				let inst = CreateInstance("pyramid", model, o2w);
				instances.push(inst);
			}

			{ // Cube
				let model = CreateModel(gl,
				[// verts
					{ pos: [-1.0, -1.0, -1.0], norm: [-0.57, -0.57, -0.57] },
					{ pos: [+1.0, -1.0, -1.0], norm: [+0.57, -0.57, -0.57] },
					{ pos: [+1.0, +1.0, -1.0], norm: [+0.57, +0.57, -0.57] },
					{ pos: [-1.0, +1.0, -1.0], norm: [-0.57, +0.57, -0.57] },
					{ pos: [-1.0, -1.0, +1.0], norm: [-0.57, -0.57, +0.57] },
					{ pos: [+1.0, -1.0, +1.0], norm: [+0.57, -0.57, +0.57] },
					{ pos: [+1.0, +1.0, +1.0], norm: [+0.57, +0.57, +0.57] },
					{ pos: [-1.0, +1.0, +1.0], norm: [-0.57, +0.57, +0.57] },
				],
				[// indices
					0, 3, 2,  2, 1, 0,  // back
					4, 5, 6,  6, 7, 4,  // front
					0, 4, 7,  7, 3, 0,  // left
					1, 2, 6,  6, 5, 1,  // right
					2, 3, 7,  7, 6, 2,  // top
					0, 1, 5,  5, 4, 0,  // bottom
				],
				[// nuggets
					{ topo: gl.TRIANGLES, shader: shader }
				]);

				let o2w = m4x4.Translation([+1.5, 0, -7.0]);
				let inst = CreateInstance("cube", model, o2w);
				instances.push(inst);
			}

			return instances;
		}

		// Create simple geometry shaders
		function CreateShader(gl)
		{
			function CompileShader(shader_type, str)
			{
				// Create a shader instance
				let shader = gl.createShader(shader_type);

				// Compile the shader
				gl.shaderSource(shader, str);
				gl.compileShader(shader);
				if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS))
					throw new Error('Could not compile shader. \n\n' + gl.getShaderInfoLog(shader));

				return shader;
			}

			// Get the compiled shaders
			let vs = CompileShader(gl.VERTEX_SHADER, forward_vs);
			let ps = CompileShader(gl.FRAGMENT_SHADER, forward_ps);

			// Compile into a shader 'program'
			let shader = gl.createProgram();
			gl.attachShader(shader, vs);
			gl.attachShader(shader, ps);
			gl.linkProgram(shader);
			if (!gl.getProgramParameter(shader, gl.LINK_STATUS))
				throw new Error('Could not compile WebGL program. \n\n' + gl.getProgramInfoLog(shader));

			// Read variables from the shaders and save them in 'shader'
			shader.position = gl.getAttribLocation(shader, "position");
			shader.normal = gl.getAttribLocation(shader, "normal");
			shader.colour = gl.getAttribLocation(shader, "colour");
			shader.texcoord = gl.getAttribLocation(shader, "texcoord");

			shader.o2w = gl.getUniformLocation(shader, "o2w");
			shader.w2c = gl.getUniformLocation(shader, "w2c");
			shader.c2s = gl.getUniformLocation(shader, "c2s");

			shader.tint_colour = gl.getUniformLocation(shader, "tint_colour");

			shader.camera = {};
			shader.camera.ws_position = gl.getUniformLocation(shader, "cam_ws_position");
			shader.camera.ws_forward = gl.getUniformLocation(shader, "cam_ws_forward");

			shader.tex_diffuse = {};
			shader.tex_diffuse.enabled = gl.getUniformLocation(shader, "has_tex_diffuse");
			shader.tex_diffuse.sampler = gl.getUniformLocation(shader, "sampler_diffuse");

			shader.light = {};
			shader.light.lighting_type = gl.getUniformLocation(shader, "lighting_type");
			shader.light.position = gl.getUniformLocation(shader, "light_position");
			shader.light.direction = gl.getUniformLocation(shader, "light_direction");
			shader.light.ambient = gl.getUniformLocation(shader, "light_ambient");
			shader.light.diffuse = gl.getUniformLocation(shader, "light_diffuse");
			shader.light.specular = gl.getUniformLocation(shader, "light_specular");
			shader.light.specpwr = gl.getUniformLocation(shader, "light_specpwr");

			// Return the shader
			return shader;
		}

		// Create a diffuse texture from a file
		function CreateTexture(gl, filepath)
		{
			let tex = gl.createTexture();
			tex.image = new Image();
			tex.image.onload = function()
			{
				gl.bindTexture(gl.TEXTURE_2D, tex);
				gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
				gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, tex.image);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
			  	gl.generateMipmap(gl.TEXTURE_2D);
 				gl.bindTexture(gl.TEXTURE_2D, null);
			}
			tex.image.src = filepath;
			return tex;
		}

		// Create a model
		function CreateModel(gl, verts, indices, nuggets, usage = gl.STATIC_DRAW)
		{
			let model =
			{
				geom: EGeom.None,
				vbuffer: null,
				nbuffer: null,
				cbuffer: null,
				tbuffer: null,
				ibuffer: null,
				gbuffer: [],
				// Nugget Format:
				// {
				// 	topo: gl.TRIANGLES,
				// 	shader: null,
				// 	tex_diffuse: null,                               // optional
				//  light: Light.Directional([-1,-1,-1], [1,1,0,1]), // optional
				// 	irange: {ofs:0, count:indices.length},           // optional
				// 	vrange: {ofs:0, count:verts.length}              // optional
				// };
			};

			// Fill verts buffer
			if (verts != null && verts.length > 0)
			{
				// Verts have position data
				if (verts[0].hasOwnProperty("pos"))
				{
					let pos = new Float32Array(verts.length * 3);
					for (let i = 0, j = 0; i != verts.length; ++i)
					{
						let p = verts[i].pos;
						pos[j++] = p[0];
						pos[j++] = p[1];
						pos[j++] = p[2];
					}

					model.geom = model.geom | EGeom.Vert;
					model.vbuffer = gl.createBuffer();
					model.vbuffer.stride = 3;
					model.vbuffer.count = pos.length / model.vbuffer.stride;
					gl.bindBuffer(gl.ARRAY_BUFFER, model.vbuffer);
					gl.bufferData(gl.ARRAY_BUFFER, pos, usage);
				}

				// Verts have normals data
				if (verts[0].hasOwnProperty("norm"))
				{
					let norm = []
					verts.map(function(x){ norm = norm.concat(x.norm); });

					model.geom = model.geom | EGeom.Norm;
					model.nbuffer = gl.createBuffer();
					model.nbuffer.stride = 3;
					model.nbuffer.count = norm.length / model.nbuffer.stride;
					gl.bindBuffer(gl.ARRAY_BUFFER, model.nbuffer);
					gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(norm), usage);
				}

				// Verts have colour data
				if (verts[0].hasOwnProperty("col"))
				{
					let col = [];
					verts.map(function(x){ col = col.concat(x.col); });

					model.geom = model.geom | EGeom.Colr;
					model.cbuffer = gl.createBuffer();
					model.cbuffer.stride = 4;
					model.cbuffer.count = col.length / model.cbuffer.stride;
					gl.bindBuffer(gl.ARRAY_BUFFER, model.cbuffer);
					gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(col), usage);
				}

				// Verts have texture coords
				if (verts[0].hasOwnProperty("uv"))
				{
					let uvs = [];
					 verts.map(function(x){ uvs = uvs.concat(x.uv); });

					model.geom = model.geom | EGeom.Tex0;
					model.tbuffer = gl.createBuffer();
					model.tbuffer.stride = 2;
					model.tbuffer.count = uvs.length / model.tbuffer.stride;
					gl.bindBuffer(gl.ARRAY_BUFFER, model.tbuffer);
					gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(uvs), usage);
				}
			}

			// Fill the index buffer
			if (indices != null && indices.length > 0)
			{
				model.ibuffer = gl.createBuffer();
				model.ibuffer.count = indices.length;
				gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, model.ibuffer);
				gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), usage);
			}

			// Fill the nuggets buffer
			if (nuggets != null && nuggets.length > 0)
			{
				if (!nuggets[0].hasOwnProperty("topo"))
					throw new Error("Nuggets must include a topology field");
				if (!nuggets[0].hasOwnProperty("shader"))
					throw new Error("Nuggets must include a shader field");

				model.gbuffer = nuggets;
			}

			return model;
		}

		// Create an instance of a model
		function CreateInstance(name, model, o2w)
		{
			return { name: name, model: model, o2w: o2w };
		}

		// Render the scene
		function DrawScene(gl, instances, camera, global_light)
		{
			// Set the viewport
			gl.viewport(0, 0, gl.ViewportWidth, gl.ViewportHeight);
			
			// Clear the back/depth buffer
			gl.clearColor(0.5, 0.5, 0.5, 1);
			gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
			
			// Set render states
			gl.enable(gl.DEPTH_TEST);

			// Render each instance
			for (inst of instances)
			{
				// Render each nugget for each instance
				for (nug of inst.model.gbuffer)
				{
					// Bind the shader to the gfx card
					gl.useProgram(nug.shader);

					{// Bind the diffuse texture
						if (nug.hasOwnProperty("tex_diffuse"))
						{
							gl.uniform1i(nug.shader.tex_diffuse.enabled, 1);
							gl.uniform1i(nug.shader.tex_diffuse.sampler, 0);
							gl.bindTexture(gl.TEXTURE_2D, nug.tex_diffuse);
							gl.activeTexture(gl.TEXTURE0);
						}
						else if (nug.shader.tex_diffuse.enabled != -1)
						{
							gl.uniform1i(nug.shader.tex_diffuse.enabled, 0);
						}
					}

					{// Bind shader input streams
						// Bind vertex buffer
						if (inst.model.geom & EGeom.Vert)
						{
							gl.bindBuffer(gl.ARRAY_BUFFER, inst.model.vbuffer);
							gl.vertexAttribPointer(nug.shader.position, inst.model.vbuffer.stride, gl.FLOAT, false, 0, 0);
							gl.enableVertexAttribArray(nug.shader.position);
						}
						else if (nug.shader.position != -1)
						{
							gl.vertexAttrib3fv(nug.shader.colour, [0,0,0]);
							gl.disableVertexAttribArray(nug.shader.position);
						}

						// Bind normals buffer
						if (inst.model.geom & EGeom.Norm)
						{
							gl.bindBuffer(gl.ARRAY_BUFFER, inst.model.nbuffer);
							gl.vertexAttribPointer(nug.shader.normal, inst.model.nbuffer.stride, gl.FLOAT, false, 0, 0);
							gl.enableVertexAttribArray(nug.shader.normal);
						}
						else if (nug.shader.normal != -1)
						{
							gl.vertexAttrib3fv(nug.shader.normal, [0,0,0]);
							gl.disableVertexAttribArray(nug.shader.normal);
						}

						// Bind colours buffer
						if (inst.model.geom & EGeom.Colr)
						{
							gl.bindBuffer(gl.ARRAY_BUFFER, inst.model.cbuffer);
							gl.vertexAttribPointer(nug.shader.colour, inst.model.cbuffer.stride, gl.FLOAT, false, 0, 0);
							gl.enableVertexAttribArray(nug.shader.colour);
						}
						else if (nug.shader.colour != -1)
						{
							gl.vertexAttrib3fv(nug.shader.colour, [1,1,1]);
							gl.disableVertexAttribArray(nug.shader.colour);
						}
						
						// Bind texture coords buffer
						if (inst.model.geom & EGeom.Tex0)
						{
							gl.bindBuffer(gl.ARRAY_BUFFER, inst.model.tbuffer);
							gl.vertexAttribPointer(nug.shader.texcoord, inst.model.tbuffer.stride, gl.FLOAT, false, 0, 0);
							gl.enableVertexAttribArray(nug.shader.texcoord);
						}
						else if (nug.shader.texcoord != -1)
						{
							gl.vertexAttrib2fv(nug.shader.texcoord, [0,0]);
							gl.disableVertexAttribArray(nug.shader.texcoord);
						}
					}

					{// Set lighting
						// Use the global light, or one from the nugget
						let light = nug.hasOwnProperty("light") ? nug.light : global_light;
						if (inst.model.geom & EGeom.Norm)
						{
							gl.uniform1i(nug.shader.light.lighting_type, light.lighting_type);
							gl.uniform3fv(nug.shader.light.position, light.position.slice(0,3));
							gl.uniform3fv(nug.shader.light.direction, light.direction.slice(0,3));
							gl.uniform3fv(nug.shader.light.ambient, light.ambient);
							gl.uniform3fv(nug.shader.light.diffuse, light.diffuse);
							gl.uniform3fv(nug.shader.light.specular, light.specular);
							gl.uniform1f(nug.shader.light.specpwr, light.specpwr);
						}
						else if (nug.shader.light.lighting_type != -1)
						{
							gl.uniform1i(nug.shader.light.lighting_type, 0);
						}
					}
					
					{// Set tint
						gl.uniform4fv(nug.shader.tint_colour, new Float32Array([0.9,0.4,0.1,1]));
					}

					{// Set transforms
						// Set the projection matrix
						let c2s = nug.hasOwnProperty("c2s") ? nug.c2s : m4x4.ProjectionPerspectiveFOV(maths.TauBy8, gl.ViewportWidth / gl.ViewportHeight, 0.01, 100.0, true);
						gl.uniformMatrix4fv(nug.shader.c2s, false, c2s);
						
						// Set the camera matrix
						let c_pos = camera.pos.slice(0,3);
						let c_fwd = camera.fwd.slice(0,3);
						gl.uniformMatrix4fv(nug.shader.w2c, false, m4x4.create());
						gl.uniform3fv(nug.shader.camera.ws_position, c_pos);
						gl.uniform3fv(nug.shader.camera.ws_forward, c_fwd);

						// Set the o2w transform
						gl.uniformMatrix4fv(nug.shader.o2w, false, inst.o2w);
					}

					{// Render the nugget
						if (inst.model.ibuffer != null)
						{
							// Get the buffer range to render
							let irange = nug.hasOwnProperty("irange") ? nug.irange : {ofs: 0, count: inst.model.ibuffer.count};
							gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, inst.model.ibuffer);
							gl.drawElements(nug.topo, irange.count, gl.UNSIGNED_SHORT, irange.ofs);
						}
						else
						{
							// Get the buffer range to render
							let vrange = nug.hasOwnProperty("vrange") ? nug.vrange : {ofs: 0, count: inst.model.vbuffer.count};
							gl.drawArrays(nug.topo, vrange.ofs, vrange.count);
						}
					}

					// Clean up
					gl.bindTexture(gl.TEXTURE_2D, null);
					gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
					gl.bindBuffer(gl.ARRAY_BUFFER, null);
				}
			}
		}



	</script>
</head>
<body onload="WebGLStart();">
	<canvas width="500" height="500" id="canvas" style="border: none;"></canvas>
</body>
</html>
