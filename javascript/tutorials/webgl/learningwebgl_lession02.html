<!doctype html>
<html>
<head>
	<title>Learning WebGL ï¿½ lesson 1</title>
	<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">
	<script src="..\..\lib\rylogic.min.js" type="text/javascript"></script>
	<script id="shader-vs" type="x-shader/x-vertex">
		attribute vec3 position;
		attribute vec4 colour;

		uniform mat4 o2w;
		uniform mat4 c2s;

		varying vec4 ps_colour;

		void main(void)
		{
			gl_Position = c2s * o2w * vec4(position, 1.0);
			ps_colour = colour;
		}
	</script>
	<script id="shader-ps" type="x-shader/x-fragment">
		precision mediump float;

		varying vec4 ps_colour;

		void main(void)
		{
			gl_FragColor = ps_colour;
		}
	</script>
	<script type="text/javascript">

		// Entry point
		function WebGLStart()
		{
			try
			{
				// Get the canvas to draw on
				let canvas = document.getElementById("canvas");

				// Set up WebGL
				let gl = InitWebGL(canvas);

				// Create and bind shaders for rendering simply geometry
				let shader = InitShaders(gl);

				// Create the model buffers
				let models = InitModels(gl);

				// Render the scene
				DrawScene(gl, shader, models);
			}
			catch (ex)
			{
				alert("Failed to initialise WebGL: " + ex.message);
			}
		}

		// Initialise WebGL
		function InitWebGL(canvas)
		{
			let gl = canvas.getContext("experimental-webgl");
			if (!gl)
				throw "webgl not available";

			gl.ViewportWidth = canvas.width;
			gl.ViewportHeight = canvas.height;
			return gl;
		}

		// Create simple geometry shaders
		function InitShaders(gl)
		{
			// Read a shader from the DOM
			function GetShader(gl, id)
			{
				// Find the shader element
				let shader_elem = document.getElementById(id);
				if (!shader_elem)
					throw "Shader element " + str(id) + " not found";

				let str = "";
				for (let k = shader_elem.firstChild; k; k = k.nextSibling)
				{
					if (k.nodeType != 3) continue;
					str += k.textContent;
				}

				// Create a shader instance
				let shader =
					shader_elem.type == "x-shader/x-fragment" ? gl.createShader(gl.FRAGMENT_SHADER) :
					shader_elem.type == "x-shader/x-vertex" ? gl.createShader(gl.VERTEX_SHADER) :
					null;

				// Compile the shader
				gl.shaderSource(shader, str);
				gl.compileShader(shader);
				if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS))
					throw gl.getShaderInfoLog(shader);

				return shader;
			}

			// Get the compiled shaders
			let ps = GetShader(gl, "shader-ps");
			let vs = GetShader(gl, "shader-vs");

			// Compile into a shader 'program'
			let shader = gl.createProgram();
			gl.attachShader(shader, vs);
			gl.attachShader(shader, ps);
			gl.linkProgram(shader);
			if (!gl.getProgramParameter(shader, gl.LINK_STATUS))
				throw "Failed to initialise shaders";

			// Bind the shaders to the gfx card
			gl.useProgram(shader);

			// Read variables from the shaders and save them in 'shader'
			shader.c2s = gl.getUniformLocation(shader, "c2s");
			shader.o2w = gl.getUniformLocation(shader, "o2w");
			shader.position = gl.getAttribLocation(shader, "position");
			shader.colour = gl.getAttribLocation(shader, "colour");
			gl.enableVertexAttribArray(shader.position);
			gl.enableVertexAttribArray(shader.colour);

			// Return the shader
			return shader;
		}

		// Create the model buffers
		function InitModels(gl)
		{
			let models = [];

			{// Model 1
				let model = new Object();

				model.vbuffer = gl.createBuffer();
				model.cbuffer = gl.createBuffer();

				// Set vertex data
				let vertices = [
					+0.0, +1.0, 0.0,
					-1.0, -1.0, 0.0,
					+1.0, -1.0, 0.0,
				];
				gl.bindBuffer(gl.ARRAY_BUFFER, model.vbuffer);
				gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
				model.vbuffer.stride = 3;
				model.vbuffer.count = vertices.length / model.vbuffer.stride;

				// Set colours
				let colours = [
					1, 0, 0, 1,
					0, 1, 0, 1,
					0, 0, 1, 1,
				];
				gl.bindBuffer(gl.ARRAY_BUFFER, model.cbuffer);
				gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colours), gl.STATIC_DRAW);
				model.cbuffer.stride = 4;
				model.cbuffer.count = colours.length / model.cbuffer.stride;

				models.push(model);
			}
			{// Model 2
				let model = new Object();

				model.vbuffer = gl.createBuffer();
				model.cbuffer = gl.createBuffer();

				// Set vertex data
				let vertices = [
					1.0, 1.0, 0.0,
					-1.0, 1.0, 0.0,
					1.0, -1.0, 0.0,
					-1.0, -1.0, 0.0,
				];
				gl.bindBuffer(gl.ARRAY_BUFFER, model.vbuffer);
				gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
				model.vbuffer.stride = 3;
				model.vbuffer.count = vertices.length / model.vbuffer.stride;

				// Set colour data
				let colours = [
					1, 0, 0, 1,
					0, 1, 0, 1,
					0, 0, 1, 1,
					1, 1, 0, 1,
				];
				gl.bindBuffer(gl.ARRAY_BUFFER, model.cbuffer);
				gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colours), gl.STATIC_DRAW);
				model.cbuffer.stride = 4;
				model.cbuffer.count = colours.length / model.cbuffer.stride;

				models.push(model);
			}

			return models;
		}

		// Render the scene
		function DrawScene(gl, shader, models)
		{
			// Clear the back buffer
			gl.clearColor(0.0, 0.0, 0.0, 1.0);
			gl.enable(gl.DEPTH_TEST);

			// Set the viewport
			gl.viewport(0, 0, gl.ViewportWidth, gl.ViewportHeight);

			// Clear the back/depth buffer
			gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

			// Set the camera matrix
			let c2s = m4x4.ProjectionPerspectiveFOV(maths.TauBy8, gl.ViewportWidth / gl.ViewportHeight, 0.1, 100.0, true);
			gl.uniformMatrix4fv(shader.c2s, false, c2s);

			// Add the models
			{
				let m = models[0];
				
				gl.bindBuffer(gl.ARRAY_BUFFER, m.vbuffer);
				gl.vertexAttribPointer(shader.position, m.vbuffer.stride, gl.FLOAT, false, 0, 0);
				gl.bindBuffer(gl.ARRAY_BUFFER, m.cbuffer);
				gl.vertexAttribPointer(shader.colour, m.cbuffer.stride, gl.FLOAT, false, 0, 0);
				
				let o2w = m4x4.Translation([-1.5, 0.0, -7.0]);
				gl.uniformMatrix4fv(shader.o2w, false, o2w);
				gl.drawArrays(gl.TRIANGLES, 0, m.vbuffer.count);
			}
			{
				let m = models[1];

				gl.bindBuffer(gl.ARRAY_BUFFER, m.vbuffer);
				gl.vertexAttribPointer(shader.position, m.vbuffer.stride, gl.FLOAT, false, 0, 0);
				gl.bindBuffer(gl.ARRAY_BUFFER, m.cbuffer);
				gl.vertexAttribPointer(shader.colour, m.cbuffer.stride, gl.FLOAT, false, 0, 0);

				let o2w = m4x4.Translation([1.5, 0.0, -7.0]);
				gl.uniformMatrix4fv(shader.o2w, false, o2w);
				gl.drawArrays(gl.TRIANGLE_STRIP, 0, m.vbuffer.count);
			}
		}

	</script>
</head>
<body onload="WebGLStart();">
	<canvas width="500" height="500" id="canvas" style="border: none;"></canvas>
</body>
</html>
