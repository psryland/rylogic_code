<!doctype html>
<html>
<head>
	<title>Learning WebGL ï¿½ lesson 1</title>
	<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">
	<script src="..\..\lib\rylogic.min.js" type="text/javascript"></script>
	<script id="shader-vs" type="x-shader/x-vertex">
		attribute vec3 position;
		attribute vec4 colour;

		uniform mat4 o2w;
		uniform mat4 c2s;

		varying vec4 ps_colour;

		void main(void)
		{
		gl_Position = c2s * o2w * vec4(position, 1.0);
		ps_colour = colour;
		}
	</script>
	<script id="shader-ps" type="x-shader/x-fragment">
		precision mediump float;

		varying vec4 ps_colour;

		void main(void)
		{
		gl_FragColor = ps_colour;
		}
	</script>
	<script type="text/javascript">

		// Entry point
		function WebGLStart()
		{
			try
			{
				// Set up WebGL
				let gl = InitWebGL(document.getElementById("canvas"));
				
				// Create the model buffers
				let instances = InitInstances(gl);
				
				// Create and bind shaders for rendering simply geometry
				let shader = InitShaders(gl);
				
				// Main loop
				let last_ms = null;
				requestAnimationFrame(function run(clock_ms)
				{
					requestAnimationFrame(run);
					if (last_ms != null) 
					{
						let elapsed_ms = clock_ms - last_ms;
						Run(elapsed_ms, gl, shader, instances);
					}
					last_ms = clock_ms;
				});
			}
			catch (ex)
			{
				alert("Failed to initialise WebGL: " + ex.message);
			}
		}

		// Initialise WebGL
		function InitWebGL(canvas)
		{
			let gl = canvas.getContext("experimental-webgl");
			if (!gl)
				throw "webgl not available";
			
			gl.ViewportWidth = canvas.width;
			gl.ViewportHeight = canvas.height;
			return gl;
		}

		// Create the model buffers
		function InitInstances(gl)
		{
			let instances = []

			{ // Instance 1
				let model = CreateModel(gl, gl.TRIANGLES,
				[
					+0.0, +1.0, 0.0,
					-1.0, -1.0, 0.0,
					+1.0, -1.0, 0.0,
				],
				[
					1, 0, 0, 1,
					0, 1, 0, 1,
					0, 0, 1, 1,
				]);
				
				let o2w = m4x4.Translation([-1.5, 0, -7.0]);
				let inst = CreateInstance(model, o2w);
				instances.push(inst);
			}

			{ // Instance 2
				let model = CreateModel(gl, gl.TRIANGLE_STRIP,
				[
					1.0, 1.0, 0.0,
					-1.0, 1.0, 0.0,
					1.0, -1.0, 0.0,
					-1.0, -1.0, 0.0,
				],
				[
					1, 0, 0, 1,
					0, 1, 0, 1,
					0, 0, 1, 1,
					1, 1, 0, 1,
				]);
				
				let o2w = m4x4.Translation([+1.5, 0, -7.0]);
				let inst = CreateInstance(model, o2w);
				instances.push(inst);
			}

			return instances;
		}

		// Create simple geometry shaders
		function InitShaders(gl)
		{
			// Read a shader from the DOM
			function GetShader(gl, id)
			{
				// Find the shader element
				let shader_elem = document.getElementById(id);
				if (!shader_elem)
					throw "Shader element " + str(id) + " not found";

				let str = "";
				for (let k = shader_elem.firstChild; k; k = k.nextSibling)
				{
					if (k.nodeType != 3) continue;
					str += k.textContent;
				}

				// Create a shader instance
				let shader =
					shader_elem.type == "x-shader/x-fragment" ? gl.createShader(gl.FRAGMENT_SHADER) :
					shader_elem.type == "x-shader/x-vertex" ? gl.createShader(gl.VERTEX_SHADER) :
					null;

				// Compile the shader
				gl.shaderSource(shader, str);
				gl.compileShader(shader);
				if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS))
					throw gl.getShaderInfoLog(shader);

				return shader;
			}

			// Get the compiled shaders
			let ps = GetShader(gl, "shader-ps");
			let vs = GetShader(gl, "shader-vs");

			// Compile into a shader 'program'
			let shader = gl.createProgram();
			gl.attachShader(shader, vs);
			gl.attachShader(shader, ps);
			gl.linkProgram(shader);
			if (!gl.getProgramParameter(shader, gl.LINK_STATUS))
				throw "Failed to initialise shaders";

			// Bind the shaders to the gfx card
			gl.useProgram(shader);

			// Read variables from the shaders and save them in 'shader'
			shader.c2s = gl.getUniformLocation(shader, "c2s");
			shader.o2w = gl.getUniformLocation(shader, "o2w");
			shader.position = gl.getAttribLocation(shader, "position");
			shader.colour = gl.getAttribLocation(shader, "colour");
			gl.enableVertexAttribArray(shader.position);
			gl.enableVertexAttribArray(shader.colour);

			// Return the shader
			return shader;
		}

		// Create a model
		function CreateModel(gl, topo, verts, colours)
		{
			let model = new Object();
			model.topo = topo;
			model.vbuffer = null;
			model.cbuffer = null;

			// Fill verts buffer
			if (verts != null)
			{
				model.vbuffer = gl.createBuffer();
				model.vbuffer.stride = 3;
				model.vbuffer.count = verts.length / model.vbuffer.stride;
				gl.bindBuffer(gl.ARRAY_BUFFER, model.vbuffer);
				gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(verts), gl.STATIC_DRAW);
			}

			// Fill colours buffer
			if (colours != null)
			{
				model.cbuffer = gl.createBuffer();
				model.cbuffer.stride = 4;
				model.cbuffer.count = colours.length / model.cbuffer.stride;
				gl.bindBuffer(gl.ARRAY_BUFFER, model.cbuffer);
				gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colours), gl.STATIC_DRAW);
			}

			return model;
		}

		// Create an instance of a model
		function CreateInstance(model, o2w)
		{
			let instance = new Object();
			instance.model = model;
			instance.initial_o2w = o2w;
			instance.o2w = o2w;
			return instance;
		}

		// Main loop
		function Run(elapsed_ms, gl, shader, instances)
		{
			for (inst of instances)
			{
				m4x4.Rotate(inst.o2w, maths.Tau * elapsed_ms / 1000, [0, 1, 0], inst.o2w);
			}

			// Render the scene
			DrawScene(gl, shader, instances);
		}

		// Render the scene
		function DrawScene(gl, shader, instances)
		{
			// Clear the back buffer
			gl.clearColor(0.0, 0.0, 0.0, 1.0);
			gl.enable(gl.DEPTH_TEST);

			// Set the viewport
			gl.viewport(0, 0, gl.ViewportWidth, gl.ViewportHeight);

			// Clear the back/depth buffer
			gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

			// Set the camera matrix
			let c2s = m4x4.ProjectionPerspectiveFOV(maths.TauBy8, gl.ViewportWidth / gl.ViewportHeight, 0.01, 100.0, true);
			gl.uniformMatrix4fv(shader.c2s, false, c2s);

			// Add the instances to the scene
			for (inst of instances)
			{
				// Assign buffers to the shader input streams
				if (inst.model.vbuffer != null)
				{
					gl.bindBuffer(gl.ARRAY_BUFFER, inst.model.vbuffer);
					gl.vertexAttribPointer(shader.position, inst.model.vbuffer.stride, gl.FLOAT, false, 0, 0);
				}
				if (inst.model.cbuffer != null)
				{
					gl.bindBuffer(gl.ARRAY_BUFFER, inst.model.cbuffer);
					gl.vertexAttribPointer(shader.colour, inst.model.cbuffer.stride, gl.FLOAT, false, 0, 0);
				}

				// Set the o2w transform
				gl.uniformMatrix4fv(shader.o2w, false, inst.o2w);

				// Render the model
				gl.drawArrays(inst.model.topo, 0, inst.model.vbuffer.count);
			}
		}

	</script>
</head>
<body onload="WebGLStart();">
	<canvas width="500" height="500" id="canvas" style="border: none;"></canvas>
</body>
</html>
