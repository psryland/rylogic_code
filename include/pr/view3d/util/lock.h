//*********************************************
// Renderer
//  Copyright (c) Rylogic Ltd 2012
//*********************************************
#pragma once

#include "pr/view3d/forward.h"

namespace pr::rdr
{
	// Notes about Map()/Unmap and resource usage flags:
	//  There are two main kinds of resources: map-able and non-map-able. Resources created with dynamic or staging
	//  usages are map-able, while resources created with default or immutable usages are non-map-able.
	// I think this means you have to initialise models that use 'D3D11_USAGE_DEFAULT' buffers at creation time
	// and you can't 'Map' them later.
	// Further:
	//  Copying data among non-map-able resources is very fast because this is the most common case and has been optimized
	//  to perform well. Since these resources are not directly accessible by the CPU, they are optimized so that the GPU
	//  can manipulate them quickly. Copying data among map-able resources is more problematic because the performance will
	//  depend on the usage the resource was created with. For example, the GPU can read a dynamic resource fairly quickly
	//  but cannot write to them, and the GPU cannot read or write to staging resources directly. Applications that wish to
	//  copy data from a resource with default usage to a resource with staging usage (to allow the CPU to read the data --
	//  i.e. the GPU read-back problem) must do so with care. See Accessing Resource Data for more details on this last case.
	//
	//  The CPU can only read from resources created with the D3D10_USAGE_STAGING flag. Since resources created with this
	//  flag cannot be set as outputs of the pipeline, if the CPU wants to read the data in a resource generated by the GPU,
	//  the data must be copied to a resource created with the staging flag. The application may do this by using the
	//  ID3D10Device::CopyResource or ID3D10Device::CopySubresourceRegion methods to copy the contents of one resource to
	//  another. The application can then gain access to this resource by calling the appropriate Map method. When access
	//  to the resource is no longer needed, the application should then call the corresponding Unmap method. For example,
	//  ID3D10Texture2D::Map and ID3D10Texture2D::Unmap. The different Map methods return some specific values depending on
	//  the input flags. See Map Remarks section for details.
	//
	//  Read this: http://msdn.microsoft.com/en-us/library/windows/desktop/bb205132(v=vs.85).aspx
	//
	// If the app needs to use ID3D10Device::CopyResource or ID3D10Device::CopySubresourceRegion to copy GPU output back to
	// CPU accessible memory, it needs to be done 2 frames before calling Map on the result of the copy to prevent any
	// performance loss (i.e. CPU waits for GPU to do the copy, then GPU waits for CPU to finish the Map()/Unmap())

	enum class EMap
	{
		Read = D3D11_MAP_READ,
		Write = D3D11_MAP_WRITE,
		ReadWrite = D3D11_MAP_READ_WRITE,
		WriteDiscard = D3D11_MAP_WRITE_DISCARD,
		WriteNoOverwrite = D3D11_MAP_WRITE_NO_OVERWRITE,
	};

	enum class EMapFlags
	{
		None = 0,
		DoNotWait = D3D11_MAP_FLAG_DO_NOT_WAIT,
		_flags_enum,
	};

	// A scope object for locking (or "mapping") a resource so that the CPU can access it.
	// Mapping:   Gets a pointer to the data contained in a sub-resource, and denies the GPU access to that sub-resource.
	// Unmapping: Invalidate the pointer to a resource and re-enable the GPU's access to that resource.
	struct Lock :private D3D11_MAPPED_SUBRESOURCE
	{
		ID3D11DeviceContext* m_dc;     // Locking is done by the DC.
		ID3D11Resource*      m_res;    // The resource to be locked
		UINT                 m_sub;    // e.g. mip level (use 0 for V/I buffers)
		std::size_t          m_stride; // The size of each element (in bytes)
		Range                m_range;  // The range of the data intended for modification (in units of stride bytes)

		// Provide a 'dc' if you want to use a deferred context to lock the resource.
		// This will override the 'dc' passed to Map by the renderer manager classes (which will pass in the immediate DC)
		// Note: that to map a deferred context, you can only use write discard or write no overwrite.
		Lock()
			:D3D11_MAPPED_SUBRESOURCE()
			,m_dc()
			,m_res()
			,m_sub()
			,m_stride()
			,m_range()
		{}
		Lock(ID3D11DeviceContext* dc, ID3D11Resource* res, UINT sub, size_t stride, EMap map_type, EMapFlags flags = EMapFlags::None, Range range = RangeZero)
			:Lock()
		{
			PR_ASSERT(PR_DBG_RDR, !AllSet(flags, EMapFlags::DoNotWait), "Don't use this constructor with this flag");
			Map(dc, res, sub, stride, map_type, flags, range);
		}
		Lock(Lock const&) = delete;
		Lock(Lock&& rhs)
			:D3D11_MAPPED_SUBRESOURCE(rhs)
			,m_dc(rhs.m_dc)
			,m_res(rhs.m_res)
			,m_sub(rhs.m_sub)
			,m_stride(rhs.m_stride)
			,m_range(rhs.m_range)
		{
			rhs.m_dc = nullptr;
			rhs.m_res = nullptr;
			rhs.m_sub = 0;
			rhs.m_stride = 0;
			rhs.m_range = Range {};
		}
		~Lock()
		{
			Unmap();
		}

		// Returns a pointer to the mapped memory
		// SDK Notes: *Don't read from a sub-resource mapped for writing*
		//  When you pass D3D11_MAP_WRITE, D3D11_MAP_WRITE_DISCARD, or D3D11_MAP_WRITE_NO_OVERWRITE to the MapType parameter,
		//  you must ensure that your app does not read the sub-resource data to which the pData member of D3D11_MAPPED_SUBRESOURCE
		//  points because doing so can cause a significant performance penalty. The memory region to which pData points can be
		//  allocated with PAGE_WRITECOMBINE, and your app must honour all restrictions that are associated with such memory.
		// The SDK recommends using volatile pointers (but struct assignment for volatiles requires CV-qualified assignment operators)
		// Just don't read from ptr()...
		uint8_t const* data() const                      { return static_cast<uint8_t const*>(pData) + m_stride * m_range.m_beg; }
		uint8_t*       data()                            { return static_cast<uint8_t*>      (pData) + m_stride * m_range.m_beg; }
		uint8_t const* end() const                       { return static_cast<uint8_t const*>(pData) + m_stride * m_range.m_end; }
		uint8_t*       end()                             { return static_cast<uint8_t*>      (pData) + m_stride * m_range.m_end; }
		template <typename Type> Type const* ptr() const { return static_cast<Type const*>(pData) + m_range.m_beg; }
		template <typename Type> Type* ptr()             { return static_cast<Type*>      (pData) + m_range.m_beg; }
		template <typename Type> Type const* end() const { return static_cast<Type const*>(pData) + m_range.m_end; }
		template <typename Type> Type* end()             { return static_cast<Type*>      (pData) + m_range.m_end; }

		// For mapped textures
		UINT RowPitch() const
		{
			return type_ptr<D3D11_MAPPED_SUBRESOURCE>(this)->RowPitch;
		}
		UINT DepthPitch() const
		{
			return type_ptr<D3D11_MAPPED_SUBRESOURCE>(this)->DepthPitch;
		}

		// Maps a resource to CPU accessible memory
		// Only returns false if 'D3D11_MAP_FLAG_DO_NOT_WAIT' is used in 'flags'
		// Mapping a resource maps the entire thing. The 'range' and 'stride' parameters
		// just allow passing of the size of the mapped data around with the lock object.
		bool Map(ID3D11DeviceContext* dc, ID3D11Resource* res, UINT sub, size_t stride, EMap map_type, EMapFlags flags, Range range)
		{
			PR_ASSERT(PR_DBG_RDR, m_dc == nullptr, "Already mapped");
			m_dc = dc;

			// Do not wait means the caller expects the map to potentially not to work
			auto hr = m_dc->Map(res, sub, static_cast<D3D11_MAP>(map_type), static_cast<UINT>(flags), this);
			if (Failed(hr))
			{
				if (!AllSet(flags, EMapFlags::DoNotWait)) Throw(hr);
				return false;
			}
			else
			{
				m_res    = res;
				m_sub    = sub;
				m_stride = stride;
				m_range  = range;
				return true;
			}
		}
		void Unmap()
		{
			if (!m_res) return;
			m_dc->Unmap(m_res, m_sub);
			static_cast<D3D11_MAPPED_SUBRESOURCE&>(*this) = D3D11_MAPPED_SUBRESOURCE();
			m_res = nullptr;
			m_dc = nullptr;
		}
	};

	// Model Lock
	struct MLock
	{
		// Notes:
		//  - This is an object for scoped locking of a model vertex and index buffer,
		//    and for keeping track of ranges as you fill it with stuff.

		Lock   m_local_vlock;  // A local vertex lock to allow the caller to not provide one
		Lock   m_local_ilock;  // A local index lock to allow the caller to not provide one
		Model* m_model;        // Pointer to the model whose buffers we're locking
		Lock&  m_vlock;        // The vertex buffer lock for the model
		Lock&  m_ilock;        // The index buffer lock for the model

		MLock(Model* model, EMap map_type = EMap::Write, EMapFlags flags = EMapFlags::None);
		MLock(Model* model, Lock& vlock, Lock& ilock, EMap map_type = EMap::Write, EMapFlags flags = EMapFlags::None);

		MLock(MLock const&) = delete;
		MLock& operator=(MLock const&) = delete;

		//// Pointers to the locked vert/index range
		//template <typename VType> VType* vptr()
		//{
		//	return type_ptr<VType>(m_vlock.pData) + m_model->m_vrange.m_begin;
		//}
		//template <typename IType> IType* iptr()
		//{
		//	return type_ptr<IType>(m_ilock.pData) + m_model->m_irange.m_begin;
		//}
		//void* vptr(size_t vsize);
		//void* iptr(size_t isize);
	};
}
